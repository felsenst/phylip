clique.c:/* Version 4.0. (c) Copyright 1993-2013 by the University of Washington.
clique.c:{  /* this and the following are do-it-yourself garbage collectors.
clique.c:    garbage = garbage->next;
clique.c:    (*p)->vec = (aPtr)Malloc((long)chars * sizeof(boolean));
clique.c:  (*p)->next = NULL;
clique.c:{  /* collect garbage on p -- put it on front of garbage list */
clique.c:  p->next = garbage;
clique.c:  (*p)->next = NULL;
clique.c:    treenode[i]->next = NULL;
clique.c:    treenode[i]->back = NULL;
clique.c:    ActChar[i - 1] = i;
clique.c:        exxit(-1);
clique.c:    if (ancone[i - 1])
clique.c:    Factor[i - 1] = gettc(factfile);
clique.c:      if (Factor[i - 1] != Factor[i - 2])
clique.c:    ActChar[i - 1] = ActualChars;
clique.c:        ActChar[i - 1] = i;
clique.c:      ActChar[i - 1] = i;
clique.c:  j = chars / 2 + (chars / 5 - 1) / 2 - 5;
clique.c:    fprintf(outfile, "-------  ");
clique.c:    fprintf(outfile, "--------- ------\n\n");
clique.c:        exxit(-1);
clique.c:      Data[i]->vec[j - 1] = (ch == '1');
clique.c:    else if (Factor[i] != Factor[i - 1])
clique.c:      weight[ActChar[i] - 1] = oldweight[i];
clique.c:  while (ch1 > ActChar[j - 1])
clique.c:  Done1 = (ch1 != ActChar[j - 1]);
clique.c:    while (ch2 > ActChar[k - 1])
clique.c:    Done2 = (ch2 != ActChar[k - 1]);
clique.c:        if (ancone[j - 1] && ancone[k - 1])
clique.c:        else if (ancone[j - 1] && !ancone[k - 1])
clique.c:        else if (!ancone[j - 1] && ancone[k - 1])
clique.c:        if (Data[i]->vec[j - 1] && Data[i]->vec[k - 1])
clique.c:        else if (Data[i]->vec[j - 1] && !Data[i]->vec[k - 1])
clique.c:        else if (!Data[i]->vec[j - 1] && Data[i]->vec[k - 1])
clique.c:        Done2 = (ch2 != ActChar[k - 1]);
clique.c:      Done1 = (ch1 != ActChar[j - 1]);
clique.c:    fprintf(outfile, "--------- ------------- ------ -- -- -----------\n\n");
clique.c:      for (j = 1; j <= ((48 - ActualChars) / 2); j++)
clique.c:        if (Comp[i]->vec[j - 1])
clique.c:    Comp[i]->vec[i] = true;
clique.c:      Comp[i]->vec[j] = Compatible(i + 1, j + 1);
clique.c:        if (Comp[i]->vec[j])
clique.c:      Comp[j]->vec[i] = Comp[i]->vec[j];
clique.c:  memcpy(Chars2->vec, aChars, chars * sizeof(boolean));
clique.c:  memcpy(Cands2->vec, Candidates, chars * sizeof(boolean));
clique.c:  memcpy(Excl2->vec, Excluded, chars * sizeof(boolean));
clique.c:    if (Cands2->vec[j - 1])
clique.c:      Chars2->vec[j - 1] = true;
clique.c:      Cands2->vec[j - 1] = false;
clique.c:      CurSize2 += weight[j - 1];
clique.c:      Possible = CountStates(Cands2->vec);
clique.c:      Intersect(Cands2->vec, Comp2[j - 1]->vec, Cprime->vec);
clique.c:      Actual = CountStates(Cprime->vec);
clique.c:      Intersect(Excl2->vec, Comp2[j - 1]->vec, Exprime->vec);
clique.c:      for (k = 0; k <= j - 2; k++)
clique.c:        if (Exprime->vec[k] && !Futile)
clique.c:          Intersect(Cprime->vec, Comp2[k]->vec, Temp);
clique.c:          Gen1(j + 1, CurSize2, Chars2->vec, Cprime->vec, Exprime->vec);
clique.c:        Chars2->vec[j - 1] = false;
clique.c:        Excl2->vec[j - 1] = true;
clique.c:        CurSize2 -= weight[j - 1];
clique.c:  /* the ingroup state for the i-th character */
clique.c:    outstate = Data[0]->vec[i - 1];
clique.c:    outstate = ancone[i - 1];
clique.c:    outstate = Data[outgrno - 1]->vec[i - 1];
clique.c:      if (Data[SpOrder[j] - 1]->vec[ChOrder[i] - 1] == instate)
clique.c:    memcpy(grouping[++n - 1], st, setsz * sizeof(long));
clique.c:    grouping[++n - 1][k] = 1L << (SpOrder[i] % SETBITS);
clique.c:    if (aChars[ActChar[i - 1] - 1])
clique.c:      ChOrder[*MaxChars - 1] = i;
clique.c:        if (Data[j]->vec[i - 1] == instate)
clique.c:      Count[i - 1] = temp;
clique.c:      if (Count[ChOrder[j - 1] - 1] < Count[ChOrder[j] - 1])
clique.c:        temp = ChOrder[j - 1];
clique.c:        ChOrder[j - 1] = ChOrder[j];
clique.c:      if (aChars[i - 1])
clique.c:        newline(outfile, j, (long)((FormWide - 22) / 3), (long)nmlngth + 1);
clique.c:    if (aChars[ActChar[i - 1] - 1])
clique.c:        newline(outfile, j, (long)((FormWide - 22) / 3), (long)nmlngth + 1);
clique.c:        newline(outfile, j, (long)((FormWide - 15) / 3), (long)nmlngth + 1);
clique.c:    *p = treenode[j - 1];
clique.c:    (*p)->tip = true;
clique.c:    (*p)->index = j;
clique.c:  (*p)->index = 0;
clique.c:    nunode(&q->next);
clique.c:    q = q->next;
clique.c:    recontraverse(&q->back, tempset, n, MaxChars);
clique.c:        if (grouping[i - 1][j] != tempset[j])
clique.c:    ((clique_node*)q->back)->maxpos = maxpos;
clique.c:    q->back->back = q;
clique.c:        if (grouping[i - 1][j] != tempset[j])
clique.c:  q->next = *p;
clique.c:        s[i] -= 1;
clique.c:      else s[i] -= 1L << 1;
clique.c:        s[i] = ~0L - 1;
clique.c:  p = root->next;
clique.c:    if (outgroup->back == p)
clique.c:      p = p->next;
clique.c:  while (p->next != root)
clique.c:    p = p->next;
clique.c:    root->next->back->back = p->back;
clique.c:    p->back->back = root->next->back;
clique.c:    q = root->next;
clique.c:    p->next = root->next;
clique.c:    nunode(&root->next);
clique.c:    q = root->next;
clique.c:    nunode(&q->next);
clique.c:    p = q->next;
clique.c:    p->next = root;
clique.c:    q->tip = false;
clique.c:    p->tip = false;
clique.c:  q->back = outgroup;
clique.c:  p->back = outgroup->back;
clique.c:  outgroup->back->back = p;
clique.c:  outgroup->back = q;
clique.c:  if (p->tip)
clique.c:    p->xcoord = 0;
clique.c:    p->ycoord = *tipy;
clique.c:    p->ymin = *tipy;
clique.c:    p->ymax = *tipy;
clique.c:  q = p->next;
clique.c:    clique_coordinates(q->back, tipy, MaxChars);
clique.c:    if (!q->back->tip)
clique.c:      if (q->back->xcoord > maxx)
clique.c:        maxx = q->back->xcoord;
clique.c:    q = q->next;
clique.c:  first = p->next->back;
clique.c:  while (q->next != p)
clique.c:    q = q->next;
clique.c:  last = q->back;
clique.c:  p->xcoord = (MaxChars - ((clique_node*)p)->maxpos) * 3 - 2;
clique.c:    p->xcoord += 2;
clique.c:  p->ycoord = (first->ycoord + last->ycoord) / 2;
clique.c:  p->ymin = first->ymin;
clique.c:  p->ymax = last->ymax;
clique.c:    if (!p->tip)
clique.c:      r = p->next;
clique.c:        if (i >= r->back->ymin && i <= r->back->ymax)
clique.c:          q = r->back;
clique.c:          r = r->next;
clique.c:      first = p->next->back;
clique.c:      while (r->next != p)
clique.c:        r = r->next;
clique.c:      last = r->back;
clique.c:    done = (p->tip || p == q);
clique.c:    n = p->xcoord - q->xcoord;
clique.c:      n--;
clique.c:    if ((long)q->ycoord == i && !done)
clique.c:      if (!q->tip)
clique.c:        for (k = 1; k <= (((clique_node*)q)->maxpos); k++)
clique.c:            if (grouping[k - 1][l] != grouping[((clique_node*)q)->maxpos - 1][l])
clique.c:            poslist[j - 1] = k;
clique.c:        size = j - 1;
clique.c:            putc('-', outfile);
clique.c:            locpos = poslist[j - 1] * 3;
clique.c:              locpos -= poslist[j - 2] * 3;
clique.c:              locpos -= branchpos;
clique.c:              putc('-', outfile);
clique.c:            if (Rarer[ChOrder[poslist[j - 1] - 1] - 1])
clique.c:            putc('-', outfile);
clique.c:        for (k = 1; k <= (((clique_node*)q)->maxpos); k++)
clique.c:            if (grouping[k - 1][l] != grouping[((clique_node*)q)->maxpos - 1][l])
clique.c:            poslist[j - 1] = k;
clique.c:        size = j - 1;
clique.c:            putc('-', outfile);
clique.c:            locpos = poslist[j - 1] * 3;
clique.c:              locpos -= poslist[j - 2] * 3;
clique.c:              locpos -= branchpos;
clique.c:              putc('-', outfile);
clique.c:            if (Rarer[ChOrder[poslist[j - 1] - 1] - 1])
clique.c:            putc('-', outfile);
clique.c:        putc('-', outfile);
clique.c:    else if (!p->tip && (long)last->ycoord > i && (long)first->ycoord < i && (i != (long)p->ycoord || p == root))
clique.c:  if (p->ycoord == i && p->tip)
clique.c:      putc(nayme[p->index - 1][j], outfile);
clique.c:    if (Rarer[ChOrder[i] - 1])
clique.c:  for (i = 1; i <= (tipy - down); i++)
clique.c:    SpOrder[i - 1] = i;
clique.c:    if (aChars[ActChar[i - 1] - 1])
clique.c:      if (!Processed[ActChar[i - 1] - 1])
clique.c:        Rarer[i - 1] = Ingroupstate(i);
clique.c:        Processed[ActChar[i - 1] - 1] = true;
clique.c:    reroot(treenode[outgrno - 1]);
clique.c:  memcpy(Chars2->vec, aChars, chars * sizeof(boolean));
clique.c:  memcpy(Cands2->vec, Candidates, chars * sizeof(boolean));
clique.c:  memcpy(Excl2->vec, Excluded, chars * sizeof(boolean));
clique.c:    if (Cands2->vec[j - 1])
clique.c:      Chars2->vec[j - 1] = true;
clique.c:      Cands2->vec[j - 1] = false;
clique.c:      CurSize2 += weight[j - 1];
clique.c:      Possible = CountStates(Cands2->vec);
clique.c:      Intersect(Cands2->vec, Comp2[j - 1]->vec, Cprime->vec);
clique.c:      Actual = CountStates(Cprime->vec);
clique.c:      Intersect(Excl2->vec, Comp2[j - 1]->vec, Exprime->vec);
clique.c:      for (k = 0; k <= j - 2; k++)
clique.c:        if (Exprime->vec[k] && !Futile)
clique.c:          Intersect(Cprime->vec, Comp2[k]->vec, Temp);
clique.c:          Gen2(j + 1, CurSize2, Chars2->vec, Cprime->vec, Exprime->vec);
clique.c:          DoAll(Chars2->vec, Processed, Rarer2, tcount);
clique.c:        Chars2->vec[j - 1] = false;
clique.c:        Excl2->vec[j - 1] = true;
clique.c:        CurSize2 -= weight[j - 1];
clique.c:    fprintf(outfile, "------- ---- -- ----- -- ----------\n");
clique.c:    fprintf(outfile, "------- -------\n");
clique.c:  funcs->node_new = clique_node_new;
clique.c:  funcs->node_new = clique_node_new;
codml0.c:eigCalcT QR_accuracy    = 1e-6;
codml0.c:eigCalcT QR_accuracy    = 1e-24;
codml0.c:double LIKE_ACCURACY  =  1e-8;
codml0.c:void debugtree(tree*);   /* debug -- its prototype */
codml0.c:   if(t->root)
codml0.c:        printf("root = %p (%ld)\n",t->root,t->root->index);
codml0.c:   // could add here t->spp ; t->nonodes2 ; t->score
codml0.c:      printf("-------------------------------------\n");
codml0.c:      p=t->nodep[i];
codml0.c:      printf("%3s nodep[%d] == %p ->index = %ld ",
codml0.c:          p->tip > 0 ? "TIP" : "",i,p,p->index);
codml0.c:                      if(! firstNode->tip) printf("%3s p:NULL\n","");
codml0.c:                      printf("%3s p:%p b:%p ","",p,p->back);
codml0.c:                      if(p->back != NULL)
codml0.c:                          printf("(%ld)",p->back->index);
codml0.c:                      printf(" branch is %e",p->v);
codml0.c:                      printf(" init'd is %d",p->initialized);
codml0.c:                      printf(" iter is %d",p->iter);
codml0.c:                      if (!(p->back == NULL))
codml0.c:                      //if (!p->tip && !(p->back == NULL))
codml0.c:                                double val = ((codon_node*)p)->codonx[siteIndex][0][codonIndex];
codml0.c:                                    double val = ((codon_node*)p)->codonx[siteIndex][0][codonIndex];
codml0.c:                      p = p->next;
codml0.c:  // allocx(nonodes, endsite, rcategs,(ml_node**)t->nodep);
codml0.c:  t->evaluate = codon_tree_evaluate;
codml0.c:  t->nuview = codon_tree_nuview;
codml0.c:  ((ml_tree*)t)->makenewv = codon_tree_makenewv;
codml0.c:  t->tree_print_f = debugtree;
codml0.c:  t->restore_traverses = codml_restore_traverses;
codml0.c:  t->node_good_f = codml_good_node;
codml0.c:  freqr = nucFreq[0] + nucFreq[2];  /* from pages 201-202 of ... */
codml0.c:    aa1 = (freqr * freqy * ttratio) - freqag - freqct;
codml0.c:      /* // EWFIX.BUG -- 
codml0.c:          nucSubRate[i][i] -= nucSubRate[i][j];
codml0.c:  /* Fill in the non-zero elements of the matrix. */
codml0.c:    codon64matrix[row][row] = (-1.0) * rowSum;
codml0.c:    for (i = 0; i < NUM_ALL_CODONS; i++)       /* set arrays to 1, non-stop */
codml0.c:    /* create matrix61 from non-stop regions of matrix64 */
codml0.c:                    assert(i-stopcounteri < NUM_SENSE_CODONS);
codml0.c:                    assert(j-stopcounterj < NUM_SENSE_CODONS);
codml0.c:                    (*no_stop_matrix)[i-stopcounteri][j-stopcounterj] = 
codml0.c:            assert(stopcounterj == NUM_ALL_CODONS - NUM_SENSE_CODONS);
codml0.c:    assert(stopcounteri == NUM_ALL_CODONS - NUM_SENSE_CODONS);
codml0.c:  for (i = 0; i < NUM_ALL_CODONS; i++)                     /* set arrays to 1, non-stop */
codml0.c:                       /* create matrix61 from non-stop regions of matrix64 */
codml0.c:        no_stop_line[i-stopcounter] = full_line[i];
codml0.c:    assert(full_line[NUM_ALL_CODONS-1] == no_stop_line[NUM_SENSE_CODONS-1]);
codml0.c:    assert(stopcounter == NUM_ALL_CODONS - NUM_SENSE_CODONS);
codml0.c:          sum +=  tempsum * ((codon_node*)treenode[i])->codonx[j][0][k];
codml0.c:          tempsum *= w * ((codon_node*)treenode[i])->codonx[j][0][k] / sum;
codml0.c:          printf("Kimura 2-parameter\n");
codml0.c:          printf("Jukes-Cantor\n");
codml0.c:      // EWFIX.BUG -- this is overwritten too soon to be seen
codml0.c:        fprintf(outfile, "\nKimura 2-parameter base substitution model\n");
codml0.c:        fprintf(outfile, "\nJukes-Cantor base substitution model\n");
codml0.c:    numsensecodons--;
codml0.c:    numsensecodons--;
codml0.c:      exxit(-1);
codml0.c:    nonodes2--;
codml0.c:      exxit(-1);
codml0.c:    headings(chars, "Sequences", "---------");
codml0.c:    /* eat white space -- if the separator line has spaces on it*/
codml0.c:        initname(i - 1); /* reads "nmlength" chars from "infile" into nayme[i-1] */
codml0.c:              if ((strchr("ABCDGHKMNRSTUVWXY?O-",charstate)) == NULL){
codml0.c:                  printf("       The correct gap character is (-)\n");
codml0.c:                exxit(-1);
codml0.c:              if ((strchr("ABCDEFGHIKLMNPQRSTVWXYZ*?-", charstate)) == NULL) {
codml0.c:                  printf("       The correct gap character is (-)\n");
codml0.c:                exxit(-1);
codml0.c:          inputSequences[i-1][j] = charstate;
codml0.c:        exxit(-1);
codml0.c:  for (i = 1; i <= ((chars - 1) / 60 + 1); i++) {
codml0.c:        putc(nayme[j - 1][k], outfile);
codml0.c:      for (k = (i - 1) * 60 + 1; k <= l; k++) {
codml0.c:        if (j > 1 && inputSequences[j - 1][k - 1] == inputSequences[0][k - 1])
codml0.c:          charstate = inputSequences[j - 1][k - 1];
codml0.c:     location[i-1] ends up as the position in the lexicographic order
codml0.c:      others that are tied with it.  Otherwise location[i-1] is 0 
codml0.c:    alias[i - 1] = i;
codml0.c:    ally[i - 1] = i;
codml0.c:    aliasweight[i - 1] = weight[i - 1];
codml0.c:    location[i - 1] = 0;
codml0.c:    if (ally[i - 1] == i)
codml0.c:    location[alias[i - 1] - 1] = i;
codml0.c:        switch (y[i][j - 1]) {
codml0.c:          case '-':
codml0.c:                     y[i][j - 1]);
codml0.c:              exxit(-1);
codml0.c:        memset(((codon_node*)(treenode[i]))->codonx[k][l], 0, sizeof(double)*numsensecodons);
codml0.c:        line64to61(temp_line, ((codon_node*)(treenode[i]))->codonx[k][l]);
codml0.c:        treenode[i]->initialized = 1; /* EWFIX */
codml0.c:          case '-':
codml0.c:              exxit(-1);
codml0.c:        memset(((codon_node*)(treenode[i]))->codonx[k][l], 0, sizeof(double)*numsensecodons);
codml0.c:        line64to61(temp_line, ((codon_node*)(treenode[i]))->codonx[k][l]);
codml0.c:        treenode[i]->initialized = 1; /* EWFIX */
codml0.c:                           weight, curtree->nodep);
codml0.c:boolean codonfreqs_sum_to_one(void); /* debug -- its prototype */
codml0.c:  fdiff = fabs(1.0 - tmpFreq);
codml0.c:    codonfreq64[i] *= 1.0 / (1.0 - stopfreq);
codml0.c:boolean is_f_times_m_symmetric(double **);  /* debug --- its prototype */
codml0.c:            assert(fabs(ij-ji) < LIKE_ACCURACY);
codml0.c:            if(fabs(ij-ji) >= LIKE_ACCURACY) return false;
codml0.c:      d = ctheta * prob[i - 1][k] + stheta * prob[j - 1][k];
codml0.c:      prob[j - 1][k] = ctheta * prob[j - 1][k] - stheta * prob[i - 1][k];
codml0.c:      prob[i - 1][k] = d;
codml0.c:      d = ctheta * prob[k][i - 1] + stheta * prob[k][j - 1];
codml0.c:      prob[k][j - 1] = ctheta * prob[k][j - 1] - stheta * prob[k][i - 1];
codml0.c:      prob[k][i - 1] = d;
codml0.c:      coeffs(prob[i - 2][i - 1], prob[i - 2][j - 1], &c, &s);
codml0.c:{ /* QR eigenvalue-finder */
codml0.c:  for (i = n; i >= 2; i--) {
codml0.c:      TEMP = prob[i - 2][i - 2] - prob[i - 1][i - 1];
codml0.c:      TEMP1 = prob[i - 1][i - 2];
codml0.c:      approx = prob[i - 2][i - 2] + prob[i - 1][i - 1];
codml0.c:      if (prob[i - 1][i - 1] < prob[i - 2][i - 2])
codml0.c:        approx = (approx - d) / 2.0;
codml0.c:        prob[j][j] -= approx;
codml0.c:        coeffs(prob[j - 1][j - 1], prob[j][j - 1], &c, &s );
codml0.c:    } while (fabs(prob[i - 1][i - 2]) > QR_accuracy);
codml0.c:            double diff = matrix[i][j] - matrix[j][i];
codml0.c:            assert (fabs(diff) < 1e-6);
codml0.c:            if (fabs(diff) >= 1e-6) return false;
codml0.c:  /* EWFIX -- change so we use eig instead of eigmat ?? */
codml0.c:        /* EWFIX -- original had conversion using codonfreqs
codml0.c:         * users, I'd rather not do it here -- it's not part
codml0.c:      free(((codon_node*)(lrsaves[i]))->codonx[j]);
codml0.c:    free(((codon_node*)(lrsaves[i]))->codonx);
codml0.c:    free(((ml_node*)(lrsaves[i]))->underflows);
codml0.c:        ((codon_node*)(lrsaves[i]))->codonx = Malloc(endsite*sizeof(ratelike));
codml0.c:        ((ml_node*)(lrsaves[i]))->underflows = Malloc(endsite * sizeof (double));
codml0.c:            ((codon_node*)(lrsaves[i]))->codonx[j]  = (cratelike)Malloc(rcategs*sizeof(csitelike));
codml0.c:  // EWFIX.CHECK -- took this away as other tests are inside inputoptions -- if (!justwts || firstset)
codml0.c:  // EWFIX.CHECK -- probably OK already -- setuptree2(&curtree);
codml0.c:  /* EWFIX.CHECK -- these are probably being handled by the "new" phylip c++-like scheme --
codml0.c:    nuc_codon_makevalues(rcategs, curtree->nodep, endsite, spp, inputSequences, alias);
codml0.c:    aa_codon_makevalues(rcategs, curtree->nodep, endsite, spp, inputSequences, alias);
codml0.c:    sib_ptr      = sib_ptr->next;
codml0.c:    sib_back_ptr = sib_ptr->back;
codml0.c:    lw = sib_back_ptr->v;
codml0.c:    double origCorrection = ((ml_node*)p)->underflows[i]; /* just used for debugging */
codml0.c:    k = category[alias[i]-1] - 1;
codml0.c:        sib_ptr      = sib_ptr->next;
codml0.c:        sib_back_ptr = sib_ptr->back;
codml0.c:          correction += ((ml_node*)sib_back_ptr)->underflows[i];
codml0.c:        memcpy(x2, ((codon_node*)sib_back_ptr)->codonx[i][j], sizeof(csitelike));
codml0.c:        assert(sib_back_ptr->initialized || sib_back_ptr->tip);
codml0.c:          if ( codon_xx[m] > maxx && sib_index == (num_sibs - 1)) 
codml0.c:          memcpy(((codon_node*)p)->codonx[siteIndex][rcategIndex],
codml0.c:  memcpy(((ml_node*)p)->underflows,temp_underflows,endsite*sizeof(double));
codml0.c:  p->initialized = true;
codml0.c:  inittrav(p->back);
codml0.c:  double prod4m, prod5m, prod6m;        /* elements of prod4-5 for */
codml0.c:  q = p->back;
codml0.c:      memcpy(x1, ((codon_node*)p)->codonx[i][j], sizeof(csitelike));
codml0.c:      memcpy(x2, ((codon_node*)q)->codonx[i][j], sizeof(csitelike));
codml0.c:      assert(p->initialized || p->tip);
codml0.c:      assert(q->initialized || q->tip);
codml0.c:          /* EWFIX --backwards ? */
codml0.c:    /* EWFIX -- don't want to use this new sumterm above */
codml0.c:    lterm = log(sumterm) + ((ml_node*)p)->underflows[i] + 
codml0.c:      ((ml_node*)q)->underflows[i];
codml0.c:    if ((ally[i] > 0) && (location[ally[i]-1] > 0)) {
codml0.c:      lai = location[ally[i] - 1];
codml0.c:      memcpy(clai, term[lai - 1], rcategs*sizeof(double));
codml0.c:      memcpy(cslai, slopeterm[lai - 1], rcategs*sizeof(double));
codml0.c:      memcpy(cclai, curveterm[lai - 1], rcategs*sizeof(double));
codml0.c:        nulike[j]  = ((1.0 - lambda) * thelike[j]  + sumc) *  clai[j];
codml0.c:        nuslope[j] = ((1.0 - lambda) * theslope[j] + sumcs) * clai[j]
codml0.c:                   + ((1.0 - lambda) * thelike[j]  + sumc) *  cslai[j];
codml0.c:        nucurve[j] = ((1.0 - lambda) * thecurve[j] + sumcc) * clai[j]
codml0.c:             + 2.0 * ((1.0 - lambda) * theslope[j] + sumcs) * cslai[j]
codml0.c:                   + ((1.0 - lambda) * thelike[j]  + sumc) *  cclai[j];
codml0.c:        nulike[j]  = ((1.0 - lambda) * thelike[j]  + sumc);
codml0.c:        nuslope[j] = ((1.0 - lambda) * theslope[j] + sumcs);
codml0.c:        nucurve[j] = ((1.0 - lambda) * thecurve[j] + sumcc);
codml0.c:  (*curve) = curve2 / sum2 - *slope * *slope;
codml0.c:  /* Newton-Raphson algorithm improvement of a branch length */
codml0.c:  q = p->back;
codml0.c:  y = p->v;
codml0.c:      y = y + slope/fabs(curve);   /* Newton-Raphson, forced uphill-wards */
codml0.c:      if (fabs(y - yold) < epsilon)
codml0.c:    done = fabs(y-yold) < 0.1*epsilon;
codml0.c:  smoothed = (fabs(yold-yorig) < epsilon) && (yorig > 1000.0*epsilon);
codml0.c:  p->v = yold;   /* the last one that had better likelihood */
codml0.c:  q->v = yold;
codml0.c:  /* EWFIX -- is there a better place to make sure it's always done? */
codml0.c:  assert(q == p->back);
codml0.c:  inittrav(p->back);
codml0.c:  ((tree*)t)->score = oldlike;
codml0.c:    /* EWFIX -- should this be ml's version (which doesn't
codml0.c:    /* EWFIX -- moved updating of {p,q}->back-> to the generic
codml0.c:  if (n->tip) return true;
codml0.c:  if (n->back == NULL) return true;
codml0.c:    boolean underMatch =  (temp_underflows[siteIndex] == ((ml_node*)n)->underflows[siteIndex]);
codml0.c:    if (! underMatch ) printf("EWFIX %e %e\n",temp_underflows[siteIndex],((ml_node*)n)->underflows[siteIndex]);
codml0.c:              double orig = ((codon_node*)n)->codonx[siteIndex][rateCatIndex][codonIndex];
codml0.c:              double diff = fabs(newV - orig);
codml0.c:              assert(diff < 1e-5);
codml0.c:              if (diff > 1e-5) return false;
codml0.c:    /* EWFIX.CHECK -- can this be 0.0? any upper limit?*/
codml0.c:  q = p->back;
codml0.c:  y = p->v;
codml0.c:    k = category[alias[i]-1] - 1;
codml0.c:      memcpy(x1, ((codon_node*)p)->codonx[i][j], sizeof(csitelike));
codml0.c:      memcpy(x2, ((codon_node*)q)->codonx[i][j], sizeof(csitelike));
codml0.c:      assert(p->initialized || p->tip);
codml0.c:      assert(q->initialized || q->tip);
codml0.c:    lterm = log(sumterm) + ((ml_node*)p)->underflows[i] + 
codml0.c:      ((ml_node*)q)->underflows[i];
codml0.c:      l0gf[which - 1][i] = lterm;
codml0.c:    if ((ally[i] > 0) && (location[ally[i]-1] > 0)) {
codml0.c:      lai = location[ally[i] - 1];
codml0.c:      memcpy(clai, contribution[lai - 1], rcategs*sizeof(double));
codml0.c:        nulike[j] = ((1.0 - lambda) * like[j] + sumc) * clai[j];
codml0.c:        nulike[j] = ((1.0 - lambda) * like[j] + sumc);
codml0.c:  curtree->score = sum;
codml0.c:    l0gl[which - 1] = sum;
codml0.c:    codon_node_copy(a->nodep[i], b->nodep[i]);
codml0.c:    if (a->nodep[i]->back) {
codml0.c:      if (a->nodep[i]->back == a->nodep[a->nodep[i]->back->index - 1])
codml0.c:        b->nodep[i]->back = b->nodep[a->nodep[i]->back->index - 1];
codml0.c:      else if (a->nodep[i]->back == a->nodep[a->nodep[i]->back->index - 1]->next)
codml0.c:        b->nodep[i]->back = b->nodep[a->nodep[i]->back->index - 1]->next;
codml0.c:        b->nodep[i]->back = b->nodep[a->nodep[i]->back->index - 1]->next->next;
codml0.c:    else b->nodep[i]->back = NULL;
codml0.c:    p = a->nodep[i];
codml0.c:    q = b->nodep[i];
codml0.c:      if (p->back) {
codml0.c:        if (p->back == a->nodep[p->back->index - 1])
codml0.c:          q->back = b->nodep[p->back->index - 1];
codml0.c:        else if (p->back == a->nodep[p->back->index - 1]->next)
codml0.c:          q->back = b->nodep[p->back->index - 1]->next;
codml0.c:          q->back = b->nodep[p->back->index - 1]->next->next;
codml0.c:        q->back = NULL;
codml0.c:      p = p->next;
codml0.c:      q = q->next;
codml0.c:  b->score = a->score;
codml0.c:  b->root = a->root;               /* start used in dnaml only */
codml0.c:  b->root = a->root;                 /* root used in dnamlk only */
codml0.c:  if (p->tip) {
codml0.c:    p->xcoord = (long)(over * lengthsum + 0.5);
codml0.c:    p->ycoord = (*tipy);
codml0.c:    p->ymin = (*tipy);
codml0.c:    p->ymax = (*tipy);
codml0.c:  q = p->next;
codml0.c:    xx = q->v;
codml0.c:    codml_coordinates(q->back, lengthsum + xx, tipy, tipmax);
codml0.c:    q = q->next;
codml0.c:  } while ((p == curtree->root || p != q) &&
codml0.c:           (p != curtree->root || p->next != q));
codml0.c:  first = p->next->back;
codml0.c:  while (q->next != p)
codml0.c:    q = q->next;
codml0.c:  last = q->back;
codml0.c:  p->xcoord = (long)(over * lengthsum + 0.5);
codml0.c:  if (p == curtree->root)
codml0.c:    p->ycoord = p->next->next->back->ycoord;
codml0.c:    p->ycoord = (first->ycoord + last->ycoord) / 2;
codml0.c:  p->ymin = first->ymin;
codml0.c:  p->ymax = last->ymax;
codml0.c:  codml_coordinates(curtree->root, 0.0, &tipy, &tipmax);
codml0.c:  for (i = 1; i <= (tipy - down); i++)
codml0.c:  codon_slopecurv(p, p->v, &like, &slope, &curv);
codml0.c:  tt = p->v;
codml0.c:  p->v = epsilon;
codml0.c:  p->back->v = epsilon;
codml0.c:  aa = curtree->evaluate(curtree,p, false);
codml0.c:  p->v = tt;
codml0.c:  p->back->v = tt;
codml0.c:  (*sumlr) = curtree->evaluate(curtree,p, false) - aa;
codml0.c:  if (curv < -epsilon) {
codml0.c:    (*s1) = p->v + (-slope - sqrt(slope * slope -  3.841 * curv)) / curv;
codml0.c:    (*s2) = p->v + (-slope + sqrt(slope * slope -  3.841 * curv)) / curv;
codml0.c:    (*s1) = -1.0;
codml0.c:    (*s2) = -1.0;
codml0.c:  if (!p->tip && !p->initialized)
codml0.c:    curtree->nuview(curtree,p);
codml0.c:  if (!p->back->tip && !p->back->initialized)
codml0.c:    curtree->nuview(curtree,p->back);
codml0.c:  q = p->back;
codml0.c:  if (q->tip) {
codml0.c:      putc(nayme[q->index-1][i], outfile);
codml0.c:    fprintf(outfile, "  %4ld          ", q->index - spp);
codml0.c:  if (p->tip) {
codml0.c:      putc(nayme[p->index-1][i], outfile);
codml0.c:    fprintf(outfile, "%4ld      ", p->index - spp);
codml0.c:  fprintf(outfile, "%15.5f", q->v);
codml0.c:  if (!usertree || (usertree && !lngths) || p->iter || reusertree) {
codml0.c:  if (!p->tip) {
codml0.c:      sib_ptr = sib_ptr->next;
codml0.c:      describe(sib_ptr->back);
codml0.c:  if (p->tip)
codml0.c:        putc(inputSequences[p->index-1][n], outfile);
codml0.c:        putc(inputSequences[p->index-1][n*3], outfile);
codml0.c:        putc(inputSequences[p->index-1][n*3+1], outfile);
codml0.c:        putc(inputSequences[p->index-1][n*3+2], outfile);
codml0.c:    if ((ally[n] == 0) || (location[ally[n]-1] == 0))
codml0.c:      assert(p->initialized || p->tip);
codml0.c:      j = location[ally[n]-1] - 1;
codml0.c:        f = ((codon_node*)p)->codonx[j][mx-1][i];
codml0.c:        if (!p->tip) {
codml0.c:            q = q->next;
codml0.c:            f *= ((codon_node*)q)->codonx[j][mx-1][i];
codml0.c:          f = exp(log(f)/(num_sibs-1.0));
codml0.c:        fprintf(outfile, "%s ", codonStrings[first]); // EWFIX -- check
codml0.c:        fprintf(outfile, "%s ", lowCodon); // EWFIX -- check
codml0.c:        mx = mp[n][mx - 1];
codml0.c:  if (p->tip) {
codml0.c:      putc(nayme[p->index-1][i], outfile);
codml0.c:    fprintf(outfile, "%4ld      ", p->index - spp);
codml0.c:  if (!p->tip) {
codml0.c:    for (q = p->next; q != p; q = q->next) {
codml0.c:      rectrav(q->back, m, n);
codml0.c:  fprintf(outfile, "Ln Likelihood = %11.5f\n", curtree->score);
codml0.c:  fprintf(outfile, " -------        ---            ------");
codml0.c:    fprintf(outfile, "      ------- ---------- ------");
codml0.c:    if (curtree->nodep[i]) {
codml0.c:      num_sibs = count_sibs (curtree->nodep[i]);
codml0.c:      sib_ptr  = curtree->nodep[i];
codml0.c:        sib_ptr->initialized = false;
codml0.c:        sib_ptr              = sib_ptr->next;
codml0.c:  describe(curtree->root->back);
codml0.c:  num_sibs = count_sibs(curtree->root);
codml0.c:  sib_ptr  = curtree->root;
codml0.c:    sib_ptr = sib_ptr->next;
codml0.c:    describe(sib_ptr->back);
codml0.c:  curtree->evaluate(curtree,curtree->root, false);
codml0.c:    for (i = workingSites - 1; i >= 0; i--) {
codml0.c:        nulike[j] = (1.0 - lambda + lambda * probcat[j]) * like[j];
codml0.c:            if (lambda * probcat[k - 1] * like[k - 1] > nulike[j]) {
codml0.c:              nulike[j] = lambda * probcat[k - 1] * like[k - 1];
codml0.c:        if ((ally[i] > 0) && (location[ally[i]-1] > 0))
codml0.c:          nulike[j] *= contribution[location[ally[i] - 1] - 1][j];
codml0.c:      if (probcat[i - 1] * like[i - 1] > mode) {
codml0.c:        mode = probcat[i - 1] * like[i - 1];
codml0.c:      mx = mp[i - 1][mx - 1];
codml0.c:    for (i = workingSites - 1; i >= 0; i--) {
codml0.c:        nulike[j] = (1.0 - lambda + lambda * probcat[j]) * like[j];
codml0.c:              nulike[j] += lambda * probcat[k - 1] * like[k - 1];
codml0.c:        if ((ally[i] > 0) && (location[ally[i]-1] > 0))
codml0.c:          nulike[j] *= contribution[location[ally[i] - 1] - 1][j];
codml0.c:        nulike[j] = (1.0 - lambda + lambda * probcat[j]) * like[j];
codml0.c:              nulike[j] += lambda * probcat[k - 1] * like[k - 1];
codml0.c:    for (i = 0; (i < 13) && (i < ((workingSites + (workingSites-1)/10 - 39) / 2)); i++)
codml0.c:        k = workingSites - 1;
codml0.c:      rectrav(curtree->root, i, k);
codml0.c:      rectrav(curtree->root->back, i, k);
codml0.c:    (*p)->index = nodei;
codml0.c:    (*p)->tip = false;
codml0.c:    ((ml_node*)*p)->allocx((ml_node*)*p, endsite, rcategs);
codml0.c:    nodep[(*p)->index - 1] = (*p);
codml0.c:    ((ml_node*)*p)->allocx((ml_node*)*p, endsite, rcategs);
codml0.c:    (*p)->index = nodei;
codml0.c:    (*p)->initialized = false;
codml0.c:    (*p)->v = initialv;
codml0.c:    (*p)->iter = true;
codml0.c:    if ((*p)->back != NULL){
codml0.c:      (*p)->back->iter = true;
codml0.c:      (*p)->back->v = initialv;
codml0.c:      (*p)->back->initialized = false;
codml0.c:    (*p)->v = valyew / divisor;
codml0.c:    (*p)->iter = false;
codml0.c:    if ((*p)->back != NULL) {
codml0.c:      (*p)->back->v = (*p)->v;
codml0.c:      (*p)->back->iter = false;
codml0.c:  if (p->tip) {
codml0.c:      if (nayme[p->index-1][i - 1] != ' ')
codml0.c:      c = nayme[p->index-1][i];
codml0.c:    q = p->next;
codml0.c:      dnaml_treeout(q->back);
codml0.c:      q = q->next;
codml0.c:    } while ((p == curtree->root || p != q) &&
codml0.c:             (p != curtree->root || p->next != q));
codml0.c:  x = p->v;
codml0.c:    w = (long)(0.43429448222 * log(-x)) + 1;
codml0.c:  if (p == curtree->root)
codml0.c:      free(((codon_node*)treenode[i])->codonx[j]);
codml0.c:    free(((codon_node*)treenode[i])->codonx);
codml0.c:          free(((codon_node*)p)->codonx[k]);
codml0.c:        free(((codon_node*)p)->codonx);
codml0.c:        p = p->next;
codml0.c:  long numsibs = count_sibs(t->root);
codml0.c:    q = t->root;
codml0.c:    r = t->root;
codml0.c:    while ( q->next != t->root )
codml0.c:      q = q->next;
codml0.c:    q->next = t->root->next;
codml0.c:    t->root = q;
codml0.c:    t->release_forknode(t, r);
codml0.c:    t->nodep[spp] = q;
codml0.c:    newl = t->root->next->oldlen + t->root->next->next->oldlen;
codml0.c:    t->root->next->back->oldlen = newl;
codml0.c:    t->root->next->next->back->oldlen = newl;
codml0.c:    newl = t->root->next->v + t->root->next->next->v;
codml0.c:    t->root->next->back->v = newl;
codml0.c:    t->root->next->next->back->v = newl;
codml0.c:    t->root->next->back->back = t->root->next->next->back;
codml0.c:    t->root->next->next->back->back = t->root->next->back;
codml0.c:    t->release_fork(t,t->root);
codml0.c:    (*p)->index = nodei;
codml0.c:    (*p)->tip = false;
codml0.c:    nodep[(*p)->index - 1] = (*p);
codml0.c:    (*p)->index = nodei;
codml0.c:    (*p)->initialized = false;
codml0.c:    (*p)->v = initialv;
codml0.c:    (*p)->iter = true;
codml0.c:    if ((*p)->back != NULL){
codml0.c:      (*p)->back->iter = true;
codml0.c:      (*p)->back->v = initialv;
codml0.c:      (*p)->back->initialized = false;
codml0.c:    (*p)->v = valyew / divisor;
codml0.c:    (*p)->iter = false;
codml0.c:    if ((*p)->back != NULL) {
codml0.c:      (*p)->back->v = (*p)->v;
codml0.c:      (*p)->back->iter = false;
codml0.c:      fprintf(outfile, "\nUser-defined tree");
codml0.c:    /* This taken out of tree read, used to be [spp-1], but referring
codml0.c:       to [0] produces output identical to what the pre-modified dnaml
codml0.c:         since multiple trees require re-initialization */
codml0.c:      treeread(intree, &curtree->root, dummy_treenode, &goteof, &dummy_first,
codml0.c:                      curtree->nodep, &nextnode, &haslengths, &grbg,
codml0.c:        printf ("\tNumber of trees actually in file:\t%ld.\n\n", which - 1);
codml0.c:        exxit (-1);
codml0.c:      curtree->root = curtree->nodep[0]->back;
codml0.c:        curtree->root = curtree->nodep[outgrno - 1]->back;
codml0.c:      // EWFIX -- proml has reusertree stuff in here
codml0.c:        dnaml_treeout(curtree->root);
codml0.c:        codon_freex_notip(nextnode, curtree->nodep);
codml0.c:        gdispose(curtree->root, &grbg, curtree->nodep);
codml0.c:      standev2(numtrees, maxwhich, 0, endsite-1, maxlogl,
codml0.c:      enterorder[i - 1] = i;
codml0.c:    curtree->root = curtree->nodep[enterorder[0] - 1]->back;
codml0.c:      assert(curtree->tree_good_f(curtree)); 
codml0.c:        curtree->copy(curtree,priortree);
codml0.c:      curtree->addtraverse(curtree,curtree->nodep[enterorder[nextsp - 1] - 1],
codml0.c:                  curtree->root, true,&qwhere,&bestyet,bestree,priortree,smoothit,NULL);
codml0.c:        bestree->copy(bestree,curtree);
codml0.c:        curtree->insert_(curtree,curtree->nodep[enterorder[nextsp - 1] - 1],
codml0.c:        curtree->copy(curtree,bestree);
codml0.c:        bestyet = curtree->score;
codml0.c:        writename(nextsp - 1, 1, enterorder);
codml0.c:      assert(curtree->tree_good_f(curtree)); /* EWFIX */
codml0.c:        curtree->globrearrange(curtree,progress,smoothit);
codml0.c:          curtree->locrearrange(curtree, curtree->nodep[enterorder[0] - 1],
codml0.c:          curtree->smoothall(curtree,curtree->root);
codml0.c:          bestyet = curtree->score;
codml0.c:      assert(curtree->tree_good_f(curtree)); /* EWFIX */
codml0.c:    curtree->copy(curtree, bestree);
codml0.c:            bestree->copy(bestree, bestree2);
codml0.c:            if (bestree2->score < bestree->score)
codml0.c:                bestree->copy(bestree, bestree2);
codml0.c:        bestree2->copy(bestree2, curtree);
codml0.c:      curtree->root = curtree->nodep[outgrno - 1]->back;
codml0.c:        dnaml_treeout(curtree->root);
codml0.c:  free_all_codonx(nonodes2, curtree->nodep);
codml0.c:    free_all_codonx(nonodes2, bestree->nodep);
codml0.c:    free_all_codonx(nonodes2, priortree->nodep);
codml0.c:      free_all_codonx(nonodes2, bestree2->nodep);
codml0.c:  funcs->new_node = codon_node_new;
codml0.c:  funcs->tree_new = codon_tree_new;
codml0.c:    curtree->free(curtree);
codml0.c:    bestree->free(bestree);
codml0.c:    priortree->free(priortree);
codml0.c:    bestree2->free(bestree2);
codml.c:/* Version 4.0. (c) Copyright 2009-2013 by the University of Washington.
codml.c:eigCalcT QR_accuracy    = 1e-6;
codml.c:eigCalcT QR_accuracy    = 1e-24;
codml.c:double LIKE_ACCURACY  =  1e-8;
codml.c:  if(t->root)
codml.c:    printf("root = %p (%ld)\n", (void *)t->root, t->root->index);
codml.c:  // could add here t->spp ; t->nonodes2 ; t->score
codml.c:    printf("-------------------------------------\n");
codml.c:    p=t->nodep[i];
codml.c:    printf("%3s nodep[%d] == %p ->index = %ld ", p->tip > 0 ? "TIP" : "", i, (void *)p, p->index);
codml.c:          if(! firstNode->tip) printf("%3s p:NULL\n", "");
codml.c:          printf("%3s p:%p b:%p ", "", (void *)p, (void *)p->back);
codml.c:          if(p->back != NULL)
codml.c:            printf("(%ld)", p->back->index);
codml.c:          printf(" branch is %e", p->v);
codml.c:          printf(" init'd is %d", p->initialized);
codml.c:          printf(" iter is %d", p->iter);
codml.c:          if (!(p->back == NULL))
codml.c:            //if (!p->tip && !(p->back == NULL))
codml.c:                double val = ((codon_node*)p)->codonx[siteIndex][0][codonIndex];
codml.c:                  double val = ((codon_node*)p)->codonx[siteIndex][0][codonIndex];
codml.c:          p = p->next;
codml.c:  // allocx(nonodes, endsite, rcategs, (ml_node**)t->nodep);
codml.c:  t->evaluate = codon_tree_evaluate;
codml.c:  t->nuview = codon_tree_nuview;
codml.c:  ((ml_tree*)t)->makenewv = codon_tree_makenewv;
codml.c:  t->tree_print_f = debugtree;
codml.c:  t->restore_traverses = codml_restore_traverses;
codml.c:  t->node_good_f = codml_node_good;
codml.c:  freqr = nucFreq[0] + nucFreq[2];  /* from pages 201-202 of ... */
codml.c:    aa1 = (freqr * freqy * ttratio) - freqag - freqct;
codml.c:        nucSubRate[i][i] -= nucSubRate[i][j];
codml.c:  /* Fill in the non-zero elements of the matrix. */
codml.c:    codon64matrix[row][row] = (-1.0) * rowSum;
codml.c:  for (i = 0; i < NUM_ALL_CODONS; i++)       /* set arrays to 1, non-stop */
codml.c:  /* create matrix61 from non-stop regions of matrix64 */
codml.c:          assert(i-stopcounteri < NUM_SENSE_CODONS);
codml.c:          assert(j-stopcounterj < NUM_SENSE_CODONS);
codml.c:          (*no_stop_matrix)[i-stopcounteri][j-stopcounterj] =
codml.c:      assert(stopcounterj == NUM_ALL_CODONS - NUM_SENSE_CODONS);
codml.c:  assert(stopcounteri == NUM_ALL_CODONS - NUM_SENSE_CODONS);
codml.c:  for (i = 0; i < NUM_ALL_CODONS; i++)                     /* set arrays to 1, non-stop */
codml.c:  /* create matrix61 from non-stop regions of matrix64 */
codml.c:      no_stop_line[i-stopcounter] = full_line[i];
codml.c:  assert(full_line[NUM_ALL_CODONS-1] == no_stop_line[NUM_SENSE_CODONS-1]);
codml.c:  assert(stopcounter == NUM_ALL_CODONS - NUM_SENSE_CODONS);
codml.c:          sum +=  tempsum * ((codon_node*)treenode[i])->codonx[j][0][k];
codml.c:          tempsum *= w * ((codon_node*)treenode[i])->codonx[j][0][k] / sum;
codml.c:          printf("Kimura 2-parameter\n");
codml.c:          printf("Jukes-Cantor\n");
codml.c:        fprintf(outfile, "\nKimura 2-parameter base substitution model\n");
codml.c:        fprintf(outfile, "\nJukes-Cantor base substitution model\n");
codml.c:    numsensecodons--;
codml.c:    numsensecodons--;
codml.c:        fprintf(outfile, "\nKimura 2-parameter base substitution model\n");
codml.c:        fprintf(outfile, "\nJukes-Cantor base substitution model\n");
codml.c:      exxit(-1);
codml.c:    nonodes2--;
codml.c:    exxit(-1);
codml.c:    headings(chars, "Sequences", "---------");
codml.c:    /* eat white space -- if the separator line has spaces on it*/
codml.c:        initname(i - 1); /* reads "nmlength" chars from "infile" into nayme[i-1] */
codml.c:            if ((strchr("ABCDGHKMNRSTUVWXY?O-", charstate)) == NULL)
codml.c:                printf("        The correct gap character is (-).\n");
codml.c:              exxit(-1);
codml.c:            if ((strchr("ABCDEFGHIKLMNPQRSTVWXYZ*?-", charstate)) == NULL)
codml.c:                printf("        The correct gap character is (-).\n");
codml.c:              exxit(-1);
codml.c:          inputSequences[i-1][j] = charstate;
codml.c:        exxit(-1);
codml.c:  for (i = 1; i <= ((chars - 1) / 60 + 1); i++)
codml.c:        putc(nayme[j - 1][k], outfile);
codml.c:      for (k = (i - 1) * 60 + 1; k <= l; k++)
codml.c:        if (j > 1 && inputSequences[j - 1][k - 1] == inputSequences[0][k - 1])
codml.c:          charstate = inputSequences[j - 1][k - 1];
codml.c:     location[i-1] ends up as the position in the lexicographic order
codml.c:     others that are tied with it.  Otherwise location[i-1] is 0
codml.c:    alias[i - 1] = i;
codml.c:    ally[i - 1] = i;
codml.c:    aliasweight[i - 1] = weight[i - 1];
codml.c:    location[i - 1] = 0;
codml.c:    if (ally[i - 1] == i)
codml.c:    location[alias[i - 1] - 1] = i;
codml.c:        switch (y[i][j - 1])
codml.c:          case '-':
codml.c:            printf("ERROR:  Unexpected amino acid symbol \'%c\' created internally; program error.", y[i][j - 1]);
codml.c:            exxit(-1);
codml.c:        memset(((codon_node*)(treenode[i]))->codonx[k][l], 0, sizeof(double)*numsensecodons);
codml.c:        line64to61(temp_line, ((codon_node*)(treenode[i]))->codonx[k][l]);
codml.c:        treenode[i]->initialized = 1; // BUG.969 -- why?
codml.c:            case '-':
codml.c:              exxit(-1);
codml.c:        memset(((codon_node*)(treenode[i]))->codonx[k][l], 0, sizeof(double)*numsensecodons);
codml.c:        line64to61(temp_line, ((codon_node*)(treenode[i]))->codonx[k][l]);
codml.c:        treenode[i]->initialized = 1; // BUG.969 -- why?
codml.c:      codml_empiricalfreqs(&nucFreq[0], &nucFreq[1], &nucFreq[2], &nucFreq[3], weight, curtree->nodep);
codml.c:  fdiff = fabs(1.0 - tmpFreq);
codml.c:    codonfreq64[i] *= 1.0 / (1.0 - stopfreq);
codml.c:      assert(fabs(ij-ji) < LIKE_ACCURACY);
codml.c:      if(fabs(ij-ji) >= LIKE_ACCURACY) return false;
codml.c:      d = ctheta * prob[i - 1][k] + stheta * prob[j - 1][k];
codml.c:      prob[j - 1][k] = ctheta * prob[j - 1][k] - stheta * prob[i - 1][k];
codml.c:      prob[i - 1][k] = d;
codml.c:      d = ctheta * prob[k][i - 1] + stheta * prob[k][j - 1];
codml.c:      prob[k][j - 1] = ctheta * prob[k][j - 1] - stheta * prob[k][i - 1];
codml.c:      prob[k][i - 1] = d;
codml.c:      coeffs(prob[i - 2][i - 1], prob[i - 2][j - 1], &c, &s);
codml.c:{ /* QR eigenvalue-finder */
codml.c:  for (i = n; i >= 2; i--)
codml.c:      TEMP = prob[i - 2][i - 2] - prob[i - 1][i - 1];
codml.c:      TEMP1 = prob[i - 1][i - 2];
codml.c:      approx = prob[i - 2][i - 2] + prob[i - 1][i - 1];
codml.c:      if (prob[i - 1][i - 1] < prob[i - 2][i - 2])
codml.c:        approx = (approx - d) / 2.0;
codml.c:        prob[j][j] -= approx;
codml.c:        coeffs(prob[j - 1][j - 1], prob[j][j - 1], &c, &s );
codml.c:    } while (fabs(prob[i - 1][i - 2]) > QR_accuracy);
codml.c:      double diff = matrix[i][j] - matrix[j][i];
codml.c:      assert (fabs(diff) < 1e-6);
codml.c:      if (fabs(diff) >= 1e-6) return false;
codml.c:  /* BUG.969 -- change so we use eig instead of eigmat ?? */
codml.c:      /* BUG.969 -- original had conversion using codonfreqs
codml.c:       * users, I'd rather not do it here -- it's not part
codml.c:      free(((codon_node*)(lrsaves[i]))->codonx[j]);
codml.c:    free(((codon_node*)(lrsaves[i]))->codonx);
codml.c:    free(((ml_node*)(lrsaves[i]))->underflows);
codml.c:    ((codon_node*)(lrsaves[i]))->codonx = Malloc(endsite * sizeof(ratelike));
codml.c:    ((ml_node*)(lrsaves[i]))->underflows = Malloc(endsite * sizeof (double));
codml.c:      ((codon_node*)(lrsaves[i]))->codonx[j]  = (cratelike)Malloc(rcategs * sizeof(csitelike));
codml.c:  // BUG.969 -- took this away as other tests are inside inputoptions -- if (!justwts || firstset)
codml.c:  // BUG.969 -- probably OK already -- setuptree2(&curtree);
codml.c:  // BUG.969 -- these are probably being handled by the "new" phylip c++-like scheme.
codml.c:    nuc_codon_makevalues(rcategs, curtree->nodep, endsite, spp, inputSequences, alias);
codml.c:    aa_codon_makevalues(rcategs, curtree->nodep, endsite, spp, inputSequences, alias);
codml.c:    sib_ptr      = sib_ptr->next;
codml.c:    sib_back_ptr = sib_ptr->back;
codml.c:    lw = sib_back_ptr->v;
codml.c:    double origCorrection = ((ml_node*)p)->underflows[i]; /* just used for debugging */
codml.c:    // k = category[alias[i]-1] - 1;
codml.c:        sib_ptr      = sib_ptr->next;
codml.c:        sib_back_ptr = sib_ptr->back;
codml.c:          correction += ((ml_node*)sib_back_ptr)->underflows[i];
codml.c:        memcpy(x2, ((codon_node*)sib_back_ptr)->codonx[i][j], sizeof(csitelike));
codml.c:        assert(sib_back_ptr->initialized || sib_back_ptr->tip);
codml.c:          if ( codon_xx[m] > maxx && sib_index == (num_sibs - 1))
codml.c:      memcpy(((codon_node*)p)->codonx[siteIndex][rcategIndex], temp_codonx[siteIndex][rcategIndex], sizeof(csitelike));
codml.c:  memcpy(((ml_node*)p)->underflows, temp_underflows, endsite * sizeof(double));
codml.c:  p->initialized = true;
codml.c:  inittrav(t, p->back);
codml.c:  double prod4m, prod5m, prod6m;        /* elements of prod4-5 for */
codml.c:  q = p->back;
codml.c:      memcpy(x1, ((codon_node*)p)->codonx[i][j], sizeof(csitelike));
codml.c:      memcpy(x2, ((codon_node*)q)->codonx[i][j], sizeof(csitelike));
codml.c:      assert(p->initialized || p->tip);
codml.c:      assert(q->initialized || q->tip);
codml.c:          /* BUG.969 --backwards ? */
codml.c:    /* BUG.969 -- don't want to use this new sumterm above */
codml.c:    lterm = log(sumterm) + ((ml_node*)p)->underflows[i] +
codml.c:      ((ml_node*)q)->underflows[i];
codml.c:    if ((ally[i] > 0) && (location[ally[i]-1] > 0))
codml.c:      lai = location[ally[i] - 1];
codml.c:      memcpy(clai, term[lai - 1], rcategs * sizeof(double));
codml.c:      memcpy(cslai, slopeterm[lai - 1], rcategs * sizeof(double));
codml.c:      memcpy(cclai, curveterm[lai - 1], rcategs * sizeof(double));
codml.c:        nulike[j]  = ((1.0 - lambda) * thelike[j]  + sumc) *  clai[j];
codml.c:        nuslope[j] = ((1.0 - lambda) * theslope[j] + sumcs) * clai[j]
codml.c:          + ((1.0 - lambda) * thelike[j]  + sumc) *  cslai[j];
codml.c:        nucurve[j] = ((1.0 - lambda) * thecurve[j] + sumcc) * clai[j]
codml.c:          + 2.0 * ((1.0 - lambda) * theslope[j] + sumcs) * cslai[j]
codml.c:          + ((1.0 - lambda) * thelike[j]  + sumc) *  cclai[j];
codml.c:        nulike[j]  = ((1.0 - lambda) * thelike[j]  + sumc);
codml.c:        nuslope[j] = ((1.0 - lambda) * theslope[j] + sumcs);
codml.c:        nucurve[j] = ((1.0 - lambda) * thecurve[j] + sumcc);
codml.c:  (*curve) = curve2 / sum2 - *slope * *slope;
codml.c:  /* Newton-Raphson algorithm improvement of a branch length */
codml.c:  q = p->back;
codml.c:  y = p->v;
codml.c:      y = y + slope/fabs(curve);        /* Newton-Raphson, forced uphill-wards */
codml.c:      if (fabs(y - yold) < epsilon)
codml.c:    done = fabs(y-yold) < 0.1*epsilon;
codml.c:  smoothed = (fabs(yold-yorig) < epsilon) && (yorig > 1000.0*epsilon);
codml.c:  p->v = yold;                          /* the last one that had better likelihood */
codml.c:  q->v = yold;
codml.c:  /* BUG.969 -- is there a better place to make sure it's always done? */
codml.c:  assert(q == p->back);
codml.c:  inittrav(t, p->back);
codml.c:  ((tree*)t)->score = oldlike;
codml.c:  /* BUG.969 -- should this be ml's version (which doesn't
codml.c:  /* BUG.969 -- moved updating of {p, q}->back-> to the generic version */
codml.c:  if (n->tip) return true;
codml.c:  if (n->back == NULL) return true;
codml.c:    boolean underMatch =  (temp_underflows[siteIndex] == ((ml_node*)n)->underflows[siteIndex]);
codml.c:    // if (! underMatch ) printf("BUG.969 %e %e\n", temp_underflows[siteIndex], ((ml_node*)n)->underflows[siteIndex]);
codml.c:        double orig = ((codon_node*)n)->codonx[siteIndex][rateCatIndex][codonIndex];
codml.c:        double diff = fabs(newV - orig);
codml.c:        assert(diff < 1e-5);
codml.c:        if (diff > 1e-5) return false;
codml.c:    /* BUG.969-- can this be 0.0? any upper limit?*/
codml.c:  q = p->back;
codml.c:  y = p->v;
codml.c:    k = category[alias[i]-1] - 1;
codml.c:      memcpy(x1, ((codon_node*)p)->codonx[i][j], sizeof(csitelike));
codml.c:      memcpy(x2, ((codon_node*)q)->codonx[i][j], sizeof(csitelike));
codml.c:      assert(p->initialized || p->tip);
codml.c:      assert(q->initialized || q->tip);
codml.c:    lterm = log(sumterm) + ((ml_node*)p)->underflows[i] +
codml.c:      ((ml_node*)q)->underflows[i];
codml.c:      l0gf[which - 1][i] = lterm;
codml.c:    if ((ally[i] > 0) && (location[ally[i]-1] > 0))
codml.c:      lai = location[ally[i] - 1];
codml.c:      memcpy(clai, contribution[lai - 1], rcategs * sizeof(double));
codml.c:        nulike[j] = ((1.0 - lambda) * like[j] + sumc) * clai[j];
codml.c:        nulike[j] = ((1.0 - lambda) * like[j] + sumc);
codml.c:  curtree->score = sum;
codml.c:    l0gl[which - 1] = sum;
codml.c:    codon_node_copy(a->nodep[i], b->nodep[i]);
codml.c:    if (a->nodep[i]->back)
codml.c:      if (a->nodep[i]->back == a->nodep[a->nodep[i]->back->index - 1])
codml.c:        b->nodep[i]->back = b->nodep[a->nodep[i]->back->index - 1];
codml.c:      else if (a->nodep[i]->back == a->nodep[a->nodep[i]->back->index - 1]->next)
codml.c:        b->nodep[i]->back = b->nodep[a->nodep[i]->back->index - 1]->next;
codml.c:        b->nodep[i]->back = b->nodep[a->nodep[i]->back->index - 1]->next->next;
codml.c:    else b->nodep[i]->back = NULL;
codml.c:    p = a->nodep[i];
codml.c:    q = b->nodep[i];
codml.c:      if (p->back)
codml.c:        if (p->back == a->nodep[p->back->index - 1])
codml.c:          q->back = b->nodep[p->back->index - 1];
codml.c:        else if (p->back == a->nodep[p->back->index - 1]->next)
codml.c:          q->back = b->nodep[p->back->index - 1]->next;
codml.c:          q->back = b->nodep[p->back->index - 1]->next->next;
codml.c:        q->back = NULL;
codml.c:      p = p->next;
codml.c:      q = q->next;
codml.c:  b->score = a->score;
codml.c:  b->root = a->root;               /* start used in dnaml only */
codml.c:  b->root = a->root;                 /* root used in dnamlk only */
codml.c:  if (p->tip)
codml.c:    p->xcoord = (long)(over * lengthsum + 0.5);
codml.c:    p->ycoord = (*tipy);
codml.c:    p->ymin = (*tipy);
codml.c:    p->ymax = (*tipy);
codml.c:  q = p->next;
codml.c:    xx = q->v;
codml.c:    codml_coordinates(q->back, lengthsum + xx, tipy, tipmax);
codml.c:    q = q->next;
codml.c:  } while ((p == curtree->root || p != q) &&
codml.c:           (p != curtree->root || p->next != q));
codml.c:  first = p->next->back;
codml.c:  while (q->next != p)
codml.c:    q = q->next;
codml.c:  last = q->back;
codml.c:  p->xcoord = (long)(over * lengthsum + 0.5);
codml.c:  if (p == curtree->root)
codml.c:    p->ycoord = p->next->next->back->ycoord;
codml.c:    p->ycoord = (first->ycoord + last->ycoord) / 2;
codml.c:  p->ymin = first->ymin;
codml.c:  p->ymax = last->ymax;
codml.c:  codml_coordinates(curtree->root, 0.0, &tipy, &tipmax);
codml.c:  for (i = 1; i <= (tipy - down); i++)
codml.c:  codon_slopecurv(p, p->v, &like, &slope, &curv);
codml.c:  tt = p->v;
codml.c:  p->v = epsilon;
codml.c:  p->back->v = epsilon;
codml.c:  aa = curtree->evaluate(curtree, p, false);
codml.c:  p->v = tt;
codml.c:  p->back->v = tt;
codml.c:  (*sumlr) = curtree->evaluate(curtree, p, false) - aa;
codml.c:  if (curv < -epsilon)
codml.c:    (*s1) = p->v + (-slope - sqrt(slope * slope -  3.841 * curv)) / curv;
codml.c:    (*s2) = p->v + (-slope + sqrt(slope * slope -  3.841 * curv)) / curv;
codml.c:    (*s1) = -1.0;
codml.c:    (*s2) = -1.0;
codml.c:  if (!p->tip && !p->initialized)
codml.c:    curtree->nuview(curtree, p);
codml.c:  if (!p->back->tip && !p->back->initialized)
codml.c:    curtree->nuview(curtree, p->back);
codml.c:  q = p->back;
codml.c:  if (q->tip)
codml.c:      putc(nayme[q->index-1][i], outfile);
codml.c:    fprintf(outfile, "  %4ld          ", q->index - spp);
codml.c:  if (p->tip)
codml.c:      putc(nayme[p->index-1][i], outfile);
codml.c:    fprintf(outfile, "%4ld      ", p->index - spp);
codml.c:  fprintf(outfile, "%15.5f", q->v);
codml.c:  if (!usertree || (usertree && !lngths) || p->iter || reusertree)
codml.c:  if (!p->tip)
codml.c:      sib_ptr = sib_ptr->next;
codml.c:      describe(sib_ptr->back);
codml.c:  if (p->tip)
codml.c:      putc(inputSequences[p->index-1][n], outfile);
codml.c:      putc(inputSequences[p->index-1][n*3], outfile);
codml.c:      putc(inputSequences[p->index-1][n*3+1], outfile);
codml.c:      putc(inputSequences[p->index-1][n*3+2], outfile);
codml.c:    if ((ally[n] == 0) || (location[ally[n]-1] == 0))
codml.c:      assert(p->initialized || p->tip);
codml.c:      j = location[ally[n]-1] - 1;
codml.c:        f = ((codon_node*)p)->codonx[j][mx-1][i];
codml.c:        if (!p->tip)
codml.c:            q = q->next;
codml.c:            f *= ((codon_node*)q)->codonx[j][mx-1][i];
codml.c:          f = exp(log(f)/(num_sibs-1.0));
codml.c:        fprintf(outfile, "%s ", codonStrings[first]); // BUG.969 -- check
codml.c:        fprintf(outfile, "%s ", lowCodon); // BUG.969 -- check
codml.c:        mx = mp[n][mx - 1];
codml.c:  if (p->tip)
codml.c:      putc(nayme[p->index-1][i], outfile);
codml.c:    fprintf(outfile, "%4ld      ", p->index - spp);
codml.c:  if (!p->tip)
codml.c:    for (q = p->next; q != p; q = q->next)
codml.c:      rectrav(q->back, m, n);
codml.c:  fprintf(outfile, "Ln Likelihood = %11.5f\n", curtree->score);
codml.c:  fprintf(outfile, " -------        ---            ------");
codml.c:    fprintf(outfile, "      ------- ---------- ------");
codml.c:    if (curtree->nodep[i])
codml.c:      num_sibs = count_sibs (curtree->nodep[i]);
codml.c:      sib_ptr  = curtree->nodep[i];
codml.c:        sib_ptr->initialized = false;
codml.c:        sib_ptr              = sib_ptr->next;
codml.c:  describe(curtree->root->back);
codml.c:  num_sibs = count_sibs(curtree->root);
codml.c:  sib_ptr  = curtree->root;
codml.c:    sib_ptr = sib_ptr->next;
codml.c:    describe(sib_ptr->back);
codml.c:  curtree->evaluate(curtree, curtree->root, false);
codml.c:    for (i = workingSites - 1; i >= 0; i--)
codml.c:        nulike[j] = (1.0 - lambda + lambda * probcat[j]) * like[j];
codml.c:            if (lambda * probcat[k - 1] * like[k - 1] > nulike[j])
codml.c:              nulike[j] = lambda * probcat[k - 1] * like[k - 1];
codml.c:        if ((ally[i] > 0) && (location[ally[i]-1] > 0))
codml.c:          nulike[j] *= contribution[location[ally[i] - 1] - 1][j];
codml.c:      if (probcat[i - 1] * like[i - 1] > mode)
codml.c:        mode = probcat[i - 1] * like[i - 1];
codml.c:      mx = mp[i - 1][mx - 1];
codml.c:    for (i = workingSites - 1; i >= 0; i--)
codml.c:        nulike[j] = (1.0 - lambda + lambda * probcat[j]) * like[j];
codml.c:            nulike[j] += lambda * probcat[k - 1] * like[k - 1];
codml.c:        if ((ally[i] > 0) && (location[ally[i]-1] > 0))
codml.c:          nulike[j] *= contribution[location[ally[i] - 1] - 1][j];
codml.c:        nulike[j] = (1.0 - lambda + lambda * probcat[j]) * like[j];
codml.c:            nulike[j] += lambda * probcat[k - 1] * like[k - 1];
codml.c:    for (i = 0; (i < 13) && (i < ((workingSites + (workingSites-1)/10 - 39) / 2)); i++)
codml.c:        k = workingSites - 1;
codml.c:      rectrav(curtree->root, i, k);
codml.c:      rectrav(curtree->root->back, i, k);
codml.c:  if (p->tip)
codml.c:      if (nayme[p->index-1][i - 1] != ' ')
codml.c:      c = nayme[p->index-1][i];
codml.c:    q = p->next;
codml.c:      dnaml_treeout(q->back);
codml.c:      q = q->next;
codml.c:    } while ((p == curtree->root || p != q) && (p != curtree->root || p->next != q));
codml.c:  x = p->v;
codml.c:    w = (long)(0.43429448222 * log(-x)) + 1;
codml.c:  if (p == curtree->root)
codml.c:      free(((codon_node*)treenode[i])->codonx[j]);
codml.c:    free(((codon_node*)treenode[i])->codonx);
codml.c:          free(((codon_node*)p)->codonx[k]);
codml.c:        free(((codon_node*)p)->codonx);
codml.c:        p = p->next;
codml.c:  node *r = t->root;
codml.c:    while ( q->next != r )
codml.c:      q = q->next;
codml.c:    q->next = r->next;
codml.c:    t->release_forknode(t, r);
codml.c:    t->nodep[spp] = q;
codml.c:    assert(r->back == NULL);            // RSGnote: This assumes the FORKRING being manipulated has the ROOT FORKNODE pointing to NULL.
codml.c:    newl = r->next->oldlen + r->next->next->oldlen;
codml.c:    r->next->back->oldlen = newl;
codml.c:    r->next->next->back->oldlen = newl;
codml.c:    newl = r->next->v + r->next->next->v;
codml.c:    r->next->back->v = newl;
codml.c:    r->next->next->back->v = newl;
codml.c:    r->next->back->back = r->next->next->back;
codml.c:    r->next->next->back->back = r->next->back;
codml.c:    t->release_fork(t, r);
codml.c:  t->root = t->nodep[0]->back;          // Reset ROOT; moved from line just after call to CODML_REROOT.
codml.c:      *p = treep->get_forknode(treep, nodei);
codml.c:      nodep[(*p)->index - 1] = (*p);
codml.c:      *p = treep->get_forknode(treep, nodei);
codml.c:      (*p)->index = nodei;
codml.c:      (*p)->initialized = false;
codml.c:      (*p)->v = initialv;
codml.c:      (*p)->iter = true;
codml.c:      if ((*p)->back != NULL)
codml.c:        (*p)->back->iter = true;
codml.c:        (*p)->back->v = initialv;
codml.c:        (*p)->back->initialized = false;
codml.c:      (*p)->v = valyew / divisor;
codml.c:      (*p)->iter = false;
codml.c:      if ((*p)->back != NULL)
codml.c:        (*p)->back->v = (*p)->v;
codml.c:        (*p)->back->iter = false;
codml.c:      fprintf(outfile, "\nUser-defined tree");
codml.c:    /* This taken out of tree read, used to be [spp-1], but referring to [0] produces output identical to what the pre-modified dnaml produced. */
codml.c:      /* These initializations required each time through the loop since multiple trees require re-initialization */
codml.c:      treeread(curtree, intree, &curtree->root, curtree->nodep, &goteof, &dummy_first, &nextnode, &haslengths, initcodonmlnode, false, nonodes2);
codml.c:        printf ("\tNumber of trees actually in file:\t%ld.\n\n", which - 1);
codml.c:        exxit (-1);
codml.c:        curtree->root = curtree->nodep[outgrno - 1]->back;
codml.c:      // BUG.969 -- proml has reusertree stuff in here
codml.c:        dnaml_treeout(curtree->root);
codml.c:        codon_freex_notip(nextnode, curtree->nodep);
codml.c:      standev2(numtrees, maxwhich, 0, endsite-1, maxlogl,
codml.c:      enterorder[i - 1] = i;
codml.c:    curtree->root = curtree->nodep[enterorder[0] - 1]->back;
codml.c:      assert(curtree->tree_good_f(curtree));    /* debug:  tree_good functions unneeded */
codml.c:        curtree->copy(curtree, priortree);
codml.c:      curtree->addtraverse(curtree, curtree->nodep[enterorder[nextsp - 1] - 1], curtree->root, true, &qwhere, &bestyet, bestree, priortree, smoothit, NULL);
codml.c:        bestree->copy(bestree, curtree);
codml.c:        curtree->insert_(curtree, curtree->nodep[enterorder[nextsp - 1] - 1], qwhere, true, false);
codml.c:        curtree->copy(curtree, bestree);
codml.c:        bestyet = curtree->score;
codml.c:        writename(nextsp - 1, 1, enterorder);
codml.c:      assert(curtree->tree_good_f(curtree)); /* BUG.969 */
codml.c:        curtree->globrearrange(curtree, progress, smoothit);
codml.c:        curtree->locrearrange(curtree, curtree->nodep[enterorder[0] - 1], smoothit, priortree, bestree) ;
codml.c:        curtree->smoothall(curtree, curtree->root);
codml.c:        bestyet = curtree->score;
codml.c:      assert(curtree->tree_good_f(curtree)); /* BUG.969 */
codml.c:    curtree->copy(curtree, bestree);
codml.c:        bestree->copy(bestree, bestree2);
codml.c:        if (bestree2->score < bestree->score)
codml.c:          bestree->copy(bestree, bestree2);
codml.c:        bestree2->copy(bestree2, curtree);
codml.c:      curtree->root = curtree->nodep[outgrno - 1]->back;
codml.c:        dnaml_treeout(curtree->root);
codml.c:  free_all_codonx(nonodes2, curtree->nodep);
codml.c:    free_all_codonx(nonodes2, bestree->nodep);
codml.c:    free_all_codonx(nonodes2, priortree->nodep);
codml.c:      free_all_codonx(nonodes2, bestree2->nodep);
codml.c:    curtree->free(curtree);
codml.c:    bestree->free(bestree);
codml.c:    priortree->free(priortree);
codml.c:    bestree2->free(bestree2);
codml.c:    // Kimura 2-parameter
codml.c:    // Jukes-Cantor
codml.c:  funcs->node_new = codon_node_new;
codml.c:  funcs->tree_new = codon_tree_new;
codml.c:    curtree->free(curtree);
codml.c:    bestree->free(bestree);
codml.c:    priortree->free(priortree);
codml.c:    bestree2->free(bestree2);
cons.c:/* Version 4.0. (c) Copyright 1993-2013 by the University of Washington.
cons.c: * namesGetBucket - return the bucket for a given name
cons.c: * namesAdd - add a name to the hash table
cons.c:  strcpy(hp->naym, addname);
cons.c:  hp->next = temp;
cons.c:  hp->hitCount = 0;
cons.c: * namesSearch - search for a name in the hash table
cons.c:    if (strcmp(searchname, p->naym) == 0) {
cons.c:      p->hitCount++;
cons.c:    p = p->next;
cons.c:      if(p->hitCount >1)
cons.c:        puts(p->naym);
cons.c:        exxit(-1);
cons.c:      } else if(p->hitCount == 0)
cons.c:        printf("\nERROR in user tree: name %s not found\n\n\n", p->naym);
cons.c:        exxit(-1);
cons.c:      p->hitCount = 0;
cons.c:      p = p->next;
cons.c: * namesClearTable - empty names out of the table and
cons.c:        p = p->next;
cons.c:      *p = treep->get_forknode(treep, nodei);
cons.c:        (*p)->nayme[i] = '\0';
cons.c:      treep->nodep[(*p)->index - 1] = (*p);
cons.c:      (*p)->v = 0;
cons.c:      *p = treep->get_forknode(treep, nodei);
cons.c:      (*p)->index = nodei;
cons.c:      (*p)->v = 0;
cons.c:      *p = treep->get_forknode(treep, nodei);
cons.c:      treep->nodep[(*ntips) - 1] = *p;
cons.c:      (*p)->tip = true;
cons.c:      strncpy ((*p)->nayme, str, MAXNCH);
cons.c:      (*p)->v = 0;
cons.c:      (*p)->v = valyew / divisor / fracchange;
cons.c:          exxit(-1);
cons.c:          exxit(-1);
cons.c:            exxit(-1);
cons.c:      (*p)->v = -1;         /* signal value that a length is missing */
cons.c:  /* set up group-related arrays */
cons.c:    lengths[i] = -1;
cons.c:    fullset[k] |= 1L << (j - k*SETBITS - 1);
cons.c:      lengths[i] = -1;
cons.c:    treeread(treep, intree, &root, treep->nodep, &goteof, &firsttree, &nextnode, &haslengths, initconsnode, true, -1);
cons.c:      reroot(treep, treep->nodep[outgrno - 1], &nextnode);
cons.c:    treep->free(treep);
cons.c:    pattern_array[i][trees_in_file]->apattern =
cons.c:    pattern_array[i][trees_in_file]->length =
cons.c:      pattern_array[i][trees_in_file]->length[j] = -1;
cons.c:    pattern_array[i][trees_in_file]->patternsize = (long *)Malloc(sizeof(long));
cons.c:          pattern_array[k][trees_in_file]->apattern[j] = grouping[i][k];
cons.c:        pattern_array[0][trees_in_file]->length[j] = lengths[i];
cons.c:  *pattern_array[0][trees_in_file]->patternsize = total_groups;
cons.c:    if (timesseen[i-1])
cons.c:      if (!(mre || (mr && (2*(*timesseen[i-1]) > ntrees))
cons.c:                || (ml && ((*timesseen[i-1]) > mlfrac*ntrees))
cons.c:                || (strict && ((*timesseen[i-1]) == ntrees)))) {
cons.c:        free(grouping[i - 1]);
cons.c:        free(timesseen[i - 1]);
cons.c:        grouping[i - 1] = NULL;
cons.c:        timesseen[i - 1] = NULL;
cons.c:    while (grouping[i - 1] != NULL)
cons.c:    while ((grouping[j - 1] == NULL) && (j < maxgrp))
cons.c:      grouping[i - 1] = (group_type *)Malloc(setsz * sizeof(group_type));
cons.c:      timesseen[i - 1] = (double *)Malloc(sizeof(double));
cons.c:      memcpy(grouping[i - 1], grouping[j - 1], setsz * sizeof(group_type));
cons.c:      *timesseen[i - 1] = *timesseen[j - 1];
cons.c:      free(grouping[j - 1]);
cons.c:      free(timesseen[j - 1]);
cons.c:      grouping[j - 1] = NULL;
cons.c:      timesseen[j - 1] = NULL;
cons.c:  (*n) = i - 1;
cons.c:      j = i - gap;
cons.c:        if (*timesseen[j - 1] < *timesseen[j + gap - 1]) {
cons.c:          memcpy(stemp, grouping[j - 1], setsz * sizeof(group_type));
cons.c:          memcpy(grouping[j - 1], grouping[j + gap - 1], setsz * sizeof(group_type));
cons.c:          memcpy(grouping[j + gap - 1], stemp, setsz * sizeof(group_type));
cons.c:          rtemp = *timesseen[j - 1];
cons.c:          *timesseen[j - 1] = *timesseen[j + gap - 1];
cons.c:          *timesseen[j + gap - 1] = rtemp;
cons.c:        j -= gap;
cons.c:    for (j = 0; comp && (j <= i - 2); j++) {
cons.c:        comp = compatible(i-1, j);
cons.c:          times2[(*n2) - 1] = (double *)Malloc(sizeof(double));
cons.c:          group2[(*n2) - 1] = (group_type *)Malloc(setsz * sizeof(group_type));
cons.c:          *times2[(*n2) - 1] = *timesseen[i - 1];
cons.c:          memcpy(group2[(*n2) - 1], grouping[i - 1], setsz * sizeof(group_type));
cons.c:          *timesseen[i - 1] = 0.0;
cons.c:            grouping[i - 1][k] = 0;
cons.c:    if (*timesseen[i - 1] == 0.0) {
cons.c:      free(grouping[i - 1]);
cons.c:      free(timesseen[i -  1]);
cons.c:      timesseen[i - 1] = NULL;
cons.c:      grouping[i - 1] = NULL;
cons.c:  for (i = 1; i <= spp - 25; i++)
cons.c:        if (((1L << (j - 1 - k*SETBITS)) & grouping[i][k]) != 0)
cons.c:      if (size != 1 && !(noroot && (size >= (spp-1)))) {
cons.c:          if (((1L << (j - 1 - k*SETBITS)) & grouping[i][k]) != 0)
cons.c:        for (j = 1; j <= 23 - spp; j++)
cons.c:    if (((1L << (i - 1 - l*SETBITS)) & st[l]) != 0) {
cons.c:    *p = treep->nodep[j - 1];
cons.c:    (*p)->tip = true;
cons.c:    (*p)->index = j;
cons.c:  *p = treep->get_forknode(treep, *nextnode);
cons.c:  treep->nodep[*nextnode - 1] = *p;
cons.c:  (*p)->deltav = 0.0;
cons.c:      (*p)->deltav = *timesseen[i];
cons.c:      q->next = treep->get_forknode(treep, *nextnode);
cons.c:      q->next->index = q->index;
cons.c:      q = q->next;
cons.c:      q->tip = false;
cons.c:      recontraverse(treep, &q->back, tempset, n, nextnode); /* put it on tree */
cons.c:      q->back->back = q;
cons.c:        if (grouping[i - 1] != 0) {
cons.c:            if (grouping[i - 1][j] != tempset[j])
cons.c:        if ((grouping[i - 1] != 0) && same)
cons.c:  q->next = *p;
cons.c:  if (p->tip) {
cons.c:    p->xcoord = 0;
cons.c:    p->ycoord = *tipy;
cons.c:    p->ymin = *tipy;
cons.c:    p->ymax = *tipy;
cons.c:  q = p->next;
cons.c:    coordinates(q->back, tipy);
cons.c:    if (!q->back->tip) {
cons.c:      if (q->back->xcoord > maxx)
cons.c:        maxx = q->back->xcoord;
cons.c:    q = q->next;
cons.c:  first = p->next->back;
cons.c:  while (q->next != p)
cons.c:    q = q->next;
cons.c:  last = q->back;
cons.c:  p->xcoord = maxx + OVER;
cons.c:  p->ycoord = (long)((first->ycoord + last->ycoord) / 2);
cons.c:  p->ymin = first->ymin;
cons.c:  p->ymax = last->ymax;
cons.c:    if (!p->tip) {
cons.c:      r = p->next;
cons.c:        if (i >= r->back->ymin && i <= r->back->ymax) {
cons.c:          q = r->back;
cons.c:          r = r->next;
cons.c:      first = p->next->back;
cons.c:      while (r->next != p)
cons.c:        r = r->next;
cons.c:      last = r->back;
cons.c:    done = (p->tip || p == q);
cons.c:    n = p->xcoord - q->xcoord;
cons.c:      n--;
cons.c:    if (q->ycoord == i && !done) {
cons.c:        putc('-', outfile);
cons.c:      if (!q->tip) {
cons.c:        for (j = 1; j <= n - 8; j++)
cons.c:          putc('-', outfile);
cons.c:        if (noroot && (root->next->next->next == root) &&
cons.c:            (((root->next->back == q) && root->next->next->back->tip)
cons.c:             || ((root->next->next->back == q) && root->next->back->tip)))
cons.c:          fprintf(outfile, "-------|");
cons.c:            if (q->deltav >= 10000)
cons.c:              fprintf(outfile, "-%5.0f-|", (double)q->deltav);
cons.c:            else if (q->deltav >= 1000)
cons.c:              fprintf(outfile, "--%4.0f-|", (double)q->deltav);
cons.c:            else if (q->deltav >= 100)
cons.c:              fprintf(outfile, "-%5.1f-|", (double)q->deltav);
cons.c:            else if (q->deltav >= 10)
cons.c:              fprintf(outfile, "--%4.1f-|", (double)q->deltav);
cons.c:              fprintf(outfile, "--%3.2f-|", (double)q->deltav);
cons.c:            fprintf(outfile, "-------|");
cons.c:          putc('-', outfile);
cons.c:    } else if (!p->tip && last->ycoord > i && first->ycoord < i &&
cons.c:               (i != p->ycoord || p == root)) {
cons.c:  if (p->ycoord == i && p->tip) {
cons.c:    for (j = 0; (j < MAXNCH) && (p->nayme[j] != '\0'); j++)
cons.c:      putc(p->nayme[j], outfile);
cons.c:    for (i = 1; i <= tipy - down; i++)
cons.c:     (without hash-coding).  n is number of sets stored there and is updated */
cons.c:  for (i = 0; i < n-1; i++) {
cons.c:  if (*timesseen[n-1] == 0.0) {
cons.c:    free(grouping[n-1]);
cons.c:    free(timesseen[n-1]);
cons.c:    timesseen[n-1] = NULL;
cons.c:    grouping[n-1] = NULL;
cons.c:  smult = (sqrt(5.0) - 1) / 2;
cons.c:    j = (long)(maxgrp * (temp - floor(temp)));
cons.c:        if (j >= maxgrp) j -= maxgrp;
cons.c:  s = ((cons_node*)r)->nodeset;
cons.c:  n = ((sqrt(5.0) - 1.0) / 2.0);   /* use an irrational multiplier */
cons.c:  i = (long)(maxgrp * (ss - floor(ss))) + 1; /* use fractional part of code */
cons.c:    if (grouping[i - 1]) {        /* ... i.e. if group is there, or  */
cons.c:      if (timesseen[i-1] != 0) {  /* ... if timesseen > 0 */
cons.c:          if (s[j] != grouping[i - 1][j])
cons.c:          grouping[i-1][j] = s[j];
cons.c:    if (grouping[i - 1] && same) {  /* if it is there, increment timesseen */
cons.c:      *timesseen[i - 1] += times;
cons.c:      lengths[i - 1] = treep->nodep[r->index - 1]->v;
cons.c:    } else if (!grouping[i - 1]) {  /* if not there and slot empty ... */
cons.c:      grouping[i - 1] = (group_type *)Malloc(setsz * sizeof(group_type));
cons.c:      timesseen[i - 1] = (double *)Malloc(sizeof(double));
cons.c:      memcpy(grouping[i - 1], s, setsz * sizeof(group_type));
cons.c:      *timesseen[i - 1] = times;
cons.c:      *order[lasti] = i - 1;
cons.c:      lengths[i - 1] = treep->nodep[r->index -1]->v;
cons.c:      if (i > maxgrp) i -= maxgrp;
cons.c:      lasti = maxgrp/2 - 1;
cons.c:  if (r->tip) {
cons.c:    if (!((cons_node*)r)->nodeset)
cons.c:      ((cons_node*)r)->nodeset = (group_type *)Malloc(setsz * sizeof(group_type));
cons.c:      ((cons_node*)r)->nodeset[i] = 0L;
cons.c:    i = (r->index-1) / (long)SETBITS;
cons.c:    ((cons_node*)r)->nodeset[i] = 1L << (r->index - 1 - i*SETBITS);
cons.c:    q = r->next;
cons.c:      accumulate(treep, q->back);
cons.c:      q = q->next;
cons.c:    q = r->next;
cons.c:    if (!((cons_node*)r)->nodeset)
cons.c:      ((cons_node*)r)->nodeset = (group_type *)Malloc(setsz * sizeof(group_type));
cons.c:      ((cons_node*)r)->nodeset[i] = 0;
cons.c:        ((cons_node*)r)->nodeset[i] |= ((cons_node*)q->back)->nodeset[i];
cons.c:      q = q->next;
cons.c:  if ((!r->tip && (r->next->next != r)) || r->tip)
cons.c:  if (p->tip) {
cons.c:      if (namesSearch(p->nayme)) {
cons.c:        puts(p->nayme);
cons.c:        exxit(-1);
cons.c:        namesAdd(p->nayme);
cons.c:    while (p->next != q) {
cons.c:      dupname2(name, p->next->back, this);
cons.c:      p = p->next;
cons.c:  if (p->tip) {
cons.c:    if (namesSearch(p->nayme)) {
cons.c:      puts(p->nayme);
cons.c:      exxit(-1);
cons.c:      namesAdd(p->nayme);
cons.c:    while (p->next != q) {
cons.c:      dupname(p->next->back);
cons.c:      p = p->next;
cons.c:  if (p->tip) {
cons.c:    if (!namesSearch(p->nayme)) {
cons.c:      printf("\nERROR in user tree: name %s not found in first tree\n\n\n", p->nayme);
cons.c:      exxit(-1);
cons.c:    while (p->next != q) {
cons.c:      missingnameRecurs(p->next->back);
cons.c:      p = p->next;
cons.c:  if (p->tip) {
cons.c:    memcpy(nayme[p->index - 1], p->nayme, MAXNCH);
cons.c:    q = p->next;
cons.c:      initreenode(q->back);
cons.c:      q = q->next;
cons.c:  while (p->next != root)
cons.c:    p = p->next;
cons.c:    q = root->next;
cons.c:    newv = q->back->v + p->back->v;
cons.c:    if (outgroup == p->back) {
cons.c:      root->next = p;
cons.c:      p->next = q;
cons.c:      q->next = root;
cons.c:      q->back->v = newv;
cons.c:      p->back->v = 0;
cons.c:      p->back->v = newv;
cons.c:      q->back->v = 0;
cons.c:    q->back->back = p->back;
cons.c:    p->back->back = q->back;
cons.c:    p->back->v = newv;
cons.c:    q->back->v = newv;
cons.c:    p->next = root->next;              /* join old root nodes */
cons.c:    treep->nodep[root->index-1] = root->next; /* make root->next the primary node */
cons.c:    root->next = treep->get_forknode(treep, *nextnode);
cons.c:    q = root->next;
cons.c:    q->next = treep->get_forknode(treep, *nextnode);
cons.c:    p = q->next;
cons.c:    p->next = root;
cons.c:    q->tip = false;
cons.c:    p->tip = false;
cons.c:    treep->nodep[*nextnode] = root;
cons.c:    root->index = *nextnode;
cons.c:    root->next->index = root->index;
cons.c:    root->next->next->index = root->index;
cons.c:  newv = outgroup->v;
cons.c:  /* q == root->next */
cons.c:  /* p == root->next->next */
cons.c:  q->back = outgroup;
cons.c:  p->back = outgroup->back;
cons.c:  outgroup->back->back = p;
cons.c:  outgroup->back = q;
cons.c:  outgroup->v = 0;
cons.c:  outgroup->back->v = 0;
cons.c:  root->v = 0;
cons.c:  p->v = newv;
cons.c:  p->back->v = newv;
cons.c:  if ( n->tip ) return;
cons.c:  if ( treep->nodep[n->index - 1] != n ) {
cons.c:    treep->nodep[n->index - 1] = n;
cons.c:    if ( n->back )
cons.c:      n->v = n->back->v;
cons.c:  for ( p = n->next ; p != n ; p = p->next)
cons.c:    reorient(treep, p->back);
cons.c:   * one-to-one mapping between tip names and the names in nayme[].
cons.c:  for (i = 0; i < spp-1; i++) {
cons.c:      if (samename(nayme[i], treep->nodep[j]->nayme)) {
cons.c:        t = treep->nodep[i];
cons.c:        treep->nodep[i] = treep->nodep[j];
cons.c:        treep->nodep[i]->index = i+1;
cons.c:        treep->nodep[j] = t;
cons.c:        treep->nodep[j]->index = j+1;
consense.c:/* Version 4.0. (c) Copyright 1993-2013 by the University of Washington.
consense.c:    tmp_node = (*p)->next;
consense.c:      tmp_node = tmp_node->next;
consense.c:  if (p->tip)
consense.c:      if (p->nayme[i - 1] != '\0')
consense.c:      c = p->nayme[i];
consense.c:    q = p->next;
consense.c:      treeout(q->back);
consense.c:      q = q->next;
consense.c:  if (p->tip)
consense.c:    x = (double)p->deltav;
consense.c:  lasti  = -1;
consense.c:      curtree->nodep[i]->nayme[j] = '\0';
consense.c:    strncpy(curtree->nodep[i]->nayme, nayme[i], MAXNCH);
consense.c:      p = nodep[i]->next;
consense.c:        q = p->next;
consense.c:  funcs->node_new = cons_node_new;
consense.c:  funcs->node_new = cons_node_new;
consense.c:  /* Open in binary: ftell() is broken for UNIX line-endings under WIN32 */
consense.c:  /* Initialize option-based variables, then ask for changes regarding
cont.c:/* Version 4.0. (c) Copyright 1999-2013 by the University of Washington.
cont.c:  ((node*)n)->copy = cont_node_copy;
cont.c:  if ( dst->totalleles != 0 && dst->totalleles != src->totalleles )
cont.c:    free(dst->view);
cont.c:    dst->view = NULL;
cont.c:  dst->totalleles = src->totalleles;
cont.c:  if ( dst->view == NULL )
cont.c:    dst->view = Malloc(src->totalleles * sizeof(double));
cont.c:  memcpy(dst->view, src->view, dst->totalleles * sizeof(double));
cont.c:    p = (*treenode)[i]->next;
cont.c:      p = p->next;
cont.c:    a->nodep[i - 1]->back = NULL;
cont.c:    a->nodep[i - 1]->iter = true;
cont.c:  /* no setup for interior nodes -- handled in treeread
cont.c:  a->score = -99999.0;
cont.c:  a->root = a->nodep[0];
cont.c:  a->get_fork = generic_tree_get_fork;
cont.c:    if (a->nodep[i] != NULL)
cont.c:        ((cont_node_type*)a->nodep[i])->view = (phenotype3)Malloc(totalleles
cont.c:        ((cont_node_type*)a->nodep[i])->totalleles = totalleles;
cont.c:    if (a->nodep[i] != NULL) {
cont.c:      r = (node*)(a->nodep[i]);
cont.c:        ((cont_node_type*)s)->view = (phenotype3)Malloc(totalleles 
cont.c:        ((cont_node_type*)s)->totalleles = totalleles;
cont.c:        s = s->next;
cont.c:  p = (Slist_node_ptr)(a->free_fork_nodes->first);   /* go along free nodes
cont.c:  q = (Slist_data_ptr)(a->free_fork_nodes->first->data);
cont.c:  n = a->free_fork_nodes->length;
cont.c:    ((cont_node_type *)q)->view = (phenotype3)Malloc(totalleles
cont.c:    ((cont_node_type *)q)->totalleles = totalleles;
cont.c:      p = p->next;
cont.c:      q = p->data;
cont.c:    free(((cont_node_type*)a->nodep[i])->view);
cont.c:    p = a->nodep[i];
cont.c:      free(((cont_node_type*)q)->view);
cont.c:      q = q->next;
cont.c:{  /* do paired sites test (KHT or SH) on user-defined trees */
cont.c:    fprintf(outfile, "Kishino-Hasegawa-Templeton test\n\n");
cont.c:      fprintf(outfile, "%3ld%10.1f", i, l0gl[i - 1]);
cont.c:        fprintf(outfile, "  <------ best\n");
cont.c:          temp = l0gf[i - 1][j] - l0gf[maxwhich - 1][j];
cont.c:        sd = sqrt(sumw / (sumw - 1.0) * (sum2 - temp * temp));
cont.c:        fprintf(outfile, "%10.1f%12.4f", (l0gl[i - 1])-maxlogl, sd);
cont.c:  else                                  /* Shimodaira-Hasegawa test using normal approximation */
cont.c:      fprintf(outfile, "Shimodaira-Hasegawa test on first %d of %ld trees\n\n", MAXSHIMOTREES, numtrees);
cont.c:      fprintf(outfile, "Shimodaira-Hasegawa test\n\n");
cont.c:    sumw = b-a+1;
cont.c:          temp = temp + (l0gf[i][k]-sum)*(l0gf[j][k]-sum2);
cont.c:    for (i = 0; i < numtrees; i++)  /* in-place Cholesky decomposition of
cont.c:      for (j = 0; j <= i-1; j++)
cont.c:      temp = sqrt(covar[i][i] - sum);
cont.c:        if (fabs(temp) < 1.0E-12)
cont.c:          covar[j][i] = (covar[j][i] - sum)/temp;
cont.c:        if (maxlogl-l0gl[j] < sum-f[j])
cont.c:      if ((maxwhich-1) == i)
cont.c:        fprintf(outfile, "  <------ best\n");
cont.c:        fprintf(outfile, " %9.1f  %10.3f", l0gl[i]-maxlogl, P[i]);
contml.c:/* Version 4.0. (c) Copyright 1993-2013 by the University of Washington.
contml.c:  t->evaluate = contml_tree_evaluate;
contml.c:  t->nuview = contml_tree_nuview;
contml.c:  t->makenewv = contml_tree_makenewv;
contml.c:  t->free = contml_tree_free;
contml.c:  generic_node_init(&(cn->cont_node_var.node_var), type, index);
contml.c:  cn->dist = 0;
contml.c:  cn->cont_node_var.node_var.copy = contml_node_copy;
contml.c:  cn->cont_node_var.node_var.reinit = contml_node_reinit;
contml.c:{ /* re-init a contml_node */
contml.c:  generic_node_reinit(&(cn->cont_node_var.node_var));
contml.c:  cn->dist = 0;
contml.c:    nonodes2--;
contml.c:      locus[i - 1] = i;
contml.c:      alleles[i - 1] = 1;
contml.c:      fprintf(outfile, "------- -- ------- -- --- -----\n\n");
contml.c:      if (fscanf(infile, "%ld", &alleles[i - 1]) < 1)
contml.c:        exxit(-1);
contml.c:      if (alleles[i - 1] <= 0)
contml.c:        printf("\nERROR:  Bad number of alleles: %ld at locus %ld.\n", alleles[i-1], i);
contml.c:        exxit(-1);
contml.c:      totalleles += alleles[i - 1];
contml.c:        fprintf(outfile, "%4ld", alleles[i - 1]);
contml.c:      for (j = 0; j < alleles[i - 1]; j++)
contml.c:      m += alleles[i - 1];
contml.c:    df = totalleles - loci;
contml.c:    fprintf(outfile, "----");
contml.c:      fprintf(outfile, "                       ----------\n");
contml.c:      fprintf(outfile, "                 ---- -----------\n");
contml.c:      for (j = 1; j <= nmlngth - 8; j++)
contml.c:          n = alleles[j - 1];
contml.c:          n = alleles[j - 1] - 1;
contml.c:            for (l = 1; l <= nmlngth - 2; l++)
contml.c:        n = alleles[j - 1];
contml.c:        n = alleles[j - 1] - 1;
contml.c:        if (fscanf(infile, "%lf", &x[i][m - 1]) < 1)
contml.c:          exxit(-1);
contml.c:        sum += x[i][m - 1];
contml.c:        if (!contchars && x[i][m - 1] < 0.0)
contml.c:          exxit(-1);
contml.c:          fprintf(outfile, "%10.5f", x[i][m - 1]);
contml.c:        if (fabs(sum - 1.0) > epsilon2)
contml.c:          for (l = 0; l <= m-3; l++)
contml.c:          printf("%f = %f\n\n", x[i][m-2], sum);
contml.c:          exxit(-1);
contml.c:          for (l = 0; l <= m-2; l++)
contml.c:        x[i][m-1] = 1.0 - sum;
contml.c:        if (x[i][m-1] < 0.0)
contml.c:          if (x[i][m-1] > -epsilon2)
contml.c:            for (l = 0; l <= m-2; l++)
contml.c:            x[i][m-1] = 0.0;
contml.c:            for (l = 0; l <= m-3; l++)
contml.c:            printf("%f = %f\n\n", x[i][m-2], sum);
contml.c:            exxit(-1);
contml.c:        sumprod[locus[j]-1] += sqrtp[j]*sqrt(x[i][j]);
contml.c:      f = (1.0 + sumprod[locus[j]-1])/2.0;
contml.c:        x[i][j] = (2.0/f - 1.0)*sqrtp[j];
contml.c:        x[i][j] = (1.0/f)*sqrt(x[i][j]) + (1.0/f - 1.0)*sqrtp[j];
contml.c:    for (k = 0; k < alleles[j]-1; k++)  /* one fewer than # of alleles */
contml.c:          c[k][l+1] = -sum / c[l][l+1];    /* set coeff to make orthogonal */
contml.c:        c[k][k+1] = - sum / sqrtp[m+k+1];  /* ... setting last coeff */
contml.c:      for (l = 0; l < alleles[j]-1; l++) /* compute the l-th one */
contml.c:        c[maxalleles-1][l] = 0.0;  /* temporarily store it ... */
contml.c:          c[maxalleles-1][l] += c[l][n]*x[i][m+n];
contml.c:      for (l = 0; l < alleles[j]-1; l++)
contml.c:        x[i][m+l] = c[maxalleles-1][l];   /* replace the gene freqs by it */
contml.c:  p->v = initialv;
contml.c:  q->v = initialv;
contml.c:  if (!p->tip)
contml.c:    sumlikely(p->next->back, p->next->next->back, sum);
contml.c:  if (!q->tip)
contml.c:    sumlikely(q->next->back, q->next->next->back, sum);
contml.c:  if (p->back == q)
contml.c:    vee = p->v;
contml.c:    vee = p->v + q->v;
contml.c:  vee += p->deltav + q->deltav;
contml.c:  if (vee <= 1.0e-10)
contml.c:    exxit(-1);
contml.c:      l0gf[which - 1][i] += (1 - alleles[i]) * log(vee) / 2.0;
contml.c:      temp = ((cont_node_type*)p)->view[i] - ((cont_node_type*)q)->view[i];
contml.c:        l0gf[which - 1][i] -= term / (2.0 * vee);
contml.c:        temp = ((cont_node_type*)p)->view[m+j-1] - ((cont_node_type*)q)->view[m+j-1];
contml.c:          l0gf[which - 1][i] -= term / (2.0 * vee);
contml.c:  (*sum) += df * log(vee) / -2.0 - sumsq / (2.0 * vee);
contml.c:      l0gf[which - 1][i] = 0.0;
contml.c:  sumlikely(p, p->back, &sum);    /* this gets the likelihood, recursively */
contml.c:    l0gl[which - 1] = sum;
contml.c:  t->score = sum;
contml.c:{ /* distance-squared between two nodes */
contml.c:      for (j = 0; j < alleles[i]-1; j++)
contml.c:        temp = ((cont_node_type*)p)->view[m+j] - ((cont_node_type*)q)->view[m+j];
contml.c:      temp = ((cont_node_type*)p)->view[i] - ((cont_node_type*)q)->view[i];
contml.c:    q = p->next;
contml.c:    ((contml_node*)p)->dist = distance(p->back, q->back);
contml.c:  q = (contml_node*)((node*)p)->next;
contml.c:  r = (contml_node*)((node*)q)->next;
contml.c:    p->bigv = ((node*)p)->v + ((node*)p)->back->deltav;
contml.c:    if (((node*)p)->iter)
contml.c:      p->bigv = (p->dist + r->dist - q->dist) / (df * 2);
contml.c:      ((contml_node*)((node*)p)->back)->bigv = p->bigv;
contml.c:      if (p->bigv < ((node*)p)->back->deltav)
contml.c:  q = p->next;
contml.c:  r = q->next;
contml.c:      vtot = ((contml_node*)q)->bigv + ((contml_node*)r)->bigv;
contml.c:        f1 = ((contml_node*)q)->bigv / vtot;
contml.c:      f2 = 1.0 - f1;
contml.c:      ((contml_node*)p)->bigv = (f1 * ((contml_node*)r)->dist + f2 * ((contml_node*)p)->dist - f1 * f2 * ((contml_node*)q)->dist) / df;
contml.c:      ((contml_node*)p)->bigv -= vtot * f1 * f2;
contml.c:      if (((contml_node*)p)->bigv < p->back->deltav)
contml.c:        ((contml_node*)p)->bigv = p->back->deltav;
contml.c:      ((contml_node*)p->back)->bigv = ((contml_node*)p)->bigv;
contml.c:    if (p->iter)
contml.c:      p->v = ((contml_node*)p)->bigv - p->back->deltav;
contml.c:    if (p->back->iter)
contml.c:      p->back->v = p->v;
contml.c:    p = p->next;
contml.c:{ /* renew inward-looking view information in subtrees */
contml.c:  q = p->next;
contml.c:  r = q->next;
contml.c:  a = q->back;
contml.c:  b = r->back;
contml.c:  v1 = q->v;
contml.c:  v2 = r->v;
contml.c:  f2 = 1.0 - f1;
contml.c:      ((cont_node_type*)p)->view[m+k-1] = f1*((cont_node_type*)a)->view[m+k-1]
contml.c:                                     + f2 * ((cont_node_type*)b)->view[m+k-1];
contml.c:  p->deltav = v1 * f1;
contml.c:/* Compute new branch length.  If after subtracting p->deltav it is negative,
contml.c:  p->v = distance(p, p->back);
contml.c:  p->v = p->v - p->deltav - p->back->deltav;
contml.c:  if (p->v < 0.0) {
contml.c:  d->bigv = c->bigv;
contml.c:  d->dist = c->dist;
contml.c:  tmp = t->nodep[m - 1];
contml.c:  memcpy(((cont_node_type*)tmp)->view, x[m - 1], totalleles * sizeof(double));
contml.c:  tmp->deltav = 0.0;
contml.c:  if (p->tip)
contml.c:    p->xcoord = lengthsum;
contml.c:    p->ycoord = *tipy;
contml.c:    p->ymin = *tipy;
contml.c:    p->ymax = *tipy;
contml.c:  q = p->next;
contml.c:    coordinates(q->back, lengthsum + q->v, tipy, tipmax);
contml.c:    q = q->next;
contml.c:  } while ((p == curtree->root || p != q) && (p != curtree->root || p->next != q));
contml.c:  first = p->next->back;
contml.c:  while (q->next != p)
contml.c:    q = q->next;
contml.c:  last = q->back;
contml.c:  p->xcoord = lengthsum;
contml.c:  if (p == curtree->root)
contml.c:    p->ycoord = p->next->next->back->ycoord;
contml.c:    p->ycoord = (first->ycoord + last->ycoord) / 2;
contml.c:  p->ymin = first->ymin;
contml.c:  p->ymax = last->ymax;
contml.c:  p = curtree->root;
contml.c:  q = curtree->root;
contml.c:  assert(p->index > 0);                 // RSGdebug
contml.c:  if (i == (long)p->ycoord && p == curtree->root)
contml.c:    if (p->index - spp >= 10)
contml.c:      fprintf(outfile, " %2ld", p->index - spp);
contml.c:      fprintf(outfile, "  %ld", p->index - spp);
contml.c:    if (!p->tip)
contml.c:      r = p->next;
contml.c:        if (i >= (long)r->back->ymin && i <= (long)r->back->ymax)
contml.c:          q = r->back;
contml.c:        r = r->next;
contml.c:      } while (!(done || (p != curtree->root && r == p) || (p == curtree->root && r == p->next)));
contml.c:      first = p->next->back;
contml.c:      while (r->next != p)
contml.c:        r = r->next;
contml.c:      last = r->back;
contml.c:      if (p == curtree->root)
contml.c:        last = p->back;
contml.c:    done = (p->tip || p == q);
contml.c:    n = (long)(scale * (q->xcoord - p->xcoord) + 0.5);
contml.c:    if (n < 3 && !q->tip)
contml.c:      n--;
contml.c:    if ((long)q->ycoord == i && !done)
contml.c:      if ((long)p->ycoord != (long)q->ycoord)
contml.c:        putc('-', outfile);
contml.c:      if (!q->tip)
contml.c:        for (j = 1; j <= n - 2; j++)
contml.c:          putc('-', outfile);
contml.c:        if (q->index - spp >= 10)
contml.c:          fprintf(outfile, "%2ld", q->index - spp);
contml.c:          fprintf(outfile, "-%ld", q->index - spp);
contml.c:          putc('-', outfile);
contml.c:    else if (!p->tip)
contml.c:      if ((long)last->ycoord > i && (long)first->ycoord < i && i != (long)p->ycoord)
contml.c:  if ((long)p->ycoord == i && p->tip)
contml.c:      putc(nayme[p->index - 1][j], outfile);
contml.c:  coordinates(curtree->root, 0.0, &tipy, &tipmax);
contml.c:  for (i = 1; i <= (tipy - down); i++)
contml.c:  assert(p->index > 0);                 // RSGdebug
contml.c:  if (p->tip)
contml.c:      if (nayme[p->index - 1][i - 1] != ' ')
contml.c:      c = nayme[p->index - 1][i];
contml.c:    treeout(p->next->back);
contml.c:    treeout(p->next->next->back);
contml.c:    if (p == curtree->root)
contml.c:      treeout(p->back);
contml.c:  x = p->v;
contml.c:    w = (long)(0.43429448222 * log(-x)) + 1;
contml.c:  if (p == curtree->root)
contml.c:  q = p->back;
contml.c:  assert(p->index > 0);                 // RSGdebug
contml.c:  assert(q->index > 0);                 // RSGdebug
contml.c:  fprintf(outfile, "%3ld       ", q->index - spp);
contml.c:  if (p->tip)
contml.c:      putc(nayme[p->index - 1][i], outfile);
contml.c:    fprintf(outfile, "%4ld      ", p->index - spp);
contml.c:  fprintf(outfile, "%15.8f", q->v);
contml.c:  delta = p->deltav + p->back->deltav;
contml.c:  bigv = p->v + delta;
contml.c:  if (p->iter)
contml.c:    fprintf(outfile, "   (%12.8f,%12.8f)", chilow * bigv - delta, chihigh * bigv - delta);
contml.c:  if (!p->tip)
contml.c:    describe(p->next->back, chilow, chihigh);
contml.c:    describe(p->next->next->back, chilow, chihigh);
contml.c:  fprintf(outfile, "Ln Likelihood = %11.5f\n", curtree->score);
contml.c:    chilow = 1.0 - 2.0 / (df * 9);
contml.c:    chilow -= 1.95996 * sqrt(2.0 / (df * 9));
contml.c:  fprintf(outfile, "-------     ---             ------");
contml.c:  fprintf(outfile, "      ------- ---------- ------\n");
contml.c:  describe(curtree->root->next->back, chilow, chihigh);
contml.c:  describe(curtree->root->next->next->back, chilow, chihigh);
contml.c:  describe(curtree->root->back, chilow, chihigh);
contml.c:    treeout(curtree->root);
contml.c:{ /* initialize a node -- for interior forks, use rough averages
contml.c:  if (p->tip)
contml.c:  q = p->next->back;
contml.c:  r = p->next->next->back;
contml.c:      ((cont_node_type*)p)->view[m+j-1] = 0.5 * ((cont_node_type*)q)->view[m+j-1] + 0.5 * ((cont_node_type*)r)->view[m+j-1];
contml.c:  if ((!lngths) || p->iter)
contml.c:    p->v = initialv;
contml.c:  if ((!lngths) || p->back->iter)
contml.c:    p->back->v = initialv;
contml.c:  if (p->tip)
contml.c:    nodeinit(p->back);
contml.c:    q = p->next;
contml.c:      initrav(q->back);
contml.c:      q = q->next;
contml.c:{ /* evaluate user-defined tree, iterating branch lengths if needed */
contml.c:  inittravall (curtree, curtree->root);     /* set initializeds false */
contml.c:  inittravall (curtree, curtree->root->back);
contml.c:    ml_inittravtree (curtree, curtree->root);
contml.c:    ml_inittravtree (curtree, curtree->root->back);
contml.c:    smooth(curtree, curtree->root);
contml.c:  curtree->evaluate(curtree, curtree->root, false);
contml.c:    /* Open in binary: ftell() is broken for UNIX line-endings under WIN32 */
contml.c:      fprintf(outfile, "User-defined tree");
contml.c:      p = curtree->get_fork(curtree, i);
contml.c:      curtree->nodep[i] = p;
contml.c:      treeread2 (intree, &curtree->root, curtree->nodep, lngths, &trweight,
contml.c:      standev2(numtrees, maxwhich, 0, loci-1, maxlogl, l0gl, l0gf, seed);
contml.c:      enterorder[i - 1] = i;
contml.c:      inittip(curtree, enterorder[nextsp - 1]);
contml.c:      curtree->copy(curtree, priortree);
contml.c:      bestree->score = UNDEFINED;
contml.c:      p = curtree->get_fork(curtree, k);
contml.c:      contml_hookup(curtree->nodep[enterorder[nextsp-1]-1],p);
contml.c:      curtree->addtraverse(curtree, p, curtree->root, true, qwhere,
contml.c:      bestree->copy(bestree, curtree);
contml.c:        writename(nextsp - 1, 1, enterorder);
contml.c:        curtree->globrearrange(curtree, progress, true);
contml.c:        curtree->locrearrange(curtree, curtree->nodep[enterorder[0]-1],
contml.c:          bestree->copy(bestree, bestree2);
contml.c:          if (bestree2->score < bestree->score)
contml.c:            bestree->copy(bestree, bestree2);
contml.c:        if (njumble > 1) bestree2->copy(bestree2, curtree);
contml.c:        curtree->root = curtree->nodep[outgrno - 1]->back;
contml.c:  funcs->node_new = contml_node_new;
contml.c:  funcs->tree_new = contml_tree_new;
contml.c:  funcs->node_new = contml_node_new;
contml.c:  funcs->tree_new = contml_tree_new;
contrast.c:/* Version 4.0. (c) Copyright 1993-2018 by Joseph Felsenstein.
contrast.c:(1) Put warnings if too many variables (in Within case) to invert matrix --
contrast.c:    matrices in the within-species case
contrast.c:    printf("  W        Within-population variation in data?");
contrast.c:      printf("  H   How close to best-yet logL to show value: ");
contrast.c:          printf("Yes, R-compatible format\n");
contrast.c:    charsd = chars - dropchars;       /* rank of superposed forms */
contrast.c:    charsd2 = chars - (dropchars-2);  /* number of non-location dimensions */
contrast.c:    charsd = chars - dropchars;       /* rank of superposed forms */
contrast.c:    charsd2 = chars - (dropchars-1);  /* number of non-location dimensions */
contrast.c:      exxit(-1);
contrast.c:      exxit(-1);
contrast.c:      nset[n2-1] = 1;
contrast.c:    fprintf(outfile, "----");
contrast.c:    fprintf(outfile, "                       ----------\n\n");
contrast.c:  contnum = spp-1;
contrast.c:      exxit(-1);
contrast.c:        contnum += sample[i]-1;
contrast.c:    for (k = 0; k <= sample[i]-1; k++) {
contrast.c:        if (fscanf(infile, "%lf", &x[i][k][j - 1]) != 1) {
contrast.c:          exxit(-1);
contrast.c:          fprintf(outfile, " %14.9f", x[i][k][j - 1]);
contrast.c:        y[i][k][j-1] = x[i][k][j-1];    /* copy it into  y */
contrast.c:/*    if (!eoln(infile))        debug:  need with within-species variation?
contrast.c:        exxit(-1);
contrast.c:        exxit(-1);
contrast.c:        exxit(-1);
contrast.c:  /* rotate the j-th sample of the i-th form in z by theta */
contrast.c:  costheta = sqrt(1.0 - sintheta*sintheta);
contrast.c:  for (k = startmchar-1; k <= endmchar-2; k += 2) {
contrast.c:    tempx = costheta * z[i][j][k] - sintheta * z[i][j][k+1];
contrast.c:  /* resize the j-th sample of the i-th form in z by logsz,
contrast.c:     alter the log-size in x  */
contrast.c:  for (k = startmchar-1; k <= endmchar-1; k += 1) {
contrast.c:    z[i][j][k] *= exp(-logsz);     /* resize the centered specimens */
contrast.c:    z[i][j][charspp-1] += logsz;  /* change the log-size accordingly */
contrast.c:  specsize[i][j] = z[i][j][charspp-1];   /* also separate log specimen size */
contrast.c:  /* copy j-th sample of the i-th morphometric form from x to temporary
contrast.c:  for (k = 0; k < startmchar-1; k++) { /* copy those before the morphometrics */
contrast.c:  for (k = startmchar-1; k < endmchar; k++) { /* copy, dropping as needed */
contrast.c:  /* retrieve j-th sample of the i-th morphometric form from temporary
contrast.c:  for (k = 0; k < startmchar-1; k++) { /* copy those before the morphometrics */
contrast.c:  for (k = startmchar-1; k < endmchar; k++) { /* copy, dropping as needed */
contrast.c:  /* copy j-th sample of the i-th morphometric form from z to x
contrast.c:    -- note there are  charspp  characters copied, including maybe log(size) */
contrast.c:    for (k = 0; k < startmchar-1; k++) { /* copy those before morphometrics */
contrast.c:    for (k = startmchar-1; k < endmchar; k++) { /* copy, dropping as needed */
contrast.c:  /* copy j-th sample of the i-th morphometric form from z to w
contrast.c:    -- note there are  charspp  characters copied, including maybe log(size) */
contrast.c:    for (k = 0; k < startmchar-1; k++) { /* copy those before morphometrics */
contrast.c:    for (k = startmchar-1; k < endmchar; k++) { /* copy, dropping as needed */
contrast.c:  /* copy j-th sample of the i-th morphometric form from w to z
contrast.c:    -- note there are  charspp  characters copied, including maybe log(size) */
contrast.c:    for (k = 0; k < startmchar-1; k++) { /* copy those before morphometrics */
contrast.c:    for (k = startmchar-1; k < endmchar; k++) { /* copy, dropping as needed */
contrast.c:  for (i = startmchar-1; i <= endmchar-1; i++) /* initialize form mean to 0 */
contrast.c:      for (k = startmchar-1; k <= endmchar-1; k++)
contrast.c:  for (k = startmchar-1; k <= endmchar-1; k ++)
contrast.c:  for (k = startmchar-1; k <= endmchar-2; k += 2) {
contrast.c:  if (fabs(sumsqmux - sumsqmuy) < 1.0e-10)  /* rotation to make axes OK */
contrast.c:  else theta = 0.5 * atan(2.0*sumprodmuxmuy/(sumsqmuy-sumsqmux));
contrast.c:  for (k = startmchar-1; k <= endmchar-2; k += 2) { /* rotate, scale means */
contrast.c:    tempx = costheta * meanform[k] - sintheta * meanform[k+1];
contrast.c:      for (k = startmchar-1; k <= endmchar-2; k += 2) {
contrast.c:        tempx = costheta * z[i][j][k] - sintheta * z[i][j][k+1];
contrast.c:    J3[i] = meanform[startmchar-1+i];   /* mu_x1, mu_y1, mu_x2, ... */
contrast.c:    J4[i] = -meanform[startmchar+i];  /* -mu_y1, mu_x1, -mu_y2, ... */
contrast.c:    J4[i+1] = meanform[startmchar-1+i];
contrast.c:  for (i = 0; i < morphchars; i++)      /* set up  I-J^t J  matrix */
contrast.c:      IJTJ[i][j] -= J3[i]*J3[j] + J4[i]*J4[j];
contrast.c:  for (i = 0; i < spp; i++) {          /* do the Bookstein I-J^t J transform */
contrast.c:          sum += IJTJ[k][l] * z[i][j][startmchar-1+l];
contrast.c:        z[i][j][startmchar-1+k] = tempsum[k] + meanz[k];
contrast.c:      for (k = startmchar-1; k <= endmchar-2; k += 2) {
contrast.c:        tempy = -sintheta * z[i][j][k] + costheta * z[i][j][k+1];
contrast.c:  copyztotemp(n, m);  /* set aside best-yet value */
contrast.c:      copyztotemp(n, m);  /* set aside best-yet value */
contrast.c:  *theta -= tol;
contrast.c:  copytemptoz(n, m);  /* restore best-yet value */
contrast.c:  /* do line search in one direction in steps of tol. return delta-log(size) and
contrast.c:  copyztotemp(n, m);  /* set aside best-yet value */
contrast.c:      copyztotemp(n, m);  /* set aside best-yet value */
contrast.c:  copytemptoz(n, m);  /* set aside best-yet value */
contrast.c://      theta = linesearch(&theta, -tol2, i, j, &changed); /* and downwards */
contrast.c://  logsize = x[i][j][charspp-1];    /* start size after Procrustes */
contrast.c://      logsize = linesearchsz(&logsize, -tol2, i, j, &changed); /* and down */
contrast.c:      for (k = startmchar-1; k <= endmchar-2; k += 2)
contrast.c:      for (k = startmchar; k <= endmchar-1; k += 2)
contrast.c:      for (k = startmchar-1; k <= endmchar-2; k += 2)
contrast.c:        z[i][j][k] -= meanx;        /* subtract out the mean for the form */
contrast.c:      for (k = startmchar; k <= endmchar-1; k += 2)
contrast.c:        z[i][j][k] -= meany;
contrast.c:      for (k = startmchar-1; k <= endmchar-1; k++)
contrast.c:        for (k = startmchar-1; k <= endmchar-1; k += 1) {
contrast.c:      for (j = startmchar-1; j <= endmchar-1; j++)
contrast.c:      for (k = startmchar-1; k <= endmchar-1; k++)
contrast.c:          for (k = startmchar-1; k <= endmchar-1; k++) {
contrast.c:      for (k = startmchar-1; k <= endmchar-1; k++)
contrast.c:        for (k = startmchar-1; k <= endmchar-2; k += 2) {
contrast.c:          A += z[i][j][k]*meanz[k+1] - z[i][j][k+1]*meanz[k];
contrast.c:        for (k = startmchar-1; k <= endmchar-2; k += 2) { /* rotate it */
contrast.c:          z[i][j][k] = (B/D)*oldx - (A/D)*oldy;
contrast.c:  } while (maxrotation > eps);  /* repeatedly Boas-fit until little change */
contrast.c://      which amounts to minimizing  x'C^{-1}x where C is the covariances
contrast.c://   /* note -- this function is not being used right now at all but parts of
contrast.c://   wasrootedatinteriornode = (curtree.root->back == NULL);  /* debug: works? */
contrast.c://     leftbranchlength = curtree.root->next->v;
contrast.c://     rightbranchlength = curtree.root->next->next->v;
contrast.c://       if (wherefrom->tip)
contrast.c://         nearestinternalnode = wherefrom->back;
contrast.c://          in a correctly coordinated way    -- debug */
contrast.c://       makecontrasts(curtree.root->next->back);
contrast.c://       /* now compute inverse of contrasts, plus get JC^(-1)I etc. */
contrast.c://       /*   question -- what to do if C is not of full rank? */
contrast.c://       A1122 = alpha11-alpha22;
contrast.c://       sintheta = sqrt((1.0-cos2theta)/2.0);
contrast.c://         for (k = startmchar-1; k <= endmchar-2; k += 2) {     /* rotate it */
contrast.c://           z[i][j][k] =   costheta*oldx - sintheta*oldy;
contrast.c://     /* this next is just to be used while we are debugging  -- debug */
contrast.c:      rotate(i, j, newparameters[i]-rotation[i][0]);
contrast.c:      resize(i, j, newparameters[i-spp]);  /* debug  make sure is OK */
contrast.c:/* for Nelder-Mead algorithm, find points that are best, worst */
contrast.c:  if (loglike[2] > loglike[nmbestone]) {  /* sort-of assumes no ties */
contrast.c:/* gets the log-like for a new suggested set of parameters */
contrast.c:/* initialize a full set of points for the Nelder-Mead algorithm */
contrast.c:        parameters[i][j] = z[j-spp][0][charspp];
contrast.c:      parameters[i][i-1] += nmupsilon;
contrast.c:/* for Nelder-Mead: replace a point in parameter space with new values */
contrast.c:/* do one step of the Nelder-Mead algorithm */
contrast.c:    nmepsilon += fabs(parameters[nmworstone][i]-parameters[nmbestone][i]);
contrast.c:    nmmeanparams[i] = (nmpoints*nmmeanparams[i] - parameters[nmworstone][i])
contrast.c:                   / (nmpoints - 1);
contrast.c:                        + alpha*(nmmeanparams[i] - parameters[nmworstone][i]);
contrast.c:                           + gammma*(reflectedparameters[i] - nmmeanparams[i]);
contrast.c:                         + rho*(parameters[nmworstone][i] - nmmeanparams[i]);
contrast.c:                        + sigma*(parameters[i][j] - parameters[nmbestone][j]);
contrast.c: /* do log-likelihood rotation, resizing (if called for) */
contrast.c:   alpha = 1.0;  /* constants used in the Nelder-Mead algorithm */
contrast.c:      nmiterateonepoint(); /* make a move in the Nelder-Mead algorithm */
contrast.c:void felsmorph2() { /* do log-likelihood rotation, resizing (if called for)
contrast.c:                   resize(i, j, incparam);  /* change log-size by amount */
contrast.c:                 if (logLnow > bestlogL) { /* if the log-likelihood is better */
contrast.c:                   changeofparam -= incparam;
contrast.c:                   incparam = -incparam*0.3;
contrast.c:  } while (bestlogL - oldlogL > 0.0000000001);
contrast.c:         which = i - spp;
contrast.c:         resize(which, 0, slopeinc);  /* ... or change log-size by */
contrast.c:         sintheta = sin(-slopeinc);
contrast.c:         resize(which, 0, -slopeinc);  /* ... or change log-size by */
contrast.c:     slopes[i] = logLnow - logLnow2;
contrast.c:         which = i - spp;
contrast.c:         resize(which, 0, incparam*slopes[i]);  /* change log-size by amount */
contrast.c:     if (logLnow > bestlogL) { /* if the log-likelihood is better */
contrast.c:       incparam = -incparam*0.3;
contrast.c:  } while (bestlogL - olderlogL > 0.0000000001);
contrast.c:    if (((endmchar-startmchar+1)%2) > 0) {  /* debug:   change for 3D */
contrast.c:      printf("         must be even, but it is %ld.\n\n", endmchar-startmchar+1);
contrast.c:      exxit(-1);
contrast.c:    morphchars = endmchar - startmchar + 1;
contrast.c:    boasfit(); /*  for a rough start, Boas-fit z's to each other */
contrast.c:    } while (endlogL - startlogL > 0.00001);
contrast.c:  /* compute all the within-species contrasts, if any */
contrast.c:  for (i = 0; i <= spp-1 ; i++) {
contrast.c:    for (k = 0; k <= (sample[i]-1); k++) {
contrast.c:            = (sumphen[j] - k*x[i][k][j])/sqrt((double)(k*(k+1)));
contrast.c:        if (k == (sample[i]-1))
contrast.c:          ((cont_node_type*)curtree.nodep[i])->view[j] = sumphen[j]/sample[i];
contrast.c:        curtree.nodep[i]->ssq = 1.0/sample[i]; /* sum of squares for sp. i */
contrast.c:  pp = p->next;
contrast.c:  q = pp->back;    /* starting with first two descendants ... */
contrast.c:  v0 = multiplier * (q->v + q->deltav);
contrast.c:  if (pp->v < 0.0) {
contrast.c:    exxit(-1);
contrast.c:    r = pp->next->back;
contrast.c:    v1 = multiplier * (r->v + r->deltav);
contrast.c:/* debug printf(" %10ld  %10ld  %15.10lf  %15.10lf\n", q->index, r->index, v0, v1);*/  
contrast.c:    if (r->v < 0.0) {
contrast.c:      exxit(-1);
contrast.c:    f1 = 1.0 - f0;
contrast.c:    if (pp == p->next) {
contrast.c:      p->ssq = q->ssq;
contrast.c:      p->deltav = v1 * f1 / multiplier;
contrast.c:      p->deltav = p->deltav * f1 / multiplier;
contrast.c:    p->ssq = f0*f0*p->ssq + f1*f1*r->ssq;
contrast.c:    if (pp == p->next) {  /* view using first two descendants */
contrast.c:        ((cont_node_type*)p)->view[j] = f0 * ((cont_node_type*)q)->view[j]
contrast.c:          + f1 * ((cont_node_type*)r)->view[j];
contrast.c:        cntrast[contno][0][j] = (((cont_node_type*)q)->view[j] -
contrast.c:                                 ((cont_node_type*)r)->view[j])/sqrt(vtot);
contrast.c:/* debug printf(" %10ld  %10ld  %15.12f %15.10f \n", q->index, r->index, vtot, cntrast[contno][0][j]);  */  
contrast.c:      ssqcont[contno][0] = q->ssq + r->ssq;
contrast.c:        ((cont_node_type*)p)->view[j] = f0 * ((cont_node_type*)p)->view[j]
contrast.c:          + f1 * ((cont_node_type*)r)->view[j];
contrast.c:        cntrast[contno][0][j] = (((cont_node_type*)p)->view[j] -
contrast.c:                                 ((cont_node_type*)r)->view[j])/sqrt(vtot);
contrast.c:      ssqcont[contno][0] = p->ssq + r->ssq;    /* debug: q? */
contrast.c:/* jacobian -= 0.5 * charsd * log((v0+v1));   debug */
contrast.c:   jacobian -= 0.5 * charsd * log(ssqcont[contno][0]);
contrast.c:    contno++;       /* added one more between-species contrast */
contrast.c:    v0 = multiplier * p->deltav;
contrast.c:    pp = pp->next;
contrast.c:  } while (((!atbase) && ((pp->next) != p))
contrast.c:           || (atbase && (((curtree.root->back == NULL)
contrast.c:                           && (pp->next != curtree.root))
contrast.c:                          || ((curtree.root->back != NULL)
contrast.c:  if (p->tip) {
contrast.c:      zsum += ((cont_node_type*)p)->view[charspp-1];
contrast.c:  pp = p->next;
contrast.c:    makecontrasts(pp->back);
contrast.c:    pp = pp->next;
contrast.c:           || (atbase && (pp != p->next) && (pp->back != NULL)));
contrast.c:  /* debug -- check that the covariances are not done already if fossil case */
contrast.c:    mean[i] = ((cont_node_type*)curtree.root)->view[i];
contrast.c:    fprintf(outfile, "--------- -------- --- --------- -----------\n\n");
contrast.c:  for (i = 0; i <= contno - 1; i++) {
contrast.c:    fprintf(outfile, "------------- --");
contrast.c:      fprintf(outfile, " ------ --");
contrast.c:    fprintf(outfile, "  ------ -------- --- ------------\n\n");
contrast.c: fprintf(outfile, " %ld %ld\n", spp, endmchar-startmchar+1); /* debug: if W? */
contrast.c:      for (k = startmchar-1; k <= endmchar-2; k += 2)
contrast.c:      for (k = startmchar-1; k <= endmchar-2; k += 2)
contrast.c:        x[i][j][k] -= meanx;        /* subtract out the mean for the form */
contrast.c:      for (k = startmchar; k <= endmchar-1; k += 2)
contrast.c:        x[i][j][k] -= meany;
contrast.c:      for (j = startmchar-1; j <= endmchar-1; j++)
contrast.c:    for (j = startmchar-1; j <= endmchar-1; j++) {
contrast.c:  fprintf(outfile, "-------- ----- ------\n\n");
contrast.c:  fprintf(outfile, "--------- -----\n\n");
contrast.c:  for (i = 0; i < spp; i++) {  /* debug  ignores within-species case */
contrast.c:  fprintf(outfile, "-------- ------ ------- -- --- ---------\n\n");
contrast.c:  for (i = 0; i < spp; i++) {  /* debug  ignores within-species case */
contrast.c:  fprintf(outfile, "-------- -- -----\n");
contrast.c:  fprintf(outfile, "-------- -------- ---------\n\n");
contrast.c:{  /* write out allometry coefficients in log-likelihood and linear cases
contrast.c:  fprintf(outfile, "---------- ------------- ----- ----- - --------- -- -----\n"); 
contrast.c:{ /* compute, in ML-plus-linearsize case, the size variance,
contrast.c:    sumprods[charspp-1][charspp-1] = varz;  /* put in new part of diagonal */
contrast.c:      temp8[i] -= mean[i]*varz;
contrast.c:      sumprods[i][charspp-1] = temp8[i]; /* put it in extra row, column */
contrast.c:      sumprods[charspp-1][i] = temp8[i];
contrast.c:      sumprods[i][j] = sumprods[i][j] - temp1[i][j] - temp1[j][i]
contrast.c:  fprintf(outfile, "---------- ------\n\n");
contrast.c:        fprintf(outfile, "\nSizes are being inferred by ML:\n variables 1 - %ld are shape variables\n", chars);
contrast.c:        fprintf(outfile, "   variables 1 - %ld are shape variables\n", chars);
contrast.c:      fprintf(outfile, "---------- ------ -- ------\n\n");
contrast.c:    fprintf(outfile, "----------- -------- -- -----\n\n");
contrast.c:    fprintf(outfile, "------------\n\n");
contrast.c:    logLvara = -0.5*contno*logdet(temp1);
contrast.c:    logLnocorr = -0.5*contno*logdet(temp1);
contrast.c:            n1*(n1+1)/2+(charsd-n1+1)*(charsd-n1)/2);
contrast.c:            logLvara-logLnocorr);
contrast.c:    fprintf(outfile, "                Chi-square value  = %12.5f,",
contrast.c:            2.0*(logLvara-logLnocorr));
contrast.c:    if (n1*(charsd-n1) == 1)
contrast.c:              n1*(charsd-n1));
contrast.c:              n1*(charsd-n1));
contrast.c:  /* Gauss-Jordan log determinant calculation.
contrast.c:    if (fabs(a[i][i]) < 1.0E-37) {
contrast.c:      exxit(-1);
contrast.c:          a[j][k] -= temp * a[i][k];
contrast.c:  /* Gauss-Jordan reduction -- invert chars x chars matrix a
contrast.c:    if (fabs(a[i][i]) < 1.0E-37) {
contrast.c:      exxit(-1);
contrast.c:          a[j][k] -= temp * a[i][k];
contrast.c:  /* estimate VE from within contrasts -- unbiasedly */
contrast.c:  /* estimate VA from between contrasts -- biasedly: does not take out VE */
contrast.c:        for (k = 0; k < spp-1; k++) {
contrast.c:                / ((long)(spp-1)*ssqcont[k][0]);
contrast.c:          s += fabs(vara[i][j]/oldvara[i][j]-1.0);
contrast.c:        s += fabs(vare[i][j]/oldvare[i][j]-1.0);
contrast.c:  for (i = 0; i < spp-1; i++) {            /* accumulate over contrasts ... */
contrast.c:    if (i <= spp-2) {       /* E(aa'|x) and E(ee'|x) for "between" contrasts */
contrast.c:      invert(temp2);                               /* compute (dA+E)^(-1)  */
contrast.c:      /* sum of - x (dA+E)^(-1) x'/2 for old A, E */
contrast.c:          sum2 -= cntrast[i][0][k]*temp2[k][l]*cntrast[i][0][l]/2.0;
contrast.c:      sum2 -= 0.5 * logdet(temp3);      /* log determinant term too */
contrast.c:            Bax[k][l] = sum;           /*  Bax  = sqrt(d) * A *(dA+E)^(-1) */
contrast.c:          Bex[k][l] = sum;                   /*  Bex = (dA+E)^(-1) * E */
contrast.c:                   - temp1[m][l]);
contrast.c:            temp2[k][l] = sum;        /*  Bax * (xx'- (dA+E)) ... */
contrast.c:                                - temp1[m][l]);
contrast.c:          temp2[k][l] = sum;            /*  Bex * (xx'-(dA+E)) ... */
contrast.c:  invert(temp2);                          /* get E^(-1) */
contrast.c:            vare[k][l] += cntrast[i][j][k] * cntrast[i][j][l] - oldvare[k][l];
contrast.c:            sum2 -= cntrast[i][j][k] * temp2[k][l] * cntrast[i][j][l] / 2.0;
contrast.c:            /* accumulate - x*E^(-1)*x'/2 for old E */
contrast.c:        sum2 -= sum3;                          /* log determinant term too */
contrast.c:  /* print out ML covariances and regressions in the error-covariance case */
contrast.c:    fprintf(outfile, "-------- -- ----\n");
contrast.c:  fprintf(outfile, "-------- -- ----\n");
contrast.c:    fprintf(outfile, "---- ----------- -------- -- -----\n\n");
contrast.c:    fprintf(outfile, "---- ------------\n\n");
contrast.c:  fprintf(outfile, "---- ----------- -------- -- -----\n\n");
contrast.c:  fprintf(outfile, "---- ------------\n\n");
contrast.c:      d = ctheta * a[i - 1][k] + stheta * a[j - 1][k];
contrast.c:      a[j - 1][k] = ctheta * a[j - 1][k] - stheta * a[i - 1][k];
contrast.c:      a[i - 1][k] = d;
contrast.c:      d = ctheta * a[k][i - 1] + stheta * a[k][j - 1];
contrast.c:      a[k][j - 1] = ctheta * a[k][j - 1] - stheta * a[k][i - 1];
contrast.c:      a[k][i - 1] = d;
contrast.c:      coeffs(a[i - 2][i - 1], a[i - 2][j - 1], &c, &s,accuracy);
contrast.c:{ /* QR eigenvalue-finder */
contrast.c:  for (i = n; i >= 2; i--) {
contrast.c:      TEMP = a[i - 2][i - 2] - a[i - 1][i - 1];
contrast.c:      TEMP1 = a[i - 1][i - 2];
contrast.c:      approx = a[i - 2][i - 2] + a[i - 1][i - 1];
contrast.c:      if (a[i - 1][i - 1] < a[i - 2][i - 2])
contrast.c:        approx = (approx - d) / 2.0;
contrast.c:        a[j][j] -= approx;
contrast.c:        coeffs(a[j - 1][j - 1], a[j][j - 1], &c, &s, accuracy);
contrast.c:    } while (fabs(a[i - 1][i - 2]) > accuracy);
contrast.c:  accuracy = 1.0e-15;
contrast.c:    n = eigorder[m-i-1];
contrast.c:      if ((j > 0) && (j%6 == 5) && ((j+1) != charspp)) /* in 6-column blocks */
contrast.c:          "   --------- ---------- ------ -- ------ ------------ -- ---------- ---------\n\n");
contrast.c:  fprintf(outfile, "   --------       -----------        -----------");
contrast.c:    fprintf(outfile, "      -----------\n");
contrast.c:    n = m-i-1;
contrast.c:  generic_node_init(&(cn->cont_node_var.node_var), type, index);
contrast.c:  ((cont_node_type*)(cn))->view = (phenotype3)Malloc((long)charspp * sizeof(double));
contrast.c:  cn->cont_node_var.node_var.copy = contrast_node_copy;
contrast.c:  cn->cont_node_var.node_var.reinit = contrast_node_reinit;
contrast.c:{ /* re-init a contrast_node */
contrast.c:  generic_node_reinit(&(cn->cont_node_var.node_var));
contrast.c:  n = treep->get_forknode(treep, index);
contrast.c:      (*p)->tip = false;
contrast.c:      nodep[(*p)->index - 1] = (*p);
contrast.c:      (*p)->tip = false;
contrast.c:      (*p)->tip = (nodei <= spp);
contrast.c:      nodei = (*p)->index; /* debug  Why not also necessary in initdnamlnode?  */
contrast.c:      (*p)->deltav = 0.0;
contrast.c:      (*p)->tip = (nodei <= spp);
contrast.c:      (*p)->v = valyew / divisor;
contrast.c:      (*p)->iter = false;
contrast.c:      if ((*p)->back != NULL) {
contrast.c:        (*p)->back->v = (*p)->v;
contrast.c:        (*p)->back->iter = false;
contrast.c:  /* debug -- this will need expansion when within-species variation is also
contrast.c:  for (i = 0; i <= contno - 2; i++) {
contrast.c:  if (!(p->tip)) {
contrast.c:    pp = p->next;
contrast.c:      bltimetraverse (pp->back, timedowntohere);
contrast.c:      if ((*timedowntohere) + multiplier * pp->v > p->tyme)
contrast.c:        p->tyme = (*timedowntohere) + multiplier * pp->v;
contrast.c:      *timedowntohere = p->tyme;
contrast.c:      pp = pp->next;
contrast.c:    if (isfossil[p->index])
contrast.c:      p->tyme = fossiltime[p->index - 1];
contrast.c:      p->tyme = 0.0;
contrast.c:  (*timedowntohere) = p->tyme;
contrast.c:  if (p->tip)
contrast.c:    p->onlyfossilsabove = isfossil[p->index];
contrast.c:    p->fossilsabove = isfossil[p->index];
contrast.c:    if (isfossil[p->index])
contrast.c:      p->lowestfossilabove = p->tyme;
contrast.c:    pp = p->next;
contrast.c:      updatebounds(pp->back);
contrast.c:      allofonedescfossils = allofonedescfossils || pp->back->onlyfossilsabove;
contrast.c:      allfossilsabove = allfossilsabove && pp->back->onlyfossilsabove;
contrast.c:      somefossilsabove = somefossilsabove || pp->back->fossilsabove;
contrast.c:      if (pp->back->lowestfossilabove > lowestfossilabovehere)
contrast.c:        lowestfossilabovehere = pp->back->lowestfossilabove;
contrast.c:      pp = pp->next;
contrast.c:    p->onlyfossilsabove = allfossilsabove;
contrast.c:    p->fossilsabove = somefossilsabove;
contrast.c:      pp = p->next;     /* start around the ring again */
contrast.c:      do {        /* find the oldest of the ancestral-to-fossils-only nodes */
contrast.c:        if (pp->back->onlyfossilsabove) {
contrast.c:          if (pp->back->tyme > lowestfossil)
contrast.c:            lowestfossil = pp->back->tyme;
contrast.c:        pp = pp->next;
contrast.c:        if (lowestfossil > minmultmult * multiplier * p->tyme)
contrast.c:          minmultmult = lowestfossil / (p->tyme * multiplier);
contrast.c:/* debug -- should we correct for jacobian of size correction here ?? */
contrast.c://   printf(" %12.8f", -0.5*contno*log(eig[charspp-i-1])); /*debug */
contrast.c:      ldet += log(eig[charspp-i-1]);
contrast.c:    logL = -contno*charsd*log(2*pi)/2.0
contrast.c:            -contno*charsd/2.0-0.5*contno*ldet+jacobian - charsd*zsum;
contrast.c:    logL = -contno*charsd*log(2*pi)/2.0
contrast.c:             -contno*charsd/2.0-0.5*contno*ldet+jacobian;
contrast.c:// printf(" %20.12f\n",-contno*charsd*log(2*pi)/2.0);
contrast.c:// printf(" %20.12f\n",-contno*charsd/2.0);
contrast.c:// printf(" %20.12f\n",-0.5*contno*ldet);
contrast.c:// printf(" %20.12f\n",-charsd*zsum);
contrast.c:    r = curtree.nodep[fossilsp[k]-1];
contrast.c:    rr = r->back->next->next;
contrast.c:    r->v = (rr->tyme - r->tyme)/multiplier;
contrast.c:      rr->back->v = r->v;
contrast.c:    bestplace = r->back->next->back->index; // RSGnote: If "numfossils" == 0, "r" will be uninitialized here.
contrast.c:    if (logL > (bestlogL - howworse))
contrast.c:  upperlimit = p->tyme;  /* p can connect from its own tyme ... */
contrast.c:  if (upperlimit < q->tyme) /* ... or from q's tyme, on back */
contrast.c:    upperlimit = q->tyme;
contrast.c:  for (i = 1; i <= ndiv; i++) {/* try ndiv equally-spaced places in branch */
contrast.c:    twhere = ((2*i-1)*q->back->tyme + (2*ndiv+1-2*i)*upperlimit)/(2.0*ndiv);
contrast.c:    p->v = (twhere - p->tyme)/multiplier;
contrast.c:    p->back->v = p->v;
contrast.c:    p->back->next->v = (twhere - q->tyme)/multiplier;
contrast.c:    p->back->next->back->v = p->back->next->v;
contrast.c:    if (p->back->next->next->back != NULL) {
contrast.c:      p->back->next->next->v =
contrast.c:        (curtree.nodep[p->back->next->next->back->index - 1]->tyme
contrast.c:         - twhere)/multiplier;
contrast.c:      p->back->next->next->back->v = p->back->next->next->v;
contrast.c:    p->back->next->next->tyme = p->tyme + p->v;
contrast.c:    qq = curtree.nodep[q->back->index - 1];   /* qq  is node ancestral to q */
contrast.c:    if (q->tyme > qq->tyme)                   /* switch them if out of time order */
contrast.c:    if (qq->tyme < p->tyme) {/* check if can't connect fossil to this branch */
contrast.c:                q->index, curtree.nodep[q->index-1]->tyme/multiplier,
contrast.c:                q->back->index, curtree.nodep[q->back->index-1]->tyme/multiplier);
contrast.c:      tup = q->tyme;
contrast.c:      if (tup < p->tyme)
contrast.c:        tup = p->tyme;
contrast.c:      tnew = (tup + qq->tyme)/2.0;
contrast.c:      p->back->tyme = tnew;   /* place new node halfway between nearby ones */
contrast.c:      q->back->tyme = tnew;
contrast.c:      q->back->next->tyme = tnew;
contrast.c:        fprintf(outfile, "     ------  -----------    -----     ------\n");
contrast.c:      q1 = curtree.nodep[q->back->index-1];
contrast.c:      q->v = (q1->tyme - q->tyme)/multiplier;
contrast.c:      q->back->v = q->v;
contrast.c:    if (p->tyme > q->tyme)
contrast.c:      p->back->tyme = p->tyme + 0.1;
contrast.c:      p->back->tyme = q->tyme + 0.1;
contrast.c:    p->back->next->tyme = p->back->tyme;  /* set tymes of new root node */
contrast.c:    p->back->next->next->tyme = p->back->tyme;
contrast.c:    curtree.root = p->back->next->next;
contrast.c:    tup = q->tyme;
contrast.c:    if (tup < p->tyme)
contrast.c:      tup = p->tyme;
contrast.c:      fprintf(outfile, " place species %ld between node %ld (length ago: %6.3f) and -infinity\n",
contrast.c:              p->index, q->index, curtree.nodep[q->index-1]->tyme);
contrast.c:      fprintf(outfile, "     ------  -----------    -----     ------\n");
contrast.c:  /* traverse to place the n-th fossil, scaling tree each time.  Be careful not
contrast.c:  worked = placefossilonbranch(curtree.nodep[fossilsp[n-1]-1], p);
contrast.c:  if (!(p->tip)) {
contrast.c:    pp = p->next;
contrast.c:      r = pp->back;
contrast.c:      pp = pp->next;
contrast.c:             || (atbase && (((curtree.root->back == NULL) && (pp != curtree.root))
contrast.c:                            || ((curtree.root->back != NULL) && (pp != curtree.root->next))
contrast.c:  /* dummy for now -- this finally connects the fossil in the best place */
contrast.c:  emptynode = nonodes - numfossils;
contrast.c:    q = curtree.nodep[fossilsp[i]-1];   /* a pointer to that fossil */
contrast.c:    q->tip = true;
contrast.c:      initcontrastnode(&p->next, &grbg, NULL, 0.0, emptynode, &spp, 0, nonbottom, NULL, curtree.nodep, NULL, NULL, NULL);
contrast.c:      p = p->next;
contrast.c:    p->next = p;                        // connect last part of triangle
contrast.c:    t->get_forknode(t, emptynode);      /* get a fork */
contrast.c:    p->index = emptynode+1;             /* set up number of new interior node */
contrast.c:    p->next->index = p->index;          // RSGnote: Using a non-initialized pointer for a memory write.
contrast.c:    p->next->next->index = p->index;
contrast.c:    hookup(p, q);                       /* hook up the fossil to the triangle of new interior-type nodes */
contrast.c:  curtree.nodep[fossilsp[n-1]-1]->tyme = fossiltime[n-1];
contrast.c:           n, fossilsp[n-1]);
contrast.c:  firstplace = true;      /* used to set up saving of best log-likelihood */
contrast.c:    multiplier = (minmultmult*(2*nmult-j)+maxmultmult*j)*multiplier0/(2*nmult);
contrast.c:  replacefossil();  /* debug -- what arguments to use? */
contrast.c:  /*  debug -- the iterative machinery will be placed here but for now we
contrast.c:  bifurcating = (curtree.root->next->next == curtree.root);
contrast.c:          varz = sumprod[charspp-1][charspp-1]; 
contrast.c:        fprintf(outfile, "    ---------- ----- ----");
contrast.c:          fprintf(outfile,  " -- -- -----------");
contrast.c:          fprintf(outfile, " ---");
contrast.c:          fprintf(outfile,  " -- -- ---- ---------");
contrast.c:          fprintf(outfile, "  %ld parameters\n\n", n1*(n1+1)/2+(charsd-n1+1)*(charsd-n1)/2+charsd*(charsd+1)/2);
contrast.c:                  logLvara-logLnocorr);
contrast.c:          fprintf(outfile, "                Chi-square value = %13.5f,",
contrast.c:                  2.0*(logLvara-logLnocorr));
contrast.c:          if (n1*(charsd-n1) == 1)
contrast.c:                    n1*(charsd-n1));
contrast.c:                    n1*(charsd-n1));
contrast.c:                  logLvara-logLnovara);
contrast.c:          fprintf(outfile, "                Chi-square value = %13.5f,",
contrast.c:                  2.0*(logLvara-logLnovara));
contrast.c:  funcs->node_new = contrast_node_new;
contrast.c:  /* Open in binary: ftell() is broken for UNIX line-endings under WIN32 */
contrast.c:  ncases = numtrees;    /* ncases will be how many tree-data pairs are done */
debug.c:/* Version 4.0. (c) Copyright 2012-2013 by the University of Washington.
debug.c:    // Can't check validity of anything because we have no TREE to traverse for INTREE nodes.  Could be printing an INTREE node, a non-INTREE (in nodep[] but not in a TREE), or a garbage node.
debug.c:    (void)nodegutsprinter("NODE", pq, (node *)0, 0, stdout); // Will always report node as non-ROOT because pointer-to-root argument is NULL here.
debug.c:  if ((pt == NULL) || pt->root)         // OK to print or check if pt is NULL or if pt is valid and pt->root is valid, but don't call if pt->root is NULL.
debug.c:    // Label the printout for the upcoming batch of text.  This gets printed before COUNT_EM gets called, which might print an error message, in which case this line gets re-printed with the ErrorCode.
debug.c:    // Next line expressions evaluated left-to-right, so GLOBAL_ERRORCODE will contain value set by COUNT_EM (if it gets set) after call to TREEPRINTER returns.
debug.c:    // Now reprint any non-zero ERRORCODE returns, so that other programs can GREP for these codes.
debug.c:    tnonodes = (int)pt->nonodes;
debug.c:    tspp = (int)pt->spp;
debug.c:              (void *) pt, tspp, tnonodes, pt->type, (void *)pt->nodep, (void *)pt->root, (void *)pt->free_forkrings, (void *)pt->free_forknodes);
debug.c:          pq = pt->nodep[nodepidx];
debug.c:          if (pq)                       // If the array slot is non-NULL,
debug.c:            pq->type = NODE_T_UNKNOWN;  // Clear its INTREE bit (using MODE_T_UNKNOWN in TYPE slot as "not-INTREE" indication; slot is otherwise unused).
debug.c:              pp = pq->next;             // Set PP to its successor.
debug.c:              while (pp && (pp != pq))   // Iterate (as long as node pointer is non-NULL) until we return to starting point.
debug.c:                pp->type = NODE_T_UNKNOWN; // Clear INTREE bit for rest of FORKnodes in the FORKring.
debug.c:                pp = pp->next;
debug.c:        clearintreebits(pt->free_forknodes, false);
debug.c:        clearintreebits(pt->free_forkrings, true);
debug.c:        if (pt->root->tip)
debug.c:          if (pt->root->back)              // If ROOT node (TIP, in this case) has non-NULL BACK, traverse from there; it may have a NULL BACK.
debug.c:            tree_traverse(pt->root->back); // Then traverse the tree recursively, starting from the FORKnode pointing to this TIPnode, marking all nodes which ARE in the tree as being INTREE nodes.
debug.c:          tree_traverse(pt->root);      // Or traverse the tree recursively from the ROOT node, starting from this FORKnode, marking all nodes which ARE in the tree as being INTREE nodes.
debug.c:      // Done with garbage-handling and now back to tree printing.
debug.c:        pq = pt->nodep[nodepidx];
debug.c:          if ((int)pq->index != (nodepidx + 1))
debug.c:              fprintf(stream, "======> DEBUG ERROR (001):  A NODE's INDEX (%d) does not match nodep[] slot index (%d) + 1.\n", (int)pq->index, nodepidx);
debug.c:              fprintf(stream, "    NODEP[%d] is %p -> ", nodepidx, (void *)pq);
debug.c:            if (! pq->tip)
debug.c:            if (pq->type == NODE_T_UNKNOWN) // Non-INTREE nodes (in nodep[] array but not reachable in a tree traversal from ROOT).
debug.c:              errorcode = nodeloopprinter("non-INTREE", pq, pt->root, 1, stream); // BACK is arbitary (may be partially initialized and not yet on garbage list).
debug.c:                return(errorcode);      // A non-INTREE TIPnode had a non-NULL NEXT pointer.
debug.c:            else if (pq == pt->root)    // INTREE and ROOT TIPnode.
debug.c:              if (pq->back)
debug.c:                errorcode = nodeloopprinter("yes-INTREE", pq, pt->root, 1, stream);
debug.c:                errorcode = nodeloopprinter("yes-INTREE", pq, pt->root, 1, stream);
debug.c:            else                        // INTREE and non-ROOT TIPnode; must have mutually-reflective BACK state.
debug.c:              errorcode = nodeloopprinter("yes-INTREE", pq, pt->root, 1, stream);
debug.c:              fprintf(stream, "    NODEP[%d] is %p ->:\n", nodepidx, (void *)pq);
debug.c:            if (pq->tip)
debug.c:            // Assumption is that all Non-INTREE nodes are on the FREE_FORKNODES list or on the FREE_FORKRINGS list and all nodes on those lists are Non-INTREE.
debug.c:            if (pq->type == NODE_T_UNKNOWN) // Non-INTREE nodes (in nodep[] array but not reachable in a tree traversal from ROOT).
debug.c:              errorcode = nodeloopprinter("      non-INTREE", pq, pt->root, 0, stream);
debug.c:                return(errorcode);      // An non-INTREE FORKnode not reachable in tree traversal from ROOT.
debug.c:            else if (pq == pt->root)    // INTREE and ROOT FORKnode.
debug.c:              if (pq->back)             // If BACK is non-NULL, it must be mutually-reflective (point to its BACK's BACK).
debug.c:                errorcode = nodeloopprinter("      yes-INTREE", pq, pt->root, 2, stream);
debug.c:                errorcode = nodeloopprinter("      yes-INTREE", pq, pt->root, 2, stream);
debug.c:            else                        // INTREE and non-ROOT FORKnode; must have mutually-reflective BACK state.
debug.c:              errorcode = nodeloopprinter("      yes-INTREE", pq, pt->root, 2, stream);
debug.c:      if (pt->free_forkrings == NULL && pt->free_forknodes == NULL)
debug.c:      else if (pt->free_forknodes == NULL)
debug.c:          fprintf(stream, "  FREE_FORKRINGS (length %d):\n", (int)pt->free_forkrings->length);
debug.c:        errorcode = forklistprinter(pt->free_forkrings, pt->root, 2, true, stream);
debug.c:          return(errorcode);            // Garbage FORKnodes (on the FREE_FORKRINGS list) must have non-NULL NEXT pointers.
debug.c:      else if (pt->free_forkrings == NULL)
debug.c:          fprintf(stream, "  FREE_FORKNODES (length %d):\n", (int)pt->free_forknodes->length);
debug.c:        errorcode = forklistprinter(pt->free_forknodes, pt->root, 1, false, stream);
debug.c:          fprintf(stream, "  FREE_FORKNODES (length %d):\n", (int)pt->free_forknodes->length);
debug.c:        errorcode = forklistprinter(pt->free_forknodes, pt->root, 1, false, stream);
debug.c:          fprintf(stream, "  FREE_FORKRINGS (length %d):\n", (int)pt->free_forkrings->length);
debug.c:        errorcode = forklistprinter(pt->free_forkrings, pt->root, 2, true, stream);
debug.c:          return(errorcode);            // Garbage FORKnodes (on the FREE_FORKRINGS list) must have non-NULL NEXT pointers.
debug.c:  int listidx, listlen = (int)forklist->length;
debug.c:  Slist_node_ptr snp = forklist->first;
debug.c:    node * pq = (node *)snp->data;
debug.c:    pq->type = NODE_T_UNKNOWN;          // Clear its INTREE bit (using MODE_T_UNKNOWN in TYPE slot as "not-INTREE" indication; slot is otherwise unused).
debug.c:      node * pp = pq->next;             // Set PP to its successor.
debug.c:      while (pp && (pp != pq))          // Iterate (as long as node pointer is non-NULL) until we return to starting point.
debug.c:        pp->type = NODE_T_UNKNOWN;      // Clear INTREE bit for rest of FORKnodes in the FORKring.
debug.c:        pp = pp->next;
debug.c:    snp = snp->next;                    // Go to next data container on list (whose snp->data component is a FORKnode).
debug.c:  if (pn->type == NODE_T_GENERIC)       // If this node has already been marked as INTREE, return (prevents infinite recursion).
debug.c:  pn->type = NODE_T_GENERIC;            // Mark node (TIP or FORK) as being INTREE, not a garbage node or a disconnected chunk.
debug.c:  if (! pn->tip)                        // If a FORKnode, count its siblings and mark them, recursively traversing each and its BACKee.
debug.c:    if (pn->back)                       // Recursively mark the FORKnode's BACK (if it is either a TIPnode or another FORKring; could be NULL).
debug.c:      tree_traverse(pn->back);
debug.c:      pn = pn->next;                    // Mark starting from startnode's NEXT and ending with STARTNODE.
debug.c:      if (pn && pn->back)
debug.c:        pn->type = NODE_T_GENERIC;       // Mark FORKnode as being INTREE, not a garbage node or a disconnected chunk.
debug.c:        tree_traverse(pn->back);         // Recursively mark all other nodes reachable from this FORKnode.
debug.c:  assert(! pq->tip);                    // Make sure argument node is a FORKnode, not a TIPnode (should never happen).
debug.c:  pn = pq->next;
debug.c:    if (pn->next != pq)
debug.c:        if (pp == pn->next)             // Found a FORKring which closes OTHER than at the starting point; fatal error; abort immediately.
debug.c:        pp = pp->next;
debug.c:    pn = pn->next;
debug.c:// nextNodeState:  1 ==> must be NULL; 2 ==> must be non-NULL.
debug.c:  int listidx, errorcode, listlen = (int)forklist->length;
debug.c:  Slist_node_ptr snp = forklist->first;
debug.c:    if (snp->data == NULL)
debug.c:    pq = (node *)snp->data;
debug.c:    // or valid NEXT pointers (if they are on the FREE_FORKRINGS list), and their BACK nodes are arbitrary (will be initialized when re-used).
debug.c:    if (pq->type == NODE_T_GENERIC)     // Found an INTREE node (in nodep[] array and reachable in a tree traversal from ROOT) on a Garbage list.
debug.c:        (void)nodeloopprinter("      yes-INTREE", pq, prootnode, nextNodeState, stream);
debug.c:    else                                // Non-INTREE (on the FREE_FORKNODES list or on the FREE_FORKRINGS list).
debug.c:      errorcode = nodeloopprinter("      non-INTREE", pq, prootnode, nextNodeState, stream);
debug.c:    if ((listidx == listlen - 1) && (snp != forklist->last))
debug.c:    snp = snp->next;                    // Go to next data container on list (whose snp->data component is a FORKnode).
debug.c:// nextNodeState:  1 ==> must be NULL; 2 ==> must be non-NULL.
debug.c:    if (pq == pq->next)                 // Make sure next pointer in loop does not loop immediately to self.
debug.c:    if (pq->tip)                        // If node is TIPnode, with a single iteration we are done.
debug.c:    if ((nextNodeState == 1) && (pq->next == NULL)) // If NEXT is supposed to be NULL (and it is), the node must be a FORKnode on the FREE_FORKNODES list; break out of the iteration.
debug.c:    pq = pq->next;                      // Go on to next node in the loop.
debug.c:// nextNodeState:  0 ==> no test (unknown constraint; anything is valid); 1 ==> must be NULL; 2 ==> must be non-NULL.
debug.c:      fprintf(stream, "======> DEBUG ERROR (013):  A NODE-pointer is NULL.\n");
debug.c:    if (pq->tip)
debug.c:      fprintf(stream, "%s, %s, TIP at %p", label, (pq == prootnode) ? "yes-ROOT" : "non-ROOT", (void *)pq);
debug.c:      fprintf(stream, "%s, %s, FORK at %p", label, (pq == prootnode) ? "yes-ROOT" : "non-ROOT", (void *)pq);
debug.c:    fprintf(stream, ", NODE.next: %p, NODE.index: %d, NODE.init: %d, NODE.back: %p", (void *)pq->next, (int)pq->index, pq->initialized, (void *)pq->back);
debug.c:    if (pq->back)
debug.c:      fprintf(stream, ", BACK.back: %p, BACK.next: %p, BACK.index: %d, BACK.init: %d", (void *)pq->back->back, (void *)pq->back->next, (int)pq->back->index, pq->back->initialized);
debug.c:  // or should always be non-NULL (for FORKnodes on the FREE_FORKRINGS list or for FORKnodes in a NODEP array).
debug.c:  if ((nextNodeState == 1) && pq->next)  // TIPnode or FORKnode on the FREE_FORKNODES list; NEXT should be NULL.
debug.c:      fprintf(stream, "======> DEBUG ERROR (014):  A TIPnode or garbage FORKnode (on the FREE_FORKNODES list) has a Non-NULL NEXT pointer.\n");
debug.c:  else if ((nextNodeState == 2) && (pq->next == NULL)) // FORKnode NEXT should be non-NULL for FORKnodes in TREE or garbage on the FREE_FORKRINGS list.
disc.c:/* Version 4.0. (c) Copyright 1993-2013 by the University of Washington.
disc.c:    headings(chars, "Characters", "----------");
disc.c:    initname(i-1);
disc.c:        putc(nayme[i - 1][j], outfile);
disc.c:      treenode[i - 1]->stateone[j] = 0;
disc.c:      treenode[i - 1]->statezero[j] = 0;
disc.c:      k = (j - 1) % bits + 1;
disc.c:      l = (j - 1) / bits + 1;
disc.c:        exxit(-1);
disc.c:        treenode[i - 1]->stateone[l - 1] = ((long)treenode[i - 1]->stateone[l - 1]) | (1L << k);
disc.c:        treenode[i - 1]->statezero[l - 1] = ((long)treenode[i - 1]->statezero[l - 1]) | (1L << k);
disc.c:          extras[j - 1] += weight[j - 1];
disc.c:          treenode[i - 1]->stateone[l - 1] = ((long)treenode[i - 1]->stateone[l - 1]) | (1L << k);
disc.c:          treenode[i - 1]->statezero[l - 1] = ((long)treenode[i - 1]->statezero[l - 1]) | (1L << k);
disc.c:    headings(chars, "Characters", "----------");
disc.c:    initname(i-1);
disc.c:        putc(nayme[i - 1][j], outfile);
disc.c:      treenode[i - 1]->fulstte1[j] = 0;
disc.c:      treenode[i - 1]->fulstte0[j] = 0;
disc.c:      treenode[i - 1]->empstte1[j] = 0;
disc.c:      treenode[i - 1]->empstte0[j] = 0;
disc.c:      k = (j - 1) % bits + 1;
disc.c:      l = (j - 1) / bits + 1;
disc.c:        exxit(-1);
disc.c:        treenode[i-1]->fulstte1[l-1] =
disc.c:          ((long)treenode[i-1]->fulstte1[l-1]) | (1L << k);
disc.c:        treenode[i-1]->empstte1[l-1] =
disc.c:          treenode[i-1]->fulstte1[l-1];
disc.c:        treenode[i-1]->fulstte0[l-1] =
disc.c:          ((long)treenode[i-1]->fulstte0[l-1]) | (1L << k);
disc.c:        treenode[i-1]->empstte0[l-1] =
disc.c:          treenode[i-1]->fulstte0[l-1];
disc.c:        extras[j-1] += weight[j-1];
disc.c:    (*treenode)[i]->stateone = (bitptr)Malloc(words * sizeof(long));
disc.c:    (*treenode)[i]->statezero = (bitptr)Malloc(words * sizeof(long));
disc.c:      p->stateone = (bitptr)Malloc(words * sizeof(long));
disc.c:      p->statezero = (bitptr)Malloc(words * sizeof(long));
disc.c:      p->next = q;
disc.c:    p->next->next->next = p;
disc.c:    (*treenode)[i]->fulstte1 = (bitptr)Malloc(words * sizeof(long));
disc.c:    (*treenode)[i]->fulstte0 = (bitptr)Malloc(words * sizeof(long));
disc.c:    (*treenode)[i]->empstte1 = (bitptr)Malloc(words * sizeof(long));
disc.c:    (*treenode)[i]->empstte0 = (bitptr)Malloc(words * sizeof(long));
disc.c:    (*treenode)[i]->fulsteps = (bitptr)Malloc(words * sizeof(long));
disc.c:    (*treenode)[i]->empsteps = (bitptr)Malloc(words * sizeof(long));
disc.c:      p->fulstte1 = (bitptr)Malloc(words * sizeof(long));
disc.c:      p->fulstte0 = (bitptr)Malloc(words * sizeof(long));
disc.c:      p->empstte1 = (bitptr)Malloc(words * sizeof(long));
disc.c:      p->empstte0 = (bitptr)Malloc(words * sizeof(long));
disc.c:      p->fulsteps = (bitptr)Malloc(words * sizeof(long));
disc.c:      p->empsteps = (bitptr)Malloc(words * sizeof(long));
disc.c:      p->next = q;
disc.c:    p->next->next->next = p;
disc.c:    treenode[i-1]->back = NULL;
disc.c:    treenode[i-1]->tip = (i <= spp);
disc.c:    treenode[i-1]->index = i;
disc.c:      p = treenode[i-1]->next;
disc.c:      while (p != treenode[i-1])
disc.c:        p->back = NULL;
disc.c:        p->tip = false;
disc.c:        p->index = i;
disc.c:        p = p->next;
disc.c:    treenode[i-1]->back = NULL;
disc.c:    treenode[i-1]->tip = (i <= spp);
disc.c:    treenode[i-1]->index = i;
disc.c:      p = treenode[i-1]->next;
disc.c:      while (p != treenode[i-1])
disc.c:        p->back = NULL;
disc.c:        p->tip = false;
disc.c:        p->index = i;
disc.c:        p = p->next;
disc.c:      exxit(-1);
disc.c:    if (ancone[i-1] && anczero[i-1])
disc.c:    else if (ancone[i-1])
disc.c:  if (below != treenode[below->index - 1])
disc.c:    below = treenode[below->index - 1];
disc.c:  if (below->back != NULL)
disc.c:    below->back->back = newfork;
disc.c:  newfork->back = below->back;
disc.c:  below->back = newfork->next->next;
disc.c:  newfork->next->next->back = below;
disc.c:  newfork->next->back = newtip;
disc.c:  newtip->back = newfork->next;
disc.c:  if (below != treenode[below->index - 1])
disc.c:    below = treenode[below->index - 1];
disc.c:  if (below->back != NULL)
disc.c:    below->back->back = newfork;
disc.c:  newfork->back = below->back;
disc.c:  rtdesc->back = newfork->next->next;
disc.c:  newfork->next->next->back = rtdesc;
disc.c:  newfork->next->back = leftdesc;
disc.c:  leftdesc->back = newfork->next;
disc.c:  (*root)->back = NULL;
disc.c:  if (below != treenode[below->index - 1])
disc.c:    below = treenode[below->index - 1];
disc.c:  if (below->back != NULL)
disc.c:    below->back->back = newfork;
disc.c:  newfork->back = below->back;
disc.c:  below->back = newfork->next->next;
disc.c:  newfork->next->next->back = below;
disc.c:  newfork->next->back = newtip;
disc.c:  newtip->back = newfork->next;
disc.c:  (*root)->back = NULL;
disc.c:    p->visited = false;
disc.c:    p = p->back;
disc.c:    if (p != NULL) p = treenode[p->index - 1];
disc.c:  if ((*item)->back == NULL)
disc.c:  *forknode = treenode[(*item)->back->index - 1];
disc.c:    if (*item == (*forknode)->next->back)
disc.c:      *root = (*forknode)->next->next->back;
disc.c:      *root = (*forknode)->next->back;
disc.c:  p = (*item)->back->next->back;
disc.c:  q = (*item)->back->next->next->back;
disc.c:    p->back = q;
disc.c:    q->back = p;
disc.c:  (*forknode)->back = NULL;
disc.c:  p = (*forknode)->next;
disc.c:    p->back = NULL;
disc.c:    p = p->next;
disc.c:  (*item)->back = NULL;
disc.c:  if ((*item)->back == NULL)
disc.c:  *forknode = treenode[(*item)->back->index - 1];
disc.c:  if (*item == (*forknode)->next->back)
disc.c:      *root = (*forknode)->next->next->back;
disc.c:      *root = (*forknode)->next->back;
disc.c:  p = (*item)->back->next->back;
disc.c:  q = (*item)->back->next->next->back;
disc.c:    p->back = q;
disc.c:    q->back = p;
disc.c:  (*forknode)->back = NULL;
disc.c:  p = (*forknode)->next;
disc.c:    p->back = NULL;
disc.c:    p = p->next;
disc.c:  (*item)->back = NULL;
disc.c:  if ((*item)->back == NULL)
disc.c:  *forknode = treenode[(*item)->back->index - 1];
disc.c:    if (*item == (*forknode)->next->back)
disc.c:      *root = (*forknode)->next->next->back;
disc.c:      *root = (*forknode)->next->back;
disc.c:  p = (*item)->back->next->back;
disc.c:  q = (*item)->back->next->next->back;
disc.c:    p->back = q;
disc.c:    q->back = p;
disc.c:  q = (*forknode)->back;
disc.c:  (*forknode)->back = NULL;
disc.c:  p = (*forknode)->next;
disc.c:    p->back = NULL;
disc.c:    p = p->next;
disc.c:  (*item)->back = NULL;
disc.c:    q = treenode[q->index - 1];
disc.c:    q-> visited = false;
disc.c:    q = q->back;
disc.c:    if (q != NULL) q = treenode[q->index - 1];
disc.c:  if (p->tip)
disc.c:    p->xcoord = 0;
disc.c:    p->ycoord = *tipy;
disc.c:    p->ymin = *tipy;
disc.c:    p->ymax = *tipy;
disc.c:  q = p->next;
disc.c:    coordinates(q->back, tipy, f, fartemp);
disc.c:    q = q->next;
disc.c:  first = p->next->back;
disc.c:  q = p->next;
disc.c:  while (q->next != p)
disc.c:    q = q->next;
disc.c:  last = q->back;
disc.c:  p->xcoord = (last->ymax - first->ymin) * f;
disc.c:  p->ycoord = (first->ycoord + last->ycoord) / 2;
disc.c:  p->ymin = first->ymin;
disc.c:  p->ymax = last->ymax;
disc.c:  if (p->xcoord > *fartemp)
disc.c:    *fartemp = p->xcoord;
disc.c:  if (p->tip)
disc.c:    p->xcoord = 0;
disc.c:    p->ycoord = *tipy;
disc.c:    p->ymin = *tipy;
disc.c:    p->ymax = *tipy;
disc.c:  q = p->next;
disc.c:    coordinates2(q->back, tipy);
disc.c:    q = q->next;
disc.c:  first = p->next->back;
disc.c:  q = p->next;
disc.c:  while (q->next != p)
disc.c:    q = q->next;
disc.c:  last = q->back;
disc.c:  p->xcoord = last->ymax - first->ymin;
disc.c:  p->ycoord = (first->ycoord + last->ycoord) / 2;
disc.c:  p->ymin = first->ymin;
disc.c:  p->ymax = last->ymax;
disc.c:  if (p->tip)
disc.c:      if (nayme[p->index - 1][i - 1] != ' ')
disc.c:      c = nayme[p->index - 1][i];
disc.c:    q = p->next;
disc.c:      treeout(q->back, nextree, col, root);
disc.c:      q = q->next;
disc.c:    fprintf(outtree, "[%6.4f];\n", 1.0 / (nextree - 1));
disc.c:  if (p->tip)
disc.c:      if (nayme[p->index - 1][i - 1] != ' ')
disc.c:      c = nayme[p->index - 1][i];
disc.c:    treeout2(p->next->back, col, root);
disc.c:    treeout2(p->next->next->back, col, root);
disc.c:    fprintf(outtree, "[%6.4f];\n", 1.0 / (nextree - 1));
disc.c:{  /* paired sites tests (KHT or SH) on user-defined trees */
disc.c:    printf("TOO MANY USER-DEFINED TREES");
disc.c:      fprintf(outfile, "Kishino-Hasegawa-Templeton test\n\n");
disc.c:        fprintf(outfile, "%3ld%10.1f", which, nsteps[which - 1]);
disc.c:          fprintf(outfile, "  <------ best\n");
disc.c:              temp = fsteps[which - 1][i] - fsteps[minwhich - 1][i];
disc.c:          sd = sqrt(sumw / (sumw - 1.0) * (sum2 - temp * temp));
disc.c:                  (nsteps[which - 1] - minsteps) / 10, sd);
disc.c:    {           /* Shimodaira-Hasegawa test using normal approximation */
disc.c:        fprintf(outfile, "Shimodaira-Hasegawa test on first %d of %ld trees\n\n", MAXSHIMOTREES, numtrees);
disc.c:        fprintf(outfile, "Shimodaira-Hasegawa test\n\n");
disc.c:              temp = temp + weight[k]*(fsteps[i][k]/-sum)
disc.c:                *(fsteps[j][k]/-sum2);
disc.c:      for (i = 0; i < numtrees; i++)    /* in-place Cholesky decomposition of trees x trees covariance matrix */
disc.c:        for (j = 0; j <= i-1; j++)
disc.c:        if (covar[i][i]-sum <= 0.0)
disc.c:          temp = sqrt(covar[i][i] - sum);
disc.c:          if (fabs(temp) < 1.0E-12)
disc.c:            covar[j][i] = (covar[j][i] - sum)/temp;
disc.c:          if (nsteps[j]-sum2 <= f[j] - sum)
disc.c:        if ((minwhich-1) == i)
disc.c:          fprintf(outfile, "  <------ best\n");
disc.c:          fprintf(outfile, "  %9.1f %10.3f", nsteps[i]-sum2, P[i]);
disc.c:  fprintf(outfile, "\n     *--------------------\n");
disc.c:        fprintf(outfile, " %c", guess[i * 10 + j - 1]);
disc.c:    *garbage = (*garbage)->next;
disc.c:    free(p->bits_);
disc.c:  /* this is a do-it-yourself garbage collectors for move
disc.c:    *grbg = (*grbg)->next;
disc.c:    (*p)->bits_ = (bitptr)Malloc(words * sizeof(long));
disc.c:  (*p)->next       = NULL;
disc.c:  /* collect garbage on p -- put it on front of garbage list */
disc.c:  p->next = *grbg;
discrete.c:/* Version 4.0. (c) Copyright 1993-2013 by the University of Washington.
discrete.c:  t->nuview = discretepars_tree_nuview;
discrete.c:  t->evaluate = discretepars_tree_evaluate;
discrete.c:  ((pars_tree*)t)->branchcollapsible = discretepars_tree_branchcollapsible;
discrete.c:  node->free = discretepars_node_free;
discrete.c:  n->discbase = (discbaseptr)Malloc(endsite * sizeof(unsigned char));
discrete.c:  n->discnumnuc = (discnucarray *)Malloc(endsite * sizeof(discnucarray));
discrete.c:    headings(chars, "Sequences", "---------");
discrete.c:    /* eat white space -- if the separator line has spaces on it*/
discrete.c:        initname(i - 1);
discrete.c:          if ((strchr("!\"#$%&'()*+,-./0123456789:;<=>?@\
discrete.c:            exxit(-1);
discrete.c:          inputSequences[i - 1][j - 1] = charstate;
discrete.c:        exxit(-1);
discrete.c:    for (i = 1; i <= ((chars - 1) / 60 + 1); i++)
discrete.c:          putc(nayme[j - 1][k], outfile);
discrete.c:        for (k = (i - 1) * 60 + 1; k <= l; k++)
discrete.c:          if (dotdiff && (j > 1 && inputSequences[j - 1][k - 1] == inputSequences[0][k - 1]))
discrete.c:            charstate = inputSequences[j - 1][k - 1];
discrete.c:      if ((nsymbol == 0) && (inputSequences[j - 1][i - 1] != '?'))
discrete.c:        convtab[0][i-1] = inputSequences[j-1][i-1];
discrete.c:      else if (inputSequences[j - 1][i - 1] != '?')
discrete.c:          if (convtab[k - 1][i - 1] == inputSequences[j - 1][i - 1])
discrete.c:          convtab[nsymbol-1][i - 1] = inputSequences[j - 1][i - 1];
discrete.c:        if (inputSequences[j - 1][i - 1] != '?')
discrete.c:          inputSequences[j - 1][i - 1] = (Char)('0' + (convsymboli - 1));
discrete.c:        exxit(-1);
discrete.c:      j = i - gap;
discrete.c:        jj = alias[j - 1];
discrete.c:        jg = alias[j + gap - 1];
discrete.c:          flip = (inputSequences[k - 1][jj - 1] > inputSequences[k - 1][jg - 1]);
discrete.c:          tied = (tied && inputSequences[k - 1][jj - 1] == inputSequences[k - 1][jg - 1]);
discrete.c:        itemp = alias[j - 1];
discrete.c:        alias[j - 1] = alias[j + gap - 1];
discrete.c:        alias[j + gap - 1] = itemp;
discrete.c:        itemp = weight[j - 1];
discrete.c:        weight[j - 1] = weight[j + gap - 1];
discrete.c:        weight[j + gap - 1] = itemp;
discrete.c:        j -= gap;
discrete.c:                inputSequences[k - 1][alias[i - 1] - 1] == inputSequences[k - 1][alias[j - 1] - 1]);
discrete.c:        weight[i - 1] += weight[j - 1];
discrete.c:        weight[j - 1] = 0;
discrete.c:        ally[alias[j - 1] - 1] = alias[i - 1];
discrete.c:    i = j - 1;
discrete.c:    if (ally[alias[i - 1] - 1] != alias[i - 1])
discrete.c:          found = (ally[alias[j - 1] - 1] == alias[j - 1]);
discrete.c:          j--;
discrete.c:          itemp = alias[i - 1];
discrete.c:          alias[i - 1] = alias[j - 1];
discrete.c:          alias[j - 1] = itemp;
discrete.c:          itemp = weight[i - 1];
discrete.c:          weight[i - 1] = weight[j - 1];
discrete.c:          weight[j - 1] = itemp;
discrete.c:      switch (inputSequences[i][alias[j] - 1])
discrete.c:      ((discretepars_node*)t->nodep[i])->discbase[j] = ns;
discrete.c:      ((pars_node*)t->nodep[i])->numsteps[j] = 0;
discrete.c:  if (!Vars.r->tip)
discrete.c:    memset(((discretepars_node*)Vars.r)->discnumnuc, 0, endsite * sizeof(discnucarray));
discrete.c:  for (i = b1 - 1; i < b2; i++)
discrete.c:    j = location[ally[i] - 1];
discrete.c:    Vars.anc = Vars.hypset[j - 1];
discrete.c:    if (!Vars.r->tip)
discrete.c:      p = Vars.r->next;
discrete.c:          ((discretepars_node*)Vars.r)->discnumnuc[j - 1][k]++;
discrete.c:          if (((discretepars_node*)p->back)->discbase[j - 1] & (1 << k))
discrete.c:            ((discretepars_node*)Vars.r)->discnumnuc[j - 1][k]++;
discrete.c:        p = p->next;
discrete.c:        discgetlargest(((discretepars_node*)Vars.r)->discnumnuc[j - 1]);
discrete.c:        if (((discretepars_node*)Vars.r)->discnumnuc[j - 1][k] == largest)
discrete.c:      ((discretepars_node*)Vars.r)->discbase[j - 1] = Vars.tempset;
discrete.c:      Vars.anc = ((discretepars_node*)t->nodep[Vars.r->back->index - 1]) ->discbase[j - 1];
discrete.c:    Vars.nonzero = (Vars.nonzero || (((discretepars_node*)Vars.r)->discbase[j - 1] & Vars.anc) == 0);
discrete.c:    Vars.maybe = (Vars.maybe || ((discretepars_node*)Vars.r)->discbase[j - 1] != Vars.anc);
discrete.c:  if (!Vars.r->tip)
discrete.c:    memcpy(tempnuc, ((discretepars_node*)Vars.r)->discnumnuc, endsite * sizeof(discnucarray));
discrete.c:    q = Vars.r->next;
discrete.c:      memcpy(((discretepars_node*)Vars.r)->discnumnuc, tempnuc, endsite * sizeof(discnucarray));
discrete.c:      for (i = b1 - 1; i < b2; i++)
discrete.c:        j = location[ally[i] - 1];
discrete.c:          if (((discretepars_node*)q->back)->discbase[j - 1] & (1 << k))
discrete.c:            ((discretepars_node*)Vars.r)->discnumnuc[j - 1][k]--;
discrete.c:        largest = discgetlargest(((discretepars_node*)Vars.r)->
discrete.c:                                 discnumnuc[j - 1]);
discrete.c:        ancset[j - 1] = 0;
discrete.c:          if (((discretepars_node*)Vars.r)->discnumnuc[j - 1][k] == largest)
discrete.c:            ancset[j - 1] |= (1 << k);
discrete.c:          Vars.anc = ancset[j - 1];
discrete.c:      dischyptrav(t, q->back, ancset, b1, b2, Vars.bottom);
discrete.c:      q = q->next;
discrete.c:  for (i = 1; i <= ((chars - 1) / 40 + 1); i++)
discrete.c:    dischyptrav(t, t->root, nothing, i * 40 - 39, n, true);
discrete.c:  if (p->tip)
discrete.c:  q = p->next;
discrete.c:    if (q->back)
discrete.c:      memcpy(((discretepars_node*)q)->discnumnuc,
discrete.c:             ((discretepars_node*)p)->discnumnuc, endsite * sizeof(discnucarray));
discrete.c:        if (((discretepars_node*)q->back)->discbase[sitei - 1] & (1 << i))
discrete.c:          ((discretepars_node*)q)->discnumnuc[sitei - 1][i]--;
discrete.c:      if (p->back)
discrete.c:          if (((discretepars_node*)p->back)->discbase[sitei - 1] & (1 << i))
discrete.c:            ((discretepars_node*)q)->discnumnuc[sitei - 1][i]++;
discrete.c:      largest = discgetlargest(((discretepars_node*)q)->discnumnuc[sitei - 1]);
discrete.c:      ((discretepars_node*)q)->discbase[sitei - 1] = 0;
discrete.c:        if (((discretepars_node*)q)->discnumnuc[sitei - 1][i] == largest)
discrete.c:          ((discretepars_node*)q)->discbase[sitei - 1] |= (1 << i);
discrete.c:    q = q->next;
discrete.c:  q = p->next;
discrete.c:    discinitbase(q->back, sitei);
discrete.c:    q = q->next;
discrete.c:  if (p->tip)
discrete.c:    p->initialized = true;
discrete.c:  q = p->next;
discrete.c:    inittreetrav(q->back, sitei);
discrete.c:    q = q->next;
discrete.c:  p->initialized = false;
discrete.c:  q = p->next;
discrete.c:    q->initialized = false;
discrete.c:    q = q->next;
discrete.c:  /* traverses an n-ary tree, computing minimum steps at each node */
discrete.c:  if (p->tip)
discrete.c:  q = p->next;
discrete.c:    if (q->back)
discrete.c:      minpostorder(q->back, treenode);
discrete.c:    q = q->next;
discrete.c:  if (!p->initialized)
discrete.c:    q = p->next;
discrete.c:      if (q->back)
discrete.c:        disccompmin(p, q->back);
discrete.c:      q = q->next;
discrete.c:  if (subtr1->tip)
discrete.c:  if (subtr1->index == outgrno)
discrete.c:      if (((discretepars_node*)subtr1)->disccumlengths[i] != -1 &&
discrete.c:          (((discretepars_node*)subtr2)->disccumlengths[j] != -1))
discrete.c:        if (((discretepars_node*)subtr1)->disccumlengths[i] + cost +
discrete.c:            ((discretepars_node*)subtr2)->disccumlengths[j] < minn)
discrete.c:          minn = ((discretepars_node*)subtr1)->disccumlengths[i] + cost +
discrete.c:            ((discretepars_node*)subtr2)->disccumlengths[j];
discrete.c:        if (((discretepars_node*)subtr1)->disccumlengths[i] + cost +
discrete.c:            ((discretepars_node*)subtr2)->disccumlengths[j] == minn)
discrete.c:          nom += ((discretepars_node*)subtr1)->discnumreconst[i] *
discrete.c:            ((discretepars_node*)subtr2)->discnumreconst[j] * cost;
discrete.c:          denom += ((discretepars_node*)subtr1)->discnumreconst[i] *
discrete.c:            ((discretepars_node*)subtr2)->discnumreconst[j];
discrete.c:  if (p->tip)
discrete.c:  if (p->index == outgrno)
discrete.c:    p = p->back;
discrete.c:  q = p->next;
discrete.c:    if (q->back)
discrete.c:      branchlength(q, q->back, brlen, treenode);
discrete.c:      q->v += (weight[sitei - 1]  * (*brlen));
discrete.c:      q->back->v += (weight[sitei - 1] * (*brlen));
discrete.c:      if (!q->back->tip)
discrete.c:        branchlentrav(q->back, root, sitei, chars, brlen, treenode);
discrete.c:    q = q->next;
discrete.c:  if (p->tip)
discrete.c:      if (nayme[p->index - 1][i - 1] != ' ')
discrete.c:      c = nayme[p->index - 1][i];
discrete.c:    q = p->next;
discrete.c:      treeout(q->back, nextree, col, root);
discrete.c:      q = q->next;
discrete.c:    fprintf(outtree, "[%6.4f];\n", 1.0 / (nextree - 1));
discrete.c:    fprintf(outfile, "Kishino-Hasegawa-Templeton test\n\n");
discrete.c:      fprintf(outfile, "%3ld%10.1f", which, nsteps[which - 1] / 10);
discrete.c:        fprintf(outfile, "  <------ best\n");
discrete.c:            temp = (fsteps[which - 1][i] - fsteps[minwhich - 1][i]);
discrete.c:        sd = sqrt(sumw / (sumw - 1.0) * (sum2 - sum * sum / sumw));
discrete.c:                (nsteps[which - 1] - minsteps) / 10, sd);
discrete.c:  {           /* Shimodaira-Hasegawa test using normal approximation */
discrete.c:      fprintf(outfile, "Shimodaira-Hasegawa test on first %d of %ld trees\n\n" , MAXSHIMOTREES, numtrees);
discrete.c:      fprintf(outfile, "Shimodaira-Hasegawa test\n\n");
discrete.c:            temp = temp + wt*(fsteps[i][k]/(wt)-sum) *(fsteps[j][k]/(wt)-sum2);
discrete.c:    for (i = 0; i < numtrees; i++)      /* in-place Cholesky decomposition of trees x trees covariance matrix */
discrete.c:      for (j = 0; j <= i-1; j++)
discrete.c:        temp = sqrt(covar[i][i] - sum);
discrete.c:        if (fabs(temp) < 1.0E-23)
discrete.c:          covar[j][i] = (covar[j][i] - sum)/temp;
discrete.c:        if (nsteps[j]-sum2 < f[j] - sum)
discrete.c:      if ((minwhich-1) == i)
discrete.c:        fprintf(outfile, "  <------ best\n");
discrete.c:        fprintf(outfile, "  %9.1f %10.3f", nsteps[i]-sum2, P[i]);
discrete.c:      p->disccumlengths[i] = 0;
discrete.c:      p->discnumreconst[i] = 1;
discrete.c:      if (p->discbase[sitei - 1] & (1 << i))
discrete.c:        p->disccumlengths[i] = 0;
discrete.c:        p->discnumreconst[i] = 1;
discrete.c:        p->disccumlengths[i] = -1;
discrete.c:        p->discnumreconst[i] = 0;
discrete.c:  if (htrav->bottom)
discrete.c:    fprintf(outfile, "%4ld   ", htrav->r->back->index - spp);
discrete.c:  if (htrav->r->tip)
discrete.c:      putc(nayme[htrav->r->index - 1][i], outfile);
discrete.c:    fprintf(outfile, "%4ld      ", htrav->r->index - spp);
discrete.c:  if (htrav->bottom)
discrete.c:  else if (htrav->nonzero)
discrete.c:  else if (htrav->maybe)
discrete.c:    j = location[ally[i - 1] - 1];
discrete.c:    htrav->tempset = ((discretepars_node*)htrav->r)->discbase[j - 1];
discrete.c:    htrav->anc = htrav->hypset[j - 1];
discrete.c:    if (!htrav->bottom)
discrete.c:      htrav->anc = ((discretepars_node*)t->nodep[htrav->r->back->index - 1]) ->discbase[j - 1];
discrete.c:    dot = dotdiff && (htrav->tempset == htrav->anc && !htrav->bottom);
discrete.c:        if (htrav->tempset == (1 << k))
discrete.c:          putc(convtab[k][i - 1], outfile);
discrete.c:      if (((discretepars_node*)desc)->disccumlengths[j] == -1)
discrete.c:        desclen = ((discretepars_node*)desc)->disccumlengths[j];
discrete.c:        descrecon += ((discretepars_node*)desc)->discnumreconst[j];
discrete.c:    ((discretepars_node*)p)->disccumlengths[i] += minn;
discrete.c:    ((discretepars_node*)p)->discnumreconst[i] *= descrecon;
discrete.c:  p->initialized = true;
discrete.c:    for ( q = p->next ; q != p ; q = q->next )
discrete.c:      qback = (discretepars_node*)q->back;
discrete.c:      base1 = qback->discbase[i];
discrete.c:      steps += ((pars_node*)qback)->numsteps[i];
discrete.c:          for ( q = p->next ; q != p ; q = q->next )
discrete.c:            qback = (discretepars_node*) q->back;
discrete.c:            if ( qback->discbase[i] & (1 << j) )
discrete.c:        steps += (weight[i]) * (count_sibs(p) - largest - root);
discrete.c:        newbase = ((discretepars_node*)p->next->back)->discbase[i] |
discrete.c:          ((discretepars_node*)p->next->next->back)->discbase[i];
discrete.c:    ((discretepars_node*)p)->discbase[i] = newbase;
discrete.c:    ((pars_node*)p)->numsteps[i] = steps;
discrete.c:  p->initialized = true;
discrete.c:  discretepars_node* q = (discretepars_node*)n->back;
discrete.c:    steps = ((pars_node*)p)->numsteps[i] + ((pars_node*)q)->numsteps[i];
discrete.c:    base1 = p->discbase[i];
discrete.c:    base2 = q->discbase[i];
discrete.c:    if ( ((pars_tree*)t)->supplement)
discrete.c:      steps += ((pars_tree*)t)->supplement(t, i);
discrete.c:      fsteps[which - 1][i] = term;
discrete.c:    nsteps[which - 1] = sum;
discrete.c:  t->score = -sum;
discrete.c:  return t->score;
discrete.c:  if ( n->tip == true || n->back->tip == true )
discrete.c:  q = n->back;
discrete.c:  if ( q->initialized == false ) t->nuview(t, q);
discrete.c:  if ( n->initialized == false ) t->nuview(t, n);
discrete.c:    if ( (((discretepars_node*)q)->discbase[i] &
discrete.c:          ((discretepars_node*)n)->discbase[i] ) == 0)
dist.c:/* Version 4.0. (c) Copyright 1993-2013 by the University of Washington.
dist.c:  n->free = dist_node_free;
dist.c:  n->copy = dist_node_copy;
dist.c:  n->init = dist_node_init;
dist.c:  dn->dist = 0;
dist.c:  dn->d = (vector)Malloc(nonodes * sizeof(double));
dist.c:  dn->w = (vector)Malloc(nonodes * sizeof(double));
dist.c:  free(n->d);
dist.c:  free(n->w);
dist.c:  dst->dist = src->dist;
dist.c:  memcpy(dst->d, src->d, nonodes * sizeof(double));
dist.c:  memcpy(dst->w, src->w, nonodes * sizeof(double));
dist.c:  dst->sametime = src->sametime;
dist.c:  dst->t = src->t;
dist.c:      p->next = q;
dist.c:    p->next->next->next = p;
dist.c:    (*treenode)[i]->free(&(*treenode)[i]);
dist.c:    q = p->next;
dist.c:      q = q->next;
dist.c:      r->free(&r);
dist.c:    p->free(&p);
dist.c:    dtreenode[i]->d = (vector)Malloc(nonodes * sizeof(double));
dist.c:      p->d = (vector)Malloc(nonodes * sizeof(double));
dist.c:      p = (dist_node*)(p->node.next);
dist.c:    free(dtreenode[i]->d);
dist.c:      free(((dist_node*)p)->d);
dist.c:      p = (dist_node*)(p->node.next);
dist.c:    dtreenode[i]->w = (vector)Malloc(nonodes * sizeof(double));
dist.c:      p->w = (vector)Malloc(nonodes * sizeof(double));
dist.c:      p = (dist_node*)p->node.next;
dist.c:    free(dtreenode[i]->w);
dist.c:      free(p->w);
dist.c:      p = (dist_node*)p->node.next;
dist.c:    a->nodep[i - 1]->back = NULL;
dist.c:    a->nodep[i - 1]->iter = true;
dist.c:    ((dist_node*)a->nodep[i - 1])->t = 0.0;
dist.c:    ((dist_node*)a->nodep[i - 1])->sametime = false;
dist.c:    a->nodep[i - 1]->v = 0.0;
dist.c:      p = a->nodep[i-1]->next;
dist.c:      while (p != a->nodep[i-1]) {
dist.c:        p->back = NULL;
dist.c:        p->iter = true;
dist.c:        ((dist_node*)p)->t = 0.0;
dist.c:        ((dist_node*)p)->sametime = false;
dist.c:        p = p->next;
dist.c:  a->score = -1.0;
dist.c:  a->root = a->nodep[0];
dist.c:    fprintf(outfile, "\n----                       ---------");
dist.c:      fprintf(outfile, "-------------");
dist.c:          exxit(-1);
dist.c:            exxit(-1);
dist.c:        exxit(-1);
dist.c:      if ((j < i) && (fabs(x[i][j]-x[j][i]) > 0.000000001)) {
dist.c:        exxit(-1);
dist.c:      fprintf(outfile, "%10.5f", x[i][j - 1]);
dist.c:        fprintf(outfile, " (%3ld)", reps[i][j - 1]);
dist.c:  if (p->tip) {
dist.c:    p->xcoord = (long)(over * lengthsum + 0.5);
dist.c:    p->ycoord = *tipy;
dist.c:    p->ymin = *tipy;
dist.c:    p->ymax = *tipy;
dist.c:  q = p->next;
dist.c:    if (q->back)
dist.c:      coordinates(q->back, lengthsum + q->v, tipy, tipmax, start);
dist.c:    q = q->next;
dist.c:  } while ((p == start || p != q) && (p != start || p->next != q));
dist.c:  first = p->next->back;
dist.c:  while (q->next != p && q->next->back)  /* is this right ? */
dist.c:    q = q->next;
dist.c:  last = q->back;
dist.c:  p->xcoord = (long)(over * lengthsum + 0.5);
dist.c:    if ( p->back != NULL ) nover++;
dist.c:      p->ycoord = (first->ycoord + last->ycoord) / 2;
dist.c:        q = q->next;
dist.c:        nover--;
dist.c:      p->ycoord = q->back->ycoord;
dist.c:    p->ycoord = (first->ycoord + last->ycoord) / 2;
dist.c:  p->ymin = first->ymin;
dist.c:  p->ymax = last->ymax;
dist.c:  if (i == (long)p->ycoord && p == start) {  /* display the root */
dist.c:      if (p->index - spp >= 10)
dist.c:        fprintf(outfile, "-");
dist.c:        fprintf(outfile, "--");
dist.c:      if (p->index - spp >= 10)
dist.c:    if (p->index - spp >= 10)
dist.c:      fprintf(outfile, "%2ld", p->index - spp);
dist.c:      fprintf(outfile, "%ld", p->index - spp);
dist.c:    if (!p->tip) { /* internal nodes */
dist.c:      r = p->next;
dist.c:      /* r->back here is going to the same node. */
dist.c:        if (!r->back) {
dist.c:          r = r->next;
dist.c:        if (i >= r->back->ymin && i <= r->back->ymax) {
dist.c:          q = r->back;
dist.c:        r = r->next;
dist.c:      } while (!((p != start && r == p) || (p == start && r == p->next)));
dist.c:      first = p->next->back;
dist.c:      while (r->next != p)
dist.c:        r = r->next;
dist.c:      last = r->back;
dist.c:        last = p->back;
dist.c:    done = (p->tip || p == q);
dist.c:    n = (long)(scale * (q->xcoord - p->xcoord) + 0.5);
dist.c:    if (!q->tip) {
dist.c:      if ((n < 3) && (q->index - spp >= 10))
dist.c:      if ((n < 2) && (q->index - spp < 10))
dist.c:      n--;
dist.c:    if ((long)q->ycoord == i && !done) {
dist.c:      if (p->ycoord != q->ycoord)
dist.c:      if (!q->tip) {
dist.c:        for (j = 1; j <= n - 2; j++)
dist.c:          putc('-', outfile);
dist.c:        if (q->index - spp >= 10)
dist.c:          fprintf(outfile, "%2ld", q->index - spp);
dist.c:          fprintf(outfile, "-%ld", q->index - spp);
dist.c:          putc('-', outfile);
dist.c:    } else if (!p->tip) {
dist.c:      if ((long)last->ycoord > i && (long)first->ycoord < i
dist.c:          && i != (long)p->ycoord) {
dist.c:  if ((long)p->ycoord == i && p->tip) {
dist.c:      putc(nayme[p->index - 1][j], outfile);
dist.c:  for (i = 1; i <= (tipy - down); i++)
dist.c:  if (p->tip) {
dist.c:      if (nayme[p->index - 1][i - 1] != ' ')
dist.c:      c = nayme[p->index - 1][i];
dist.c:    treeoutr(p->next->back, col, curtree);
dist.c:    treeoutr(p->next->next->back, col, curtree);
dist.c:  x = p->v;
dist.c:    w = (long)(0.43429448222 * log(-x)) + 1;
dist.c:  if (p == curtree->root)
dist.c:  if (p->tip) {
dist.c:      if (nayme[p->index - 1][i - 1] != ' ')
dist.c:      c = nayme[p->index - 1][i];
dist.c:    treeout(p->next->back, col, m, njoin, start);
dist.c:    treeout(p->next->next->back, col, m, njoin, start);
dist.c:      treeout(p->back, col, m, njoin, start);
dist.c:  x = p->v;
dist.c:    w = (long)(m * log(-x)) + 1;
dnacomp.c:/* Version 4.0. (c) Copyright 1993-2013 by the University of Washington.
dnacomp.c:  t->evaluate = dnacomp_tree_evaluate;
dnacomp.c:    bestrees[i - 1].btree = (long *)Malloc(nonodes * sizeof(long));
dnacomp.c:  place = (long *)Malloc((2*spp-1) * sizeof(long));
dnacomp.c:    alias[i - 1] = i;
dnacomp.c:    oldweight[i - 1] = weight[i - 1];
dnacomp.c:    ally[i - 1] = i;
dnacomp.c:    if (ally[i - 1] == i)
dnacomp.c:    location[alias[i - 1] - 1] = i;
dnacomp.c:  in_tree[n - 1] = true;
dnacomp.c:    l = -1;
dnacomp.c:        if (in_tree[i - 1] && ((dnapars_node*)curtree->nodep[i - 1])->base[j]
dnacomp.c:          if ((((dnapars_node*)curtree->nodep[i - 1])->base[j] & s) == 0)
dnacomp.c:      if (in_tree[i] && ((dnapars_node*)curtree->nodep[i])->base[j] == 0)
dnacomp.c:    steps = ((pars_node*)r)->numsteps[i] + ((pars_node*)r->back)->numsteps[i];
dnacomp.c:    if ( (((dnapars_node*)r)->base[i] & ((dnapars_node*)r->back)->base[i] )
dnacomp.c:      fsteps[which - 1][i] = term;
dnacomp.c:    nsteps[which - 1] = sum;
dnacomp.c:  t->score = like;
dnacomp.c:    fprintf(outfile, "\n     *----------\n");
dnacomp.c:          if (((pars_node*)curtree->root)->numsteps
dnacomp.c:              [location[ally[k - 1] - 1] - 1] ==
dnacomp.c:              necsteps[location[ally[k - 1] - 1] - 1])
dnacomp.c:            if (oldweight[k - 1] > 0)
dnacomp.c:            if (oldweight[k - 1] > 0)
dnacomp.c:    treeout(curtree->root, nextree, &col, curtree->root);
dnacomp.c:  if (p->tip)
dnacomp.c:    names[p->index - 1] = true;
dnacomp.c:  q = p->next;
dnacomp.c:    initboolnames(q->back, names);
dnacomp.c:    q = q->next;
dnacomp.c:{  /* do paired sites test (KHT or SH) on user-defined trees */
dnacomp.c:    fprintf(outfile, "Kishino-Hasegawa-Templeton test\n\n");
dnacomp.c:      fprintf(outfile, "%3ld  %11.1f", which, nsteps[which - 1]);
dnacomp.c:        fprintf(outfile, "  <------ best\n");
dnacomp.c:            temp = (fsteps[maxwhich - 1][i] - fsteps[which - 1][i]);
dnacomp.c:        sd = sqrt(sumw / (sumw - 1.0) * (sum2 - sum * sum /sumw));
dnacomp.c:                (maxsteps-nsteps[which - 1]), sd);
dnacomp.c:  {           /* Shimodaira-Hasegawa test using normal approximation */
dnacomp.c:      fprintf(outfile, "Shimodaira-Hasegawa test on first %d of %ld trees\n\n", MAXSHIMOTREES, numtrees);
dnacomp.c:      fprintf(outfile, "Shimodaira-Hasegawa test\n\n");
dnacomp.c:            temp = temp + (fsteps[i][k]- wt * sum)
dnacomp.c:              * (fsteps[j][k]- wt * sum2) / wt;
dnacomp.c:    for (i = 0; i < numtrees; i++)      /* in-place Cholesky decomposition of trees x trees covariance matrix */
dnacomp.c:      for (j = 0; j <= i-1; j++)
dnacomp.c:        temp = sqrt(covar[i][i] - sum);
dnacomp.c:        if (fabs(temp) < 1.0E-12)
dnacomp.c:          covar[j][i] = (covar[j][i] - sum)/temp;
dnacomp.c:        if (sum2-nsteps[j] <= sum-f[j])
dnacomp.c:      if ((maxwhich-1) == i)
dnacomp.c:        fprintf(outfile, "  <------ best\n");
dnacomp.c:        fprintf(outfile, " %10.1f  %10.3f", sum2-nsteps[i], P[i]);
dnacomp.c:      enterorder[i - 1] = i;
dnacomp.c:    curtree->root = curtree->nodep[enterorder[0] - 1];
dnacomp.c:      bestyet = -350.0 * spp * chars;
dnacomp.c:      item = curtree->nodep[enterorder[i - 1] - 1];
dnacomp.c:      there = curtree->root;
dnacomp.c:      curtree->addtraverse(curtree, item, curtree->root, true, &there, &bestyet, NULL, NULL, 0, &multf);
dnacomp.c:      curtree->insert_(curtree, item, there, recompute, multf);
dnacomp.c:      curtree->locrearrange(curtree, curtree->nodep[enterorder[0]-1], false, NULL, NULL);
dnacomp.c:        writename(i - 1, 1, enterorder);
dnacomp.c:              sprintf(progbuf, "-");
dnacomp.c:        curtree->globrearrange(curtree, progress, false);
dnacomp.c:    for (i = spp - 1; i >= 1; i--)
dnacomp.c:      curtree->re_move(curtree, curtree->nodep[i], &dummy, recompute);
dnacomp.c:          fprintf(outfile, "%6ld trees in all found\n", nextree - 1);
dnacomp.c:      for (i = 0; i <= (nextree - 2); i++)
dnacomp.c:        curtree->evaluate(curtree, curtree->root, 0);
dnacomp.c:        curtree->root = root_tree(curtree, curtree->root);
dnacomp.c:        curtree->nodep[curtree->root->index - 1] = curtree->root;
dnacomp.c:        reroot_tree(curtree, curtree->root); // RSGbugfix: Name change.
dnacomp.c:    /* Open in binary: ftell() is broken for UNIX line-endings under WIN32 */
dnacomp.c:      fprintf(outfile, "User-defined tree");
dnacomp.c:      fsteps[j - 1] = (long *)Malloc(endsite * sizeof(long));
dnacomp.c:      treeread(curtree, intree, &curtree->root, curtree->nodep, &goteof, &firsttree, &nextnode, &haslengths, initparsnode, false, nonodes);
dnacomp.c:      initboolnames(curtree->root, names);
dnacomp.c:      reroot_tree(curtree, curtree->root); // RSGbugfix: Name change.
dnacomp.c:      curtree->evaluate(curtree, curtree->root, false);
dnacomp.c:      curtree->root = root_tree(curtree, curtree->root);
dnacomp.c:        reroot(curtree->nodep[outgrno - 1], curtree->root);
dnacomp.c:      free(fsteps[j - 1]);
dnadist.c: * (c) Copyright 1993-2013 by the University of Washington.  Written by Joseph
dnadist.c:boolean dotdiff         = true;         /* use dot-difference format */
dnadist.c:sitelike **x;    /* array of sitelike [0..spp-1][0..endsite-1] */
dnadist.c:        str = "Kimura 2-parameter";
dnadist.c:        str = "Jukes-Cantor";
dnadist.c:    printf("  D  Distance (F84, Kimura, Jukes-Cantor, LogDet)?  %s\n", str);
dnadist.c:        str = "Lower-triangular";
dnadist.c:        str = "Human-readable";
dnadist.c:        /* square(machine-readable) -> lower-triangular -> square(human-readable) */
dnadist.c:    category[i] = ch - '0';
dnadist.c:    fprintf(outfile, "%ld", category[i - 1]);
dnadist.c:             " with Jukes-Cantor, Kimura or logdet distances\n");
dnadist.c:      exxit(-1);
dnadist.c:      j = i - gap;
dnadist.c:        jj = alias[j - 1];
dnadist.c:        jg = alias[j + gap - 1];
dnadist.c:        // RSGnote: BUG - "tied" referenced here before being initialized.
dnadist.c:        flip = (oldweight[jj - 1] < oldweight[jg - 1] || (tied && category[jj - 1] > category[jg - 1]));
dnadist.c:        tied = (category[jj - 1] == category[jg - 1]);
dnadist.c:          flip = (inputSequences[k - 1][jj - 1] > inputSequences[k - 1][jg - 1]);
dnadist.c:          tied = (tied && inputSequences[k - 1][jj - 1] == inputSequences[k - 1][jg - 1]);
dnadist.c:        itemp = alias[j - 1];
dnadist.c:        alias[j - 1] = alias[j + gap - 1];
dnadist.c:        alias[j + gap - 1] = itemp;
dnadist.c:        j -= gap;
dnadist.c:      tied = (category[alias[i - 1] - 1] == category[alias[j - 1] - 1]);
dnadist.c:                inputSequences[k - 1][alias[i - 1] - 1] == inputSequences[k - 1][alias[j - 1] - 1]);
dnadist.c:      ally[alias[j - 1] - 1] = alias[i - 1];
dnadist.c:    if (ally[alias[i - 1] - 1] != alias[i - 1]) {
dnadist.c:          found = (ally[alias[j - 1] - 1] == alias[j - 1]);
dnadist.c:          j--;
dnadist.c:          itemp = alias[i - 1];
dnadist.c:          alias[i - 1] = alias[j - 1];
dnadist.c:          alias[j - 1] = itemp;
dnadist.c:    alias[i - 1] = i;
dnadist.c:    ally[i - 1] = i;
dnadist.c:    weight[i - 1] = 0;
dnadist.c:    location[i - 1] = 0;
dnadist.c:    if (ally[i - 1] == i)
dnadist.c:    location[alias[i - 1] - 1] = i;
dnadist.c:    sumrates += oldweight[i] * rate[category[i] - 1];
dnadist.c:      weight[location[ally[i] - 1] - 1] += oldweight[i];
dnadist.c:      sitealias = alias[site] - 1;
dnadist.c:      if ( strchr("AMRWDHVNX?O-", basechar) ) { /* A bases */
dnadist.c:      if ( strchr("CMYSBHVNX?O-", basechar) ) { /* C bases */
dnadist.c:      if ( strchr("GKRSBDVNX?O-", basechar) ) { /* G bases */
dnadist.c:      if ( strchr("TUKYWBDHNX?O-", basechar) ) { /* T bases */
dnadist.c:  /*Gauss-Jordan reduction -- invert matrix a in place,
dnadist.c:          a[j][k] -= temp * a[i][k];
dnadist.c:  xp = x[m-1];
dnadist.c:  xq = x[n-1];
dnadist.c:    if((strchr("NX?O-", inputSequences[m-1][i]) == NULL) &&
dnadist.c:       (strchr("NX?O-", inputSequences[n-1][i]) == NULL))
dnadist.c:           "%ld and %ld; -1.0 was written.\n", m, n );
dnadist.c:    return -1.0;
dnadist.c:      printf("  -1.0 WAS WRITTEN\n");
dnadist.c:      return -1.0;
dnadist.c:        num2 += (long)(weight[i] * (sumyr - sum));
dnadist.c:    tt = ((1.0 - (double)num1 / denominator)-invarfrac)/(1.0-invarfrac);
dnadist.c:          p1 = exp(-tt);
dnadist.c:          p2 = exp(-xv * tt) - exp(-tt);
dnadist.c:          p3 = 1.0 - exp(-xv * tt);
dnadist.c:          p1 = exp(-cvi * log(1 + tt / cvi));
dnadist.c:          p2 = exp(-cvi * log(1 + xv * tt / cvi))
dnadist.c:              - exp(-cvi * log(1 + tt / cvi));
dnadist.c:          p3 = 1.0 - exp(-cvi * log(1 + xv * tt / cvi));
dnadist.c:        q1 = q1 * (1.0-invarfrac) + invarfrac;
dnadist.c:        q2 *= (1.0 - invarfrac);
dnadist.c:        q3 *= (1.0 - invarfrac);
dnadist.c:          slope = 0.5 * exp(-tt) * (num2 / q2 - num1 / q1) +
dnadist.c:                  0.25 * xv * exp(-xv * tt) *
dnadist.c:                 ((denominator - num1 - num2) * 2 / q3 - num2 / q2 - num1 / q1);
dnadist.c:          slope = 0.5 * (1 / (1 + tt / cvi)) * exp(-cvi * log(1 + tt / cvi)) *
dnadist.c:                  (num2 / q2 - num1 / q1) + 0.25 * (xv / (1 + xv * tt / cvi)) *
dnadist.c:                    exp(-cvi * log(1 + xv * tt / cvi)) *
dnadist.c:                 ((denominator - num1 - num2) * 2 / q3 - num2 / q2 - num1 / q1);
dnadist.c:        slope *= (1.0-invarfrac);
dnadist.c:          delta = fabs(delta) / -2.0;
dnadist.c:      printf("  -1.0 WAS WRITTEN\n");
dnadist.c:      return -1.0;
dnadist.c:      printf("  -1.0 WAS WRITTEN\n");
dnadist.c:      return -1.0;
dnadist.c:              && (4 * (((double)numerator / denominator) - invarfrac)
dnadist.c:                  <= (1.0 - invarfrac))) {
dnadist.c:      printf("  -1.0 WAS WRITTEN\n");
dnadist.c:      return -1.0;
dnadist.c:        vv = -0.75 * log((4.0*((double)numerator / denominator) - 1.0) / 3.0);
dnadist.c:        vv = 0.75 * cvi * (exp(-(1/cvi)*
dnadist.c:                               log((4.0 * ((double)numerator / denominator) - 1.0) / 3.0)) - 1.0);
dnadist.c:        vv = 0.75 * cvi * (exp(-(1/cvi)*
dnadist.c:                               log((4.0 * ((double)numerator / denominator - invarfrac)/
dnadist.c:                                    (1.0-invarfrac) - 1.0) / 3.0)) - 1.0);
dnadist.c:      printf("  -1.0 was written.\n");
dnadist.c:      return -1.0;
dnadist.c:        printf("  -1.0 WAS WRITTEN\n");
dnadist.c:        return -1.0;
dnadist.c:      vv = -0.25*(vv - 0.5*(log(basefreq1[0])+log(basefreq1[1])
dnadist.c:    /* For F84 and multi-category Jukes, similarity, and Kimura */
dnadist.c:        lz = -tt;
dnadist.c:            tbl[i].z1 = exp(-cvi*log(1.0-tbl[i].ratxv * lz/cvi));
dnadist.c:            tbl[i].z1zz = exp(-cvi*log(1.0-tbl[i].rat * lz/cvi));
dnadist.c:          tbl[i].y1 = 1.0 - tbl[i].z1;
dnadist.c:          tbl[i].z1yy = tbl[i].z1 - tbl[i].z1zz;
dnadist.c:          idx = category[alias[i] - 1];
dnadist.c:            slope += weightrat[i] * (tbl[idx - 1].z1zz * (bb - aa) +
dnadist.c:                                     tbl[idx - 1].z1xv * (cc - bb)) /
dnadist.c:                         (aa * tbl[idx - 1].z1zz + bb * tbl[idx - 1].z1yy +
dnadist.c:                          cc * tbl[idx - 1].y1);
dnadist.c:            slope += (1.0-invarfrac) * weightrat[i] * (
dnadist.c:                    ((tbl[idx-1].rat)/(1.0-tbl[idx-1].rat * lz/cvi))
dnadist.c:                       * tbl[idx - 1].z1zz * (bb - aa) +
dnadist.c:                    ((tbl[idx-1].ratxv)/(1.0-tbl[idx-1].ratxv * lz/cvi))
dnadist.c:                       * tbl[idx - 1].z1 * (cc - bb)) /
dnadist.c:                (aa * ((1.0-invarfrac)*tbl[idx - 1].z1zz + invarfrac)
dnadist.c:                  + bb * (1.0-invarfrac)*tbl[idx - 1].z1yy
dnadist.c:                  + cc * (1.0-invarfrac)*tbl[idx - 1].y1);
dnadist.c:        delta = fabs(delta) / -2.0;
dnadist.c:      printf("  -1.0 WAS WRITTEN\n");
dnadist.c:      return -1.0;
dnadist.c:    weightrat[i] = weight[i] * rate[category[alias[i] - 1] - 1];
dnadist.c:        sprintf(progbuf, "%c", nayme[i - 1][j]);
dnadist.c:      d[i - 1][j - 1] = v;
dnadist.c:      d[j - 1][i - 1] = v;
dnadist.c:        sprintf(progbuf, "%c", nayme[spp - 1][j]);
dnadist.c:      fprintf(outfile, "  Jukes-Cantor Distance\n");
dnadist.c:      fprintf(outfile, "  Kimura 2-parameter Distance\n");
dnadist.c:        fprintf(outfile, "%12ld%13.3f\n", i, rate[i - 1]);
dnadist.c:  ///boolean dotdiff         = true;         /* use dot-difference format */
dnainvar.c:/* Version 4.0. (c) Copyright 1993-2013 by the University of Washington.
dnainvar.c:#define maxsp           4   /* maximum number of species -- must be 4 */
dnainvar.c:long f[(long)ww - (long)xx + 1][(long)ww - (long)xx + 1]
dnainvar.c:       [(long)ww - (long)xx + 1]; /* made global from being local to makeinv */
dnainvar.c:      printf("  .  Use dot-differencing to display them  %s\n",
dnainvar.c:    exxit(-1);
dnainvar.c:        tied = (tied && inputSequences[k - 1][alias[i - 1] - 1] == inputSequences[k - 1][alias[j - 1] - 1]);
dnainvar.c:      if (tied && aliasweight[j - 1] > 0)
dnainvar.c:        aliasweight[i - 1] += aliasweight[j - 1];
dnainvar.c:        aliasweight[j - 1] = 0;
dnainvar.c:    i = j - 1;
dnainvar.c:    alias[i - 1] = i;
dnainvar.c:    aliasweight[i - 1] = weight[i - 1];
dnainvar.c:    weight[i - 1] = aliasweight[i - 1];
dnainvar.c:    if (weight[i - 1] > 0)
dnainvar.c:      putc(inputSequences[j][alias[i] - 1], outfile);
dnainvar.c:  simbol t[maxsp - 1];
dnainvar.c:        f[(long)s1 - (long)xx][(long)s2 - (long)xx]
dnainvar.c:          [(long)s3 - (long)xx] = 0;
dnainvar.c:      ch = inputSequences[j][alias[i] - 1];
dnainvar.c:    ch1 = inputSequences[0][alias[i] - 1];
dnainvar.c:        ch = inputSequences[j - 1][alias[i] - 1];
dnainvar.c:          t[j - 2] = xx;
dnainvar.c:          t[j - 2] = yy;
dnainvar.c:          t[j - 2] = zz;
dnainvar.c:          t[j - 2] = zz;
dnainvar.c:          t[j - 2] = ww;
dnainvar.c:      f[(long)t[0] - (long)xx][(long)t[1] - (long)xx]
dnainvar.c:        [(long)t[2] - (long)xx] += weight[i];
dnainvar.c:        if (f[(long)s1 - (long)xx][(long)s2 - (long)xx]
dnainvar.c:            [(long)s3 - (long)xx] > 0) {
dnainvar.c:                    f[(long)s1 - (long)xx][(long)s2 - (long)xx]
dnainvar.c:                    [(long)s3 - (long)xx]);
dnainvar.c:  /* make quadratic invariant, table, chi-square */
dnainvar.c:    fprintf(outfile, "   Quadratic invariant = %15.1f\n\n", (*nr) * (*pr) - (*mr) * (*qr));
dnainvar.c:  fprintf(outfile, "   Chi-square = ");
dnainvar.c:  TEMP = (*mr) * (*qr) - (*nr) * (*pr);
dnainvar.c:  while (nayme[m - 1][n - 1] == ' ')
dnainvar.c:    n--;
dnainvar.c:    putc(nayme[m - 1][i], outfile);
dnainvar.c:    p = p * (m + n - i + 1) / i;
dnainvar.c:  fprintf(outfile, "  of each expression using a one-sided exact binomial test.\n");
dnainvar.c:  m = f[(long)yy - (long)xx][(long)zz - (long)xx]
dnainvar.c:      [(long)ww - (long)xx] + f[0][(long)zz - (long)xx]
dnainvar.c:      [(long)zz - (long)xx];
dnainvar.c:  n = f[(long)yy - (long)xx][(long)zz - (long)xx]
dnainvar.c:      [(long)zz - (long)xx] + f[0][(long)zz - (long)xx]
dnainvar.c:      [(long)ww - (long)xx];
dnainvar.c:  fprintf(outfile, "   I  %5ld    - %5ld   = %5ld", m, n, m - n);
dnainvar.c:  m = f[(long)zz - (long)xx][(long)yy - (long)xx]
dnainvar.c:      [(long)ww - (long)xx] + f[(long)zz - (long)xx][0]
dnainvar.c:      [(long)zz - (long)xx];
dnainvar.c:  n = f[(long)zz - (long)xx][(long)yy - (long)xx]
dnainvar.c:      [(long)zz - (long)xx] + f[(long)zz - (long)xx][0]
dnainvar.c:      [(long)ww - (long)xx];
dnainvar.c:  fprintf(outfile, "   II %5ld    - %5ld   = %5ld", m, n, m - n);
dnainvar.c:  m = f[(long)zz - (long)xx][(long)ww - (long)xx]
dnainvar.c:      [(long)yy - (long)xx] + f[(long)zz - (long)xx]
dnainvar.c:      [(long)zz - (long)xx][0];
dnainvar.c:  n = f[(long)zz - (long)xx][(long)zz - (long)xx]
dnainvar.c:      [(long)yy - (long)xx] + f[(long)zz - (long)xx]
dnainvar.c:      [(long)ww - (long)xx][0];
dnainvar.c:  fprintf(outfile, "   III%5ld    - %5ld   = %5ld", m, n, m - n);
dnainvar.c:  fprintf(outfile, "  chi-square, for the correct tree topology)\n");
dnainvar.c:  m = f[0][0][0] + f[0][(long)yy - (long)xx]
dnainvar.c:      [(long)yy - (long)xx] + f[0][(long)zz - (long)xx]
dnainvar.c:      [(long)zz - (long)xx];
dnainvar.c:  n = f[0][0][(long)yy - (long)xx] + f[0][0]
dnainvar.c:      [(long)zz - (long)xx] + f[0][(long)yy - (long)xx][0] + f[0]
dnainvar.c:      [(long)yy - (long)xx][(long)zz - (long)xx] + f[0]
dnainvar.c:      [(long)zz - (long)xx][0] + f[0][(long)zz - (long)xx]
dnainvar.c:      [(long)yy - (long)xx] + f[0][(long)zz - (long)xx]
dnainvar.c:      [(long)ww - (long)xx];
dnainvar.c:  p = f[(long)yy - (long)xx][0][0] + f[(long)yy - (long)xx]
dnainvar.c:      [(long)yy - (long)xx]
dnainvar.c:      [(long)yy - (long)xx] + f[(long)yy - (long)xx]
dnainvar.c:      [(long)zz - (long)xx]
dnainvar.c:      [(long)zz - (long)xx] + f[(long)zz - (long)xx][0]
dnainvar.c:      [0] + f[(long)zz - (long)xx][(long)yy - (long)xx]
dnainvar.c:      [(long)yy - (long)xx] + f[(long)zz - (long)xx]
dnainvar.c:      [(long)zz - (long)xx]
dnainvar.c:      [(long)zz - (long)xx] + f[(long)zz - (long)xx]
dnainvar.c:      [(long)ww - (long)xx][(long)ww - (long)xx];
dnainvar.c:  q = f[(long)yy - (long)xx][0][(long)yy - (long)xx] +
dnainvar.c:      f[(long)yy - (long)xx][0][(long)zz - (long)xx] +
dnainvar.c:      f[(long)yy - (long)xx][(long)yy - (long)xx][0] +
dnainvar.c:      f[(long)yy - (long)xx][(long)yy - (long)xx][(long)zz - (long)xx] +
dnainvar.c:      f[(long)yy - (long)xx][(long)zz - (long)xx][0] +
dnainvar.c:      f[(long)yy - (long)xx][(long)zz - (long)xx][(long)yy - (long)xx] +
dnainvar.c:      f[(long)yy - (long)xx][(long)zz - (long)xx][(long)ww - (long)xx] +
dnainvar.c:      f[(long)zz - (long)xx][0][(long)yy - (long)xx] +
dnainvar.c:      f[(long)zz - (long)xx][0][(long)zz - (long)xx] +
dnainvar.c:      f[(long)zz - (long)xx][0][(long)ww - (long)xx] +
dnainvar.c:      f[(long)zz - (long)xx][(long)yy - (long)xx][0] +
dnainvar.c:      f[(long)zz - (long)xx][(long)yy - (long)xx][(long)zz - (long)xx] +
dnainvar.c:      f[(long)zz - (long)xx][(long)yy - (long)xx][(long)ww - (long)xx] +
dnainvar.c:      f[(long)zz - (long)xx][(long)zz - (long)xx][0] +
dnainvar.c:      f[(long)zz - (long)xx][(long)zz - (long)xx][(long)yy - (long)xx] +
dnainvar.c:      f[(long)zz - (long)xx][(long)zz - (long)xx][(long)ww - (long)xx] +
dnainvar.c:      f[(long)zz - (long)xx][(long)ww - (long)xx][0] +
dnainvar.c:      f[(long)zz - (long)xx][(long)ww - (long)xx][(long)yy - (long)xx] +
dnainvar.c:      f[(long)zz - (long)xx][(long)ww - (long)xx][(long)zz - (long)xx];
dnainvar.c:  L1 = nr * pr - mr * qr;
dnainvar.c:  m = f[0][0][0] + f[(long)yy - (long)xx][0]
dnainvar.c:      [(long)yy - (long)xx] + f[(long)zz - (long)xx][0]
dnainvar.c:      [(long)zz - (long)xx];
dnainvar.c:  n = f[0][0][(long)yy - (long)xx] + f[0][0]
dnainvar.c:      [(long)zz - (long)xx] + f[(long)yy - (long)xx][0]
dnainvar.c:      [0] + f[(long)yy - (long)xx][0]
dnainvar.c:      [(long)zz - (long)xx] + f[(long)zz - (long)xx][0]
dnainvar.c:      [0] + f[(long)zz - (long)xx][0]
dnainvar.c:      [(long)yy - (long)xx] + f[(long)zz - (long)xx][0]
dnainvar.c:      [(long)ww - (long)xx];
dnainvar.c:  p = f[0][(long)yy - (long)xx][0] + f[(long)yy - (long)xx]
dnainvar.c:      [(long)yy - (long)xx]
dnainvar.c:      [(long)yy - (long)xx] + f[(long)zz - (long)xx]
dnainvar.c:      [(long)yy - (long)xx][(long)zz - (long)xx] + f[0]
dnainvar.c:      [(long)zz - (long)xx][0] + f[(long)yy - (long)xx]
dnainvar.c:      [(long)zz - (long)xx]
dnainvar.c:      [(long)yy - (long)xx] + f[(long)zz - (long)xx]
dnainvar.c:      [(long)zz - (long)xx]
dnainvar.c:      [(long)zz - (long)xx] + f[(long)zz - (long)xx]
dnainvar.c:      [(long)ww - (long)xx][(long)zz - (long)xx];
dnainvar.c:  q = f[0][(long)yy - (long)xx][(long)yy - (long)xx] + f[0]
dnainvar.c:      [(long)yy - (long)xx][(long)zz - (long)xx] +
dnainvar.c:      f[(long)yy - (long)xx][(long)yy - (long)xx][0] +
dnainvar.c:      f[(long)yy - (long)xx][(long)yy - (long)xx][(long)zz - (long)xx] +
dnainvar.c:      f[(long)zz - (long)xx][(long)yy - (long)xx][0] +
dnainvar.c:      f[(long)zz - (long)xx][(long)yy - (long)xx][(long)yy - (long)xx] +
dnainvar.c:      f[(long)zz - (long)xx][(long)yy - (long)xx][(long)ww - (long)xx] +
dnainvar.c:      f[0][(long)zz - (long)xx][(long)yy - (long)xx] + f[0]
dnainvar.c:      [(long)zz - (long)xx][(long)zz - (long)xx] + f[0]
dnainvar.c:      [(long)zz - (long)xx][(long)ww - (long)xx] +
dnainvar.c:      f[(long)yy - (long)xx][(long)zz - (long)xx][0] +
dnainvar.c:      f[(long)yy - (long)xx][(long)zz - (long)xx][(long)zz - (long)xx] +
dnainvar.c:      f[(long)yy - (long)xx][(long)zz - (long)xx][(long)ww - (long)xx] +
dnainvar.c:      f[(long)zz - (long)xx][(long)zz - (long)xx][0] +
dnainvar.c:      f[(long)zz - (long)xx][(long)zz - (long)xx][(long)yy - (long)xx] +
dnainvar.c:      f[(long)zz - (long)xx][(long)zz - (long)xx][(long)ww - (long)xx] +
dnainvar.c:      f[(long)zz - (long)xx][(long)ww - (long)xx][0] +
dnainvar.c:      f[(long)zz - (long)xx][(long)ww - (long)xx][(long)yy - (long)xx] +
dnainvar.c:      f[(long)zz - (long)xx][(long)ww - (long)xx][(long)ww - (long)xx];
dnainvar.c:  L2 = nr * pr - mr * qr;
dnainvar.c:  m = f[0][0][0] + f[(long)yy - (long)xx][(long)yy - (long)xx]
dnainvar.c:      [0] + f[(long)zz - (long)xx][(long)zz - (long)xx][0];
dnainvar.c:  n = f[(long)yy - (long)xx][0][0] + f[(long)zz - (long)xx][0]
dnainvar.c:      [0] + f[0][(long)yy - (long)xx][0] + f[(long)zz - (long)xx]
dnainvar.c:      [(long)yy - (long)xx][0] + f[0][(long)zz - (long)xx]
dnainvar.c:      [0] + f[(long)yy - (long)xx][(long)zz - (long)xx]
dnainvar.c:      [0] + f[(long)zz - (long)xx][(long)ww - (long)xx][0];
dnainvar.c:  p = f[0][0][(long)yy - (long)xx] + f[(long)yy - (long)xx]
dnainvar.c:      [(long)yy - (long)xx]
dnainvar.c:      [(long)yy - (long)xx] + f[(long)zz - (long)xx]
dnainvar.c:      [(long)zz - (long)xx][(long)yy - (long)xx] + f[0][0]
dnainvar.c:      [(long)zz - (long)xx] + f[(long)yy - (long)xx]
dnainvar.c:      [(long)yy - (long)xx]
dnainvar.c:      [(long)zz - (long)xx] + f[(long)zz - (long)xx]
dnainvar.c:      [(long)zz - (long)xx]
dnainvar.c:      [(long)zz - (long)xx] + f[(long)zz - (long)xx]
dnainvar.c:      [(long)zz - (long)xx][(long)ww - (long)xx];
dnainvar.c:  q = f[(long)yy - (long)xx][0][(long)yy - (long)xx] + f[(long)zz - (long)xx]
dnainvar.c:      [0][(long)yy - (long)xx] + f[0][(long)yy - (long)xx][(long)yy - (long)xx] +
dnainvar.c:      f[(long)zz - (long)xx][(long)yy - (long)xx][(long)yy - (long)xx] +
dnainvar.c:      f[0][(long)zz - (long)xx]
dnainvar.c:      [(long)yy - (long)xx] + f[(long)yy - (long)xx][(long)zz - (long)xx]
dnainvar.c:      [(long)yy - (long)xx] + f[(long)zz - (long)xx][(long)ww - (long)xx]
dnainvar.c:      [(long)yy - (long)xx] + f[(long)yy - (long)xx][0]
dnainvar.c:      [(long)zz - (long)xx] + f[(long)zz - (long)xx][0]
dnainvar.c:      [(long)zz - (long)xx] + f[0][(long)zz - (long)xx]
dnainvar.c:      [(long)ww - (long)xx] + f[0][(long)yy - (long)xx]
dnainvar.c:      [(long)zz - (long)xx] + f[(long)zz - (long)xx]
dnainvar.c:      [(long)yy - (long)xx]
dnainvar.c:      [(long)zz - (long)xx] + f[(long)zz - (long)xx]
dnainvar.c:      [(long)yy - (long)xx][(long)ww - (long)xx] + f[0]
dnainvar.c:      [(long)zz - (long)xx]
dnainvar.c:      [(long)zz - (long)xx] + f[(long)yy - (long)xx]
dnainvar.c:      [(long)zz - (long)xx]
dnainvar.c:      [(long)zz - (long)xx] + f[(long)zz - (long)xx]
dnainvar.c:      [(long)ww - (long)xx]
dnainvar.c:      [(long)ww - (long)xx] + f[(long)zz - (long)xx][0]
dnainvar.c:      [(long)ww - (long)xx] + f[(long)yy - (long)xx]
dnainvar.c:      [(long)zz - (long)xx][(long)ww - (long)xx] +
dnainvar.c:      f[(long)zz - (long)xx][(long)ww - (long)xx][(long)zz - (long)xx];
dnainvar.c:  L3 = nr * pr - mr * qr;
dnainvar.c:  fprintf(outfile, "  Tree I:   %15.1f\n", L2 - L3);
dnainvar.c:  fprintf(outfile, "  Tree II:  %15.1f\n", L3 - L1);
dnainvar.c:  fprintf(outfile, "  Tree III: %15.1f\n\n", L1 - L2);
dnaml.c:/* Version 4.0. (c) Copyright 1993-2013 by the University of Washington.
dnaml.c:  t->evaluate = dnaml_tree_evaluate;
dnaml.c:  t->try_insert_ = ml_tree_try_insert_;
dnaml.c:  t->nuview = dnaml_tree_nuview;
dnaml.c:  ((ml_tree*)t)->makenewv = dnaml_tree_makenewv;
dnaml.c:          printf("  user-defined HMM of rates\n");
dnaml.c:            printf("\nSitewise user-assigned categories:\n\n");
dnaml.c:        initgammacat(rcategs-1, alpha, rrate, probcat);
dnaml.c:        for (i = 0; i < rcategs-1; i++)
dnaml.c:          probcat[i] = probcat[i]*(1.0-invarfrac);
dnaml.c:        probcat[rcategs-1] = invarfrac;
dnaml.c:        rrate[rcategs-1] = 0.0;
dnaml.c:     location[i-1] ends up as the position in the lexicographic order
dnaml.c:     others that are tied with it.  Otherwise location[i-1] is 0
dnaml.c:    alias[i - 1] = i;
dnaml.c:    ally[i - 1] = i;
dnaml.c:    aliasweight[i - 1] = weight[i - 1];
dnaml.c:    location[i - 1] = 0;
dnaml.c:    if (ally[i - 1] == i)
dnaml.c:    location[alias[i - 1] - 1] = i;
dnaml.c:  makevalues2(rcategs, curtree->nodep, endsite, spp, inputSequences, alias);
dnaml.c:    empiricalfreqs(&freqa, &freqc, &freqg, &freqt, aliasweight, curtree->nodep);
dnaml.c:      free (tbl[i][j]->ww);
dnaml.c:      free (tbl[i][j]->zz);
dnaml.c:      free (tbl[i][j]->wwzz);
dnaml.c:      free (tbl[i][j]->vvzz);
dnaml.c:      /* Then allocate for worst-case multifurcations */
dnaml.c:      tbl[i][j]->ww   = (double *) Malloc(num_comma * sizeof (double));
dnaml.c:      tbl[i][j]->zz   = (double *) Malloc(num_comma * sizeof (double));
dnaml.c:      tbl[i][j]->wwzz = (double *) Malloc(num_comma * sizeof (double));
dnaml.c:      tbl[i][j]->vvzz = (double *) Malloc(num_comma * sizeof (double));
dnaml.c:      free(tbl[i][j]->ww);
dnaml.c:      free(tbl[i][j]->zz);
dnaml.c:      free(tbl[i][j]->wwzz);
dnaml.c:      free(tbl[i][j]->vvzz);
dnaml.c:      tbl[i][j]->rat = rrate[i]*rate[j];
dnaml.c:      tbl[i][j]->ratxi = tbl[i][j]->rat * xi;
dnaml.c:      tbl[i][j]->ratxv = tbl[i][j]->rat * xv;
dnaml.c:      tbl[i][j]->ww   = (double *) Malloc(2 * sizeof (double));
dnaml.c:      tbl[i][j]->zz   = (double *) Malloc(2 * sizeof (double));
dnaml.c:      tbl[i][j]->wwzz = (double *) Malloc(2 * sizeof (double));
dnaml.c:      tbl[i][j]->vvzz = (double *) Malloc(2 * sizeof (double));
dnaml.c:          * tbl[j][category[alias[i] - 1] - 1]->rat;
dnaml.c:        tbl[i][j]->rat /= sumrates;
dnaml.c:        tbl[i][j]->ratxi /= sumrates;
dnaml.c:        tbl[i][j]->ratxv /= sumrates;
dnaml.c:  q = p->back;
dnaml.c:  y = p->v;
dnaml.c:  lz = -y;
dnaml.c:      tbl[i][j]->orig_zz = exp(tbl[i][j]->ratxi * lz);
dnaml.c:      tbl[i][j]->z1 = exp(tbl[i][j]->ratxv * lz);
dnaml.c:      tbl[i][j]->z1zz = tbl[i][j]->z1 * tbl[i][j]->orig_zz;
dnaml.c:      tbl[i][j]->z1yy = tbl[i][j]->z1 - tbl[i][j]->z1zz;
dnaml.c:    k = category[alias[i]-1] - 1;
dnaml.c:        y1 = 1.0 - tbl[j][k]->z1;
dnaml.c:        z1zz = tbl[j][k]->z1zz;
dnaml.c:        z1yy = tbl[j][k]->z1yy;
dnaml.c:      memcpy(x1, ((dna_node*)p)->x[i][j], sizeof(sitelike));
dnaml.c:      prod1 = freqa * x1[0] + freqc * x1[(long)C - (long)A] +
dnaml.c:        freqg * x1[(long)G - (long)A] + freqt * x1[(long)T - (long)A];
dnaml.c:      memcpy(x2, ((dna_node*)q)->x[i][j], sizeof(sitelike));
dnaml.c:      prod2 = freqa * x2[0] + freqc * x2[(long)C - (long)A] +
dnaml.c:        freqg * x2[(long)G - (long)A] + freqt * x2[(long)T - (long)A];
dnaml.c:      prod3 = (x1[0] * freqa + x1[(long)G - (long)A] * freqg) *
dnaml.c:        (x2[0] * freqar + x2[(long)G - (long)A] * freqgr) +
dnaml.c:        (x1[(long)C - (long)A] * freqc + x1[(long)T - (long)A] * freqt) *
dnaml.c:        (x2[(long)C - (long)A] * freqcy + x2[(long)T - (long)A] * freqty);
dnaml.c:        freqc * x1[(long)C - (long)A] * x2[(long)C - (long)A] +
dnaml.c:        freqg * x1[(long)G - (long)A] * x2[(long)G - (long)A] +
dnaml.c:        freqt * x1[(long)T - (long)A] * x2[(long)T - (long)A];
dnaml.c:    lterm = log(sumterm) + ((ml_node*)p)->underflows[i] + ((ml_node*)q)->underflows[i];
dnaml.c:      l0gf[which - 1][i] = lterm;
dnaml.c:    if ((ally[i] > 0) && (location[ally[i]-1] > 0))
dnaml.c:      lai = location[ally[i] - 1];
dnaml.c:      memcpy(clai, contribution[lai - 1], rcategs * sizeof(double));
dnaml.c:        nulike[j] = ((1.0 - lambda) * like[j] + sumc) * clai[j];
dnaml.c:        nulike[j] = ((1.0 - lambda) * like[j] + sumc);
dnaml.c:  ((tree*)t)->score = sum;
dnaml.c:    l0gl[which - 1] = sum;
dnaml.c:  local_nvd->yy     = (double *) Malloc(num_sibs * sizeof (double));
dnaml.c:  local_nvd->wwzz   = (double *) Malloc(num_sibs * sizeof (double));
dnaml.c:  local_nvd->vvzz   = (double *) Malloc(num_sibs * sizeof (double));
dnaml.c:  local_nvd->vzsumr = (double *) Malloc(num_sibs * sizeof (double));
dnaml.c:  local_nvd->vzsumy = (double *) Malloc(num_sibs * sizeof (double));
dnaml.c:  local_nvd->sum    = (double *) Malloc(num_sibs * sizeof (double));
dnaml.c:  local_nvd->sumr   = (double *) Malloc(num_sibs * sizeof (double));
dnaml.c:  local_nvd->sumy   = (double *) Malloc(num_sibs * sizeof (double));
dnaml.c:  local_nvd->xx     = (sitelike *) Malloc(num_sibs * sizeof (sitelike));
dnaml.c:  free (local_nvd->yy);
dnaml.c:  free (local_nvd->wwzz);
dnaml.c:  free (local_nvd->vvzz);
dnaml.c:  free (local_nvd->vzsumr);
dnaml.c:  free (local_nvd->vzsumy);
dnaml.c:  free (local_nvd->sum);
dnaml.c:  free (local_nvd->sumr);
dnaml.c:  free (local_nvd->sumy);
dnaml.c:  free (local_nvd->xx);
dnaml.c:    sib_ptr      = sib_ptr->next;
dnaml.c:    sib_back_ptr = sib_ptr->back;
dnaml.c:    lw = - (sib_back_ptr->v);
dnaml.c:        tbl[i][j]->ww[sib_index]   = exp(tbl[i][j]->ratxi * lw);
dnaml.c:        tbl[i][j]->zz[sib_index]   = exp(tbl[i][j]->ratxv * lw);
dnaml.c:        tbl[i][j]->wwzz[sib_index] = tbl[i][j]->ww[sib_index] *
dnaml.c:          tbl[i][j]->zz[sib_index];
dnaml.c:        tbl[i][j]->vvzz[sib_index] = (1.0 - tbl[i][j]->ww[sib_index]) *
dnaml.c:          tbl[i][j]->zz[sib_index];
dnaml.c:    k = category[alias[i]-1] - 1;
dnaml.c:        sib_ptr         = sib_ptr->next;
dnaml.c:        sib_back_ptr    = sib_ptr->back;
dnaml.c:          correction += ((ml_node*)sib_back_ptr)->underflows[i];
dnaml.c:        local_nvd->wwzz[sib_index] = tbl[j][k]->wwzz[sib_index];
dnaml.c:        local_nvd->vvzz[sib_index] = tbl[j][k]->vvzz[sib_index];
dnaml.c:        local_nvd->yy[sib_index]   = 1.0 - tbl[j][k]->zz[sib_index];
dnaml.c:        memcpy(local_nvd->xx[sib_index], ((dna_node*)sib_back_ptr)->x[i][j], sizeof(sitelike));
dnaml.c:        local_nvd->sum[sib_index] =
dnaml.c:          local_nvd->yy[sib_index] *
dnaml.c:          (freqa * local_nvd->xx[sib_index][(long)A] +
dnaml.c:           freqc * local_nvd->xx[sib_index][(long)C] +
dnaml.c:           freqg * local_nvd->xx[sib_index][(long)G] +
dnaml.c:           freqt * local_nvd->xx[sib_index][(long)T]);
dnaml.c:        local_nvd->sumr[sib_index] = freqar * local_nvd->xx[sib_index][(long)A] + freqgr * local_nvd->xx[sib_index][(long)G];
dnaml.c:        local_nvd->sumy[sib_index] = freqcy * local_nvd->xx[sib_index][(long)C] + freqty * local_nvd->xx[sib_index][(long)T];
dnaml.c:        local_nvd->vzsumr[sib_index] = local_nvd->vvzz[sib_index] * local_nvd->sumr[sib_index];
dnaml.c:        local_nvd->vzsumy[sib_index] = local_nvd->vvzz[sib_index] * local_nvd->sumy[sib_index];
dnaml.c:          local_nvd->sum[sib_index] +
dnaml.c:          local_nvd->wwzz[sib_index] *
dnaml.c:          local_nvd->xx[sib_index][(long)A] +
dnaml.c:          local_nvd->vzsumr[sib_index];
dnaml.c:          local_nvd->sum[sib_index] +
dnaml.c:          local_nvd->wwzz[sib_index] *
dnaml.c:          local_nvd->xx[sib_index][(long)C] +
dnaml.c:          local_nvd->vzsumy[sib_index];
dnaml.c:          local_nvd->sum[sib_index] +
dnaml.c:          local_nvd->wwzz[sib_index] *
dnaml.c:          local_nvd->xx[sib_index][(long)G] +
dnaml.c:          local_nvd->vzsumr[sib_index];
dnaml.c:          local_nvd->sum[sib_index] +
dnaml.c:          local_nvd->wwzz[sib_index] *
dnaml.c:          local_nvd->xx[sib_index][(long)T] +
dnaml.c:          local_nvd->vzsumy[sib_index];
dnaml.c:      for ( l = 0 ; l < ((long)T - (long)A + 1); l++ )
dnaml.c:      memcpy(((dna_node*)p)->x[i][j], p_xx, sizeof(sitelike));
dnaml.c:    ((ml_node*)p)->underflows[i] = 0;
dnaml.c:    ((ml_node*)p)->underflows[i] += correction;
dnaml.c:  p->initialized = true;
dnaml.c:  q = p->back;
dnaml.c:  lz = -y;
dnaml.c:      tbl[i][j]->orig_zz = exp(tbl[i][j]->rat * lz);
dnaml.c:      tbl[i][j]->z1 = exp(tbl[i][j]->ratxv * lz);
dnaml.c:    k = category[alias[i]-1] - 1;
dnaml.c:        zz = tbl[j][k]->orig_zz;
dnaml.c:        z1 = tbl[j][k]->z1;
dnaml.c:      zzs = -tbl[j][k]->rat * zz ;
dnaml.c:      z1s = -tbl[j][k]->ratxv * z1 ;
dnaml.c:      temp = tbl[j][k]->rat;
dnaml.c:      temp = tbl[j][k]->ratxv;
dnaml.c:      memcpy(x1, ((dna_node*)p)->x[i][j], sizeof(sitelike));
dnaml.c:      prod1 = freqa * x1[0] + freqc * x1[(long)C - (long)A] +
dnaml.c:        freqg * x1[(long)G - (long)A] + freqt * x1[(long)T - (long)A];
dnaml.c:      memcpy(x2, ((dna_node*)q)->x[i][j], sizeof(sitelike));
dnaml.c:      prod2 = freqa * x2[0] + freqc * x2[(long)C - (long)A] +
dnaml.c:        freqg * x2[(long)G - (long)A] + freqt * x2[(long)T - (long)A];
dnaml.c:      prod3 = (x1[0] * freqa + x1[(long)G - (long)A] * freqg) *
dnaml.c:        (x2[0] * freqar + x2[(long)G - (long)A] * freqgr) +
dnaml.c:        (x1[(long)C - (long)A] * freqc + x1[(long)T - (long)A] * freqt) *
dnaml.c:        (x2[(long)C - (long)A] * freqcy + x2[(long)T - (long)A] * freqty);
dnaml.c:        freqc * x1[(long)C - (long)A] * x2[(long)C - (long)A] +
dnaml.c:        freqg * x1[(long)G - (long)A] * x2[(long)G - (long)A] +
dnaml.c:        freqt * x1[(long)T - (long)A] * x2[(long)T - (long)A];
dnaml.c:      aa = prod12 - prod3;
dnaml.c:      bb = prod3 - prod1*prod2;
dnaml.c:    lterm = log(sumterm) + ((ml_node*)p)->underflows[i] + ((ml_node*)q)->underflows[i];
dnaml.c:    if ((ally[i] > 0) && (location[ally[i]-1] > 0))
dnaml.c:      lai = location[ally[i] - 1];
dnaml.c:      memcpy(clai, term[lai - 1], rcategs * sizeof(double));
dnaml.c:      memcpy(cslai, slopeterm[lai - 1], rcategs * sizeof(double));
dnaml.c:      memcpy(cclai, curveterm[lai - 1], rcategs * sizeof(double));
dnaml.c:        nulike[j] = ((1.0 - lambda) * thelike[j] + sumc) * clai[j];
dnaml.c:        nuslope[j] = ((1.0 - lambda) * theslope[j] + sumcs) * clai[j]
dnaml.c:          + ((1.0 - lambda) * thelike[j] + sumc) * cslai[j];
dnaml.c:        nucurve[j] = ((1.0 - lambda) * thecurve[j] + sumcc) * clai[j]
dnaml.c:          + 2.0 * ((1.0 - lambda) * theslope[j] + sumcs) * cslai[j]
dnaml.c:          + ((1.0 - lambda) * thelike[j] + sumc) * cclai[j];
dnaml.c:        nulike[j] = ((1.0 - lambda) * thelike[j] + sumc);
dnaml.c:        nuslope[j] = ((1.0 - lambda) * theslope[j] + sumcs);
dnaml.c:        nucurve[j] = ((1.0 - lambda) * thecurve[j] + sumcc);
dnaml.c:  (*curve) = curve2 / sum2 - *slope * *slope;
dnaml.c:  /* Newton-Raphson algorithm improvement of a branch length */
dnaml.c:  q = p->back;
dnaml.c:  y = p->v;
dnaml.c:      y = y + slope/fabs(curve);   /* Newton-Raphson, forced uphill-wards */
dnaml.c:      if (fabs(y - yold) < epsilon) /* if change is too small ... */
dnaml.c:    done = fabs(y-yold) < 0.1*epsilon;
dnaml.c:  smoothed = (fabs(yold-yorig) < epsilon) && (yorig > 1000.0*epsilon);
dnaml.c:  p->v = yold;      /* the last one that had better likelihood */
dnaml.c:  q->v = yold;
dnaml.c:  ((tree*)t)->score = oldlike;
dnaml.c:      *p = treep->get_forknode(treep, nodei);
dnaml.c:      ((ml_node*)*p)->allocx((ml_node*)*p, endsite, rcategs);
dnaml.c:      assert((*p)->index > 0);
dnaml.c:      nodep[(*p)->index - 1] = (*p);
dnaml.c:      *p = treep->get_forknode(treep, nodei);
dnaml.c:      ((ml_node*)*p)->allocx((ml_node*)*p, endsite, rcategs);
dnaml.c:      (*p)->initialized = false;
dnaml.c:      (*p)->v = initialv;
dnaml.c:      (*p)->iter = true;
dnaml.c:      if ((*p)->back != NULL)
dnaml.c:        (*p)->back->iter = true;
dnaml.c:        (*p)->back->v = initialv;
dnaml.c:        (*p)->back->initialized = false;
dnaml.c:      (*p)->v = valyew / divisor / fracchange;
dnaml.c:      (*p)->iter = false;
dnaml.c:      if ((*p)->back != NULL)
dnaml.c:        (*p)->back->v = (*p)->v;
dnaml.c:        (*p)->back->iter = false;
dnaml.c:  if (p->tip)
dnaml.c:    p->xcoord = (long)(over * lengthsum + 0.5);
dnaml.c:    p->ycoord = (*tipy);
dnaml.c:    p->ymin = (*tipy);
dnaml.c:    p->ymax = (*tipy);
dnaml.c:  q = p->next;
dnaml.c:    xx = fracchange * q->v;
dnaml.c:    dnaml_coordinates(q->back, lengthsum + xx, tipy, tipmax);
dnaml.c:    q = q->next;
dnaml.c:  } while ((p == curtree->root || p != q) && (p != curtree->root || p->next != q));
dnaml.c:  first = p->next->back;
dnaml.c:  while (q->next != p)
dnaml.c:    q = q->next;
dnaml.c:  last = q->back;
dnaml.c:  p->xcoord = (long)(over * lengthsum + 0.5);
dnaml.c:  if (p == curtree->root)
dnaml.c:    p->ycoord = p->next->next->back->ycoord;
dnaml.c:    p->ycoord = (first->ycoord + last->ycoord) / 2;
dnaml.c:  p->ymin = first->ymin;
dnaml.c:  p->ymax = last->ymax;
dnaml.c:  dnaml_coordinates(curtree->root, 0.0, &tipy, &tipmax);
dnaml.c:  for (i = 1; i <= (tipy - down); i++)
dnaml.c:  slopecurv (p, p->v, &like, &slope, &curv);
dnaml.c:  tt = p->v;
dnaml.c:  p->v = epsilon;
dnaml.c:  p->back->v = epsilon;
dnaml.c:  aa = curtree->evaluate(curtree, p, false);
dnaml.c:  p->v = tt;
dnaml.c:  p->back->v = tt;
dnaml.c:  (*sumlr) = curtree->evaluate(curtree, p, false) - aa;
dnaml.c:  if (curv < -epsilon)
dnaml.c:    (*s1) = p->v + (-slope - sqrt(slope * slope -  3.841 * curv)) / curv;
dnaml.c:    (*s2) = p->v + (-slope + sqrt(slope * slope -  3.841 * curv)) / curv;
dnaml.c:    (*s1) = -1.0;
dnaml.c:    (*s2) = -1.0;
dnaml.c:  if (!p->tip && !p->initialized)
dnaml.c:    curtree->nuview(curtree, p);
dnaml.c:  if (!p->back->tip && !p->back->initialized)
dnaml.c:    curtree->nuview(curtree, p->back);
dnaml.c:  q = p->back;
dnaml.c:  assert(p->index > 0);                 // RSGdebug
dnaml.c:  assert(q->index > 0);                 // RSGdebug
dnaml.c:  if (q->tip)
dnaml.c:      putc(nayme[q->index-1][i], outfile);
dnaml.c:    fprintf(outfile, "  %4ld          ", q->index - spp);
dnaml.c:  if (p->tip)
dnaml.c:      putc(nayme[p->index-1][i], outfile);
dnaml.c:    fprintf(outfile, "%4ld      ", p->index - spp);
dnaml.c:  fprintf(outfile, "%15.5f", q->v * fracchange);
dnaml.c:  if (reusertree || !usertree || (usertree && !lngths) || p->iter )
dnaml.c:  if (!p->tip)
dnaml.c:      sib_ptr = sib_ptr->next;
dnaml.c:      describe(sib_ptr->back);
dnaml.c:  j = location[ally[n]-1] - 1;
dnaml.c:    f = ((dna_node*)p)->x[j][mx-1][i];
dnaml.c:      q = q->next;
dnaml.c:      f *= ((dna_node*)q)->x[j][mx-1][i];
dnaml.c:    putc(toupper(basechar[m - 1]), outfile);
dnaml.c:    putc(basechar[m - 1], outfile);
dnaml.c:    mx = mp[n][mx - 1];
dnaml.c:  assert(p->index > 0);                 // RSGdebug
dnaml.c:  if (p->tip)
dnaml.c:      putc(nayme[p->index-1][i], outfile);
dnaml.c:    fprintf(outfile, "%4ld      ", p->index - spp);
dnaml.c:    if (p->tip)
dnaml.c:      putc(inputSequences[p->index-1][i], outfile);
dnaml.c:  if (!p->tip)
dnaml.c:    rectrav(p->next->back, m, n);
dnaml.c:    rectrav(p->next->next->back, m, n);
dnaml.c:  fprintf(outfile, "Ln Likelihood = %11.5f\n", curtree->score);
dnaml.c:  fprintf(outfile, " -------        ---            ------");
dnaml.c:    fprintf(outfile, "      ------- ---------- ------");
dnaml.c:    if (curtree->nodep[i])
dnaml.c:      num_sibs = count_sibs (curtree->nodep[i]);
dnaml.c:      sib_ptr  = curtree->nodep[i];
dnaml.c:        sib_ptr->initialized = false;
dnaml.c:        sib_ptr              = sib_ptr->next;
dnaml.c:  describe(curtree->root->back);
dnaml.c:  num_sibs = count_sibs (curtree->root);
dnaml.c:  sib_ptr  = curtree->root;
dnaml.c:    sib_ptr = sib_ptr->next;
dnaml.c:    describe(sib_ptr->back);
dnaml.c:  dummy = curtree->evaluate(curtree, curtree->root, false);
dnaml.c:    for (i = sites - 1; i >= 0; i--)
dnaml.c:        nulike[j] = (1.0 - lambda + lambda * probcat[j]) * like[j];
dnaml.c:            if (lambda * probcat[k - 1] * like[k - 1] > nulike[j])
dnaml.c:              nulike[j] = lambda * probcat[k - 1] * like[k - 1];
dnaml.c:        if ((ally[i] > 0) && (location[ally[i]-1] > 0))
dnaml.c:          nulike[j] *= contribution[location[ally[i] - 1] - 1][j];
dnaml.c:      if (probcat[i - 1] * like[i - 1] > mode)
dnaml.c:        mode = probcat[i - 1] * like[i - 1];
dnaml.c:      mx = mp[i - 1][mx - 1];
dnaml.c:    for (i = sites - 1; i >= 0; i--)
dnaml.c:        nulike[j] = (1.0 - lambda + lambda * probcat[j]) * like[j];
dnaml.c:            nulike[j] += lambda * probcat[k - 1] * like[k - 1];
dnaml.c:        if ((ally[i] > 0) && (location[ally[i]-1] > 0))
dnaml.c:          nulike[j] *= contribution[location[ally[i] - 1] - 1][j];
dnaml.c:        nulike[j] = (1.0 - lambda + lambda * probcat[j]) * like[j];
dnaml.c:            nulike[j] += lambda * probcat[k - 1] * like[k - 1];
dnaml.c:    for (i = 0; (i < 13) && (i < ((sites + (sites-1)/10 - 39) / 2)); i++)
dnaml.c:        k = sites - 1;
dnaml.c:      rectrav(curtree->root, i, k);
dnaml.c:      rectrav(curtree->root->back, i, k);
dnaml.c:  assert(p->index > 0);                 // RSGdebug
dnaml.c:  if (p->tip)
dnaml.c:      if (nayme[p->index-1][i - 1] != ' ')
dnaml.c:      c = nayme[p->index-1][i];
dnaml.c:    q = p->next;
dnaml.c:      dnaml_treeout(q->back);
dnaml.c:      q = q->next;
dnaml.c:    } while ((p == curtree->root || p != q) && (p != curtree->root || p->next != q));
dnaml.c:  x = p->v * fracchange;
dnaml.c:    w = (long)(0.43429448222 * log(-x)) + 1;
dnaml.c:  if (p == curtree->root)
dnaml.c:  node *r = t->root;
dnaml.c:    while ( q->next != r )
dnaml.c:      q = q->next;
dnaml.c:    q->next = r->next;
dnaml.c:    t->release_forknode(t, r);
dnaml.c:    t->nodep[spp] = q;
dnaml.c:    assert(r->back == NULL);            // RSGnote: This assumes the FORKRING being manipulated has the ROOT FORKNODE pointing to NULL.
dnaml.c:    newl = r->next->oldlen + r->next->next->oldlen;
dnaml.c:    r->next->back->oldlen = newl;
dnaml.c:    r->next->next->back->oldlen = newl;
dnaml.c:    newl = r->next->v + r->next->next->v;
dnaml.c:    r->next->back->v = newl;
dnaml.c:    r->next->next->back->v = newl;
dnaml.c:    r->next->back->back = r->next->next->back;
dnaml.c:    r->next->next->back->back = r->next->back;
dnaml.c:   t->release_fork(t, r);
dnaml.c:  t->root = t->nodep[0]->back;          // Reset ROOT; moved from line just after call to DNAML_REROOT.
dnaml.c:    //printf("in maketree - usertree: %i\n", usertree);
dnaml.c:      /* Open in binary: ftell() is broken for UNIX line-endings under WIN32 */
dnaml.c:      fprintf(outfile, "User-defined tree");
dnaml.c:    /* This taken out of tree read, used to be [spp-1], but referring to [0] produces output identical to what the pre-modified dnaml produced. */
dnaml.c:      /* These initializations required each time through the loop since multiple trees require re-initialization */
dnaml.c:      treeread(curtree, intree, &curtree->root, curtree->nodep, &goteof, &dummy_first, &nextnode, &haslengths, initdnamlnode, false, nonodes2);
dnaml.c:        printf ("\tNumber of trees actually in file:\t%ld.\n\n", which - 1);
dnaml.c:        exxit(-1);
dnaml.c:        curtree->root = curtree->nodep[outgrno - 1]->back;
dnaml.c:      if ( reusertree && ( which == 1 || curtree->score > bestree2->score ))
dnaml.c:        curtree->copy(curtree, bestree2);
dnaml.c:        bestree2->copy(bestree2, curtree);
dnaml.c:        curtree->root = curtree->nodep[0]->back;
dnaml.c:          curtree->root = curtree->nodep[outgrno - 1]->back;
dnaml.c:        dnaml_treeout(curtree->root);
dnaml.c:        freex_notip(nextnode, curtree->nodep);
dnaml.c:      standev2(numtrees, maxwhich, 0, endsite-1, maxlogl, l0gl, l0gf, aliasweight, seed);
dnaml.c:      enterorder[i - 1] = i;
dnaml.c:    curtree->root = curtree->nodep[enterorder[0] - 1]->back;
dnaml.c:        curtree->copy(curtree, priortree);
dnaml.c:      curtree->addtraverse(curtree, curtree->nodep[enterorder[nextsp - 1] - 1], curtree->root, true, &qwhere, &bestyet, bestree, priortree, smoothit, NULL);
dnaml.c:        bestree->copy(bestree, curtree);
dnaml.c:        curtree->insert_(curtree, curtree->nodep[enterorder[nextsp - 1] - 1], qwhere, true, false);
dnaml.c:        bestyet = curtree->score;
dnaml.c:        writename(nextsp - 1, 1, enterorder);
dnaml.c:        curtree->globrearrange(curtree, progress, smoothit);
dnaml.c:        curtree->locrearrange(curtree, curtree->nodep[enterorder[0]-1], smoothit, priortree, bestree);
dnaml.c:    curtree->copy(curtree, bestree);
dnaml.c:        bestree->copy(bestree, bestree2);
dnaml.c:        if (bestree2->score < bestree->score)
dnaml.c:          bestree->copy(bestree, bestree2);
dnaml.c:        bestree2->copy(bestree2, curtree);
dnaml.c:      curtree->root = curtree->nodep[outgrno - 1]->back;
dnaml.c:          curtree->nodep[i]->initialized = false;
dnaml.c:          curtree->nodep[i]->initialized = false;
dnaml.c:          curtree->nodep[i]->next->initialized = false;
dnaml.c:          curtree->nodep[i]->next->next->initialized = false;
dnaml.c:        dnaml_treeout(curtree->root);
dnaml.c:  freex(nonodes2, curtree->nodep);
dnaml.c:    freex(nonodes2, bestree->nodep);
dnaml.c:    freex(nonodes2, priortree->nodep);
dnaml.c:      freex(nonodes2, bestree2->nodep);
dnaml.c:  if (!usertree) nonodes2--;
dnaml.c:    // User-defined HMM of rates
dnaml.c:      initgammacat(rcategs-1, alpha, rrate, probcat);
dnaml.c:      for (i = 0; i < rcategs-1; i++)
dnaml.c:        probcat[i] = probcat[i]*(1.0-invarfrac);
dnaml.c:      probcat[rcategs-1] = invarfrac;
dnaml.c:      rrate[rcategs-1] = 0.0;
dnamlk.c:/* Version 4.0. (c) Copyright 1986-2013 by the University of Washington
dnamlk.c:/*  sites = number of sites in actual sequences numtrees = number of user-defined trees */
dnamlk.c:  t->insert_  = mlk_tree_insert_;
dnamlk.c:  t->try_insert_ = ml_tree_try_insert_;
dnamlk.c:  t->re_move = mlk_tree_re_move;
dnamlk.c:  t->evaluate = dnamlk_tree_evaluate;
dnamlk.c:  t->globrearrange = rooted_globrearrange;
dnamlk.c:  t->locrearrange = rooted_locrearrange;
dnamlk.c:  ((ml_tree*)t)->makenewv = (makenewv_t)mlk_tree_makenewv;
dnamlk.c:  t->nuview = dnamlk_tree_nuview;
dnamlk.c:  t->save_lr_nodes = rooted_tree_save_lr_nodes;
dnamlk.c:  t->restore_lr_nodes = rooted_tree_restore_lr_nodes;
dnamlk.c:          printf("  user-defined HMM of rates\n");
dnamlk.c:              printf("\nSitewise user-assigned categories:\n\n");
dnamlk.c:              lambda1 = 1.0 - lambda;
dnamlk.c:        initgammacat(rcategs-1, alpha, rrate, probcat);
dnamlk.c:        for (i = 0; i < rcategs-1; i++)
dnamlk.c:          probcat[i] = probcat[i]*(1.0-invarfrac);
dnamlk.c:        probcat[rcategs-1] = invarfrac;
dnamlk.c:        rrate[rcategs-1] = 0.0;
dnamlk.c:  tymes       = (double *)Malloc((nonodes - spp) * sizeof(double));
dnamlk.c:     location[i-1] ends up as the position in the lexicographic order
dnamlk.c:     others that are tied with it.  Otherwise location[i-1] is 0
dnamlk.c:    alias[i - 1] = i;
dnamlk.c:    ally[i - 1] = i;
dnamlk.c:    aliasweight[i - 1] = weight[i - 1];
dnamlk.c:    location[i - 1] = 0;
dnamlk.c:    if (ally[i - 1] == i)
dnamlk.c:    location[alias[i - 1] - 1] = i;
dnamlk.c:  makevalues2(rcategs, curtree->nodep, endsite, spp, inputSequences, alias);
dnamlk.c:    empiricalfreqs(&freqa, &freqc, &freqg, &freqt, aliasweight, curtree->nodep);
dnamlk.c:      free (tbl[i][j]->ww);
dnamlk.c:      free (tbl[i][j]->zz);
dnamlk.c:      free (tbl[i][j]->wwzz);
dnamlk.c:      free (tbl[i][j]->vvzz);
dnamlk.c:      /* Then allocate for worst-case multifurcations */
dnamlk.c:      tbl[i][j]->ww   = (double *) Malloc(num_comma * sizeof (double));
dnamlk.c:      tbl[i][j]->zz   = (double *) Malloc(num_comma * sizeof (double));
dnamlk.c:      tbl[i][j]->wwzz = (double *) Malloc(num_comma * sizeof (double));
dnamlk.c:      tbl[i][j]->vvzz = (double *) Malloc(num_comma * sizeof (double));
dnamlk.c:      free(tbl[i][j]->ww);
dnamlk.c:      free(tbl[i][j]->zz);
dnamlk.c:      free(tbl[i][j]->wwzz);
dnamlk.c:      free(tbl[i][j]->vvzz);
dnamlk.c:      tbl[i][j]->rat = rrate[i]*rate[j];
dnamlk.c:      tbl[i][j]->ratxi = tbl[i][j]->rat * xi;
dnamlk.c:      tbl[i][j]->ratxv = tbl[i][j]->rat * xv;
dnamlk.c:      tbl[i][j]->ww   = (double *) Malloc(2 * sizeof (double));
dnamlk.c:      tbl[i][j]->zz   = (double *) Malloc(2 * sizeof (double));
dnamlk.c:      tbl[i][j]->wwzz = (double *) Malloc(2 * sizeof (double));
dnamlk.c:      tbl[i][j]->vvzz = (double *) Malloc(2 * sizeof (double));
dnamlk.c:        * tbl[j][category[alias[i] - 1] - 1]->rat;
dnamlk.c:      tbl[i][j]->rat /= sumrates;
dnamlk.c:      tbl[i][j]->ratxi /= sumrates;
dnamlk.c:      tbl[i][j]->ratxv /= sumrates;
dnamlk.c:  local_nvd->yy     = (double *) Malloc(num_sibs * sizeof (double));
dnamlk.c:  local_nvd->wwzz   = (double *) Malloc(num_sibs * sizeof (double));
dnamlk.c:  local_nvd->vvzz   = (double *) Malloc(num_sibs * sizeof (double));
dnamlk.c:  local_nvd->vzsumr = (double *) Malloc(num_sibs * sizeof (double));
dnamlk.c:  local_nvd->vzsumy = (double *) Malloc(num_sibs * sizeof (double));
dnamlk.c:  local_nvd->sum    = (double *) Malloc(num_sibs * sizeof (double));
dnamlk.c:  local_nvd->sumr   = (double *) Malloc(num_sibs * sizeof (double));
dnamlk.c:  local_nvd->sumy   = (double *) Malloc(num_sibs * sizeof (double));
dnamlk.c:  local_nvd->xx     = (sitelike *) Malloc(num_sibs * sizeof (sitelike));
dnamlk.c:  free (local_nvd->yy);
dnamlk.c:  free (local_nvd->wwzz);
dnamlk.c:  free (local_nvd->vvzz);
dnamlk.c:  free (local_nvd->vzsumr);
dnamlk.c:  free (local_nvd->vzsumy);
dnamlk.c:  free (local_nvd->sum);
dnamlk.c:  free (local_nvd->sumr);
dnamlk.c:  free (local_nvd->sumy);
dnamlk.c:  free (local_nvd->xx);
dnamlk.c:    sib_ptr      = sib_ptr->next;
dnamlk.c:    sib_back_ptr = sib_ptr->back;
dnamlk.c:      lw = -fabs( get_tyme(p) - get_tyme(sib_back_ptr) );
dnamlk.c:        tbl[i][j]->ww[sib_index]   = exp(tbl[i][j]->ratxi * lw);
dnamlk.c:        tbl[i][j]->zz[sib_index]   = exp(tbl[i][j]->ratxv * lw);
dnamlk.c:        tbl[i][j]->wwzz[sib_index] = tbl[i][j]->ww[sib_index] * tbl[i][j]->zz[sib_index];
dnamlk.c:        tbl[i][j]->vvzz[sib_index] = (1.0 - tbl[i][j]->ww[sib_index]) *
dnamlk.c:          tbl[i][j]->zz[sib_index];
dnamlk.c:    k = category[alias[i]-1] - 1;
dnamlk.c:        sib_ptr         = sib_ptr->next;
dnamlk.c:        sib_back_ptr    = sib_ptr->back;
dnamlk.c:        local_nvd->wwzz[sib_index] = tbl[j][k]->wwzz[sib_index];
dnamlk.c:        local_nvd->vvzz[sib_index] = tbl[j][k]->vvzz[sib_index];
dnamlk.c:        local_nvd->yy[sib_index]   = 1.0 - tbl[j][k]->zz[sib_index];
dnamlk.c:          memcpy(local_nvd->xx[sib_index],
dnamlk.c:                 ((dna_node*)sib_back_ptr)->x[i][j],
dnamlk.c:            correction += ((ml_node*)sib_back_ptr)->underflows[i];
dnamlk.c:          local_nvd->xx[sib_index][0] = 1.0;
dnamlk.c:          local_nvd->xx[sib_index][(long)C - (long)A] = 1.0;
dnamlk.c:          local_nvd->xx[sib_index][(long)G - (long)A] = 1.0;
dnamlk.c:          local_nvd->xx[sib_index][(long)T - (long)A] = 1.0;
dnamlk.c:        local_nvd->sum[sib_index] =
dnamlk.c:          local_nvd->yy[sib_index] *
dnamlk.c:          (freqa * local_nvd->xx[sib_index][(long)A] +
dnamlk.c:           freqc * local_nvd->xx[sib_index][(long)C] +
dnamlk.c:           freqg * local_nvd->xx[sib_index][(long)G] +
dnamlk.c:           freqt * local_nvd->xx[sib_index][(long)T]);
dnamlk.c:        local_nvd->sumr[sib_index] =
dnamlk.c:          freqar * local_nvd->xx[sib_index][(long)A] +
dnamlk.c:          freqgr * local_nvd->xx[sib_index][(long)G];
dnamlk.c:        local_nvd->sumy[sib_index] =
dnamlk.c:          freqcy * local_nvd->xx[sib_index][(long)C] +
dnamlk.c:          freqty * local_nvd->xx[sib_index][(long)T];
dnamlk.c:        local_nvd->vzsumr[sib_index] =
dnamlk.c:          local_nvd->vvzz[sib_index] * local_nvd->sumr[sib_index];
dnamlk.c:        local_nvd->vzsumy[sib_index] =
dnamlk.c:          local_nvd->vvzz[sib_index] * local_nvd->sumy[sib_index];
dnamlk.c:          local_nvd->sum[sib_index] +
dnamlk.c:          local_nvd->wwzz[sib_index] *
dnamlk.c:          local_nvd->xx[sib_index][(long)A] +
dnamlk.c:          local_nvd->vzsumr[sib_index];
dnamlk.c:          local_nvd->sum[sib_index] +
dnamlk.c:          local_nvd->wwzz[sib_index] *
dnamlk.c:          local_nvd->xx[sib_index][(long)C] +
dnamlk.c:          local_nvd->vzsumy[sib_index];
dnamlk.c:          local_nvd->sum[sib_index] +
dnamlk.c:          local_nvd->wwzz[sib_index] *
dnamlk.c:          local_nvd->xx[sib_index][(long)G] +
dnamlk.c:          local_nvd->vzsumr[sib_index];
dnamlk.c:          local_nvd->sum[sib_index] +
dnamlk.c:          local_nvd->wwzz[sib_index] *
dnamlk.c:          local_nvd->xx[sib_index][(long)T] +
dnamlk.c:          local_nvd->vzsumy[sib_index];
dnamlk.c:      for ( l = 0 ; l < ((long)T - (long)A + 1 ) ; l++ )
dnamlk.c:      memcpy(((dna_node*)p)->x[i][j], p_xx, sizeof(sitelike));
dnamlk.c:    ((ml_node*)p)->underflows[i] = 0;
dnamlk.c:    ((ml_node*)p)->underflows[i] += correction;
dnamlk.c:  p->initialized = true;
dnamlk.c:  if (p == t->root && (count_sibs(p) == 2))
dnamlk.c:    r = p->next->back;
dnamlk.c:    q = p->next->next->back;
dnamlk.c:    y = get_tyme(r) + get_tyme(q) - 2 * get_tyme(p);
dnamlk.c:    if (!r->tip && !r->initialized) t->nuview (t, r);
dnamlk.c:    if (!q->tip && !q->initialized) t->nuview (t, q);
dnamlk.c:  else if (p == t->root)
dnamlk.c:    /* the next two lines copy tyme and x to p->next.  Normally they are
dnamlk.c:    set_tyme(p->next, get_tyme(p));
dnamlk.c:    t->nuview(t, p->next);
dnamlk.c:    r = p->next;
dnamlk.c:    q = p->next->back;
dnamlk.c:    y = fabs( get_tyme(p->next) - get_tyme(q) );
dnamlk.c:    q = p->back;
dnamlk.c:    if (!r->tip && !r->initialized) t->nuview (t, r);
dnamlk.c:    if (!q->tip && !q->initialized) t->nuview (t, q);
dnamlk.c:    y = fabs( get_tyme(r) - get_tyme(q) );
dnamlk.c:  lz = -y;
dnamlk.c:      tbl[i][j]->orig_zz = exp(tbl[i][j]->ratxi * lz);
dnamlk.c:      tbl[i][j]->z1 = exp(tbl[i][j]->ratxv * lz);
dnamlk.c:      tbl[i][j]->z1zz = tbl[i][j]->z1 * tbl[i][j]->orig_zz;
dnamlk.c:      tbl[i][j]->z1yy = tbl[i][j]->z1 - tbl[i][j]->z1zz;
dnamlk.c:    k = category[alias[i]-1] - 1;
dnamlk.c:        y1 = 1.0 - tbl[j][k]->z1;
dnamlk.c:        z1zz = tbl[j][k]->z1zz;
dnamlk.c:        z1yy = tbl[j][k]->z1yy;
dnamlk.c:      memcpy(x1, ((dna_node*)r)->x[i][j], sizeof(sitelike));
dnamlk.c:      prod1 = freqa * x1[0] + freqc * x1[(long)C - (long)A] + freqg * x1[(long)G - (long)A] + freqt * x1[(long)T - (long)A];
dnamlk.c:      memcpy(x2, ((dna_node*)q)->x[i][j], sizeof(sitelike));
dnamlk.c:      prod2 = freqa * x2[0] + freqc * x2[(long)C - (long)A] + freqg * x2[(long)G - (long)A] + freqt * x2[(long)T - (long)A];
dnamlk.c:      prod3 = (x1[0] * freqa + x1[(long)G - (long)A] * freqg) * (x2[0] * freqar + x2[(long)G - (long)A] * freqgr) + (x1[(long)C - (long)A] * freqc + x1[(long)T - (long)A] * freqt) * (x2[(long)C - (long)A] * freqcy + x2[(long)T - (long)A] * freqty);
dnamlk.c:      prod12 = freqa * x1[0] * x2[0] + freqc * x1[(long)C - (long)A] * x2[(long)C - (long)A] + freqg * x1[(long)G - (long)A] * x2[(long)G - (long)A] + freqt * x1[(long)T - (long)A] * x2[(long)T - (long)A];
dnamlk.c:    lterm = log(sumterm) + ((ml_node*)p)->underflows[i] +
dnamlk.c:      ((ml_node*)q)->underflows[i];
dnamlk.c:      l0gf[which - 1][i] = lterm;
dnamlk.c:      if ((ally[i] > 0) && (location[ally[i]-1] > 0))
dnamlk.c:        lai = location[ally[i] - 1];
dnamlk.c:        memcpy(clai, contribution[lai - 1], sizeof(contribarr));
dnamlk.c:          nulike[j] = ((1.0 - lambda) * like[j] + sumc) * clai[j];
dnamlk.c:          nulike[j] = ((1.0 - lambda) * like[j] + sumc);
dnamlk.c:  t->score = sum;
dnamlk.c:    l0gl[which - 1] = sum;
dnamlk.c:      *p = treep->get_forknode(treep, nodei);
dnamlk.c:      ((ml_node*)*p)->allocx((ml_node*)*p, endsite, rcategs);
dnamlk.c:      nodep[(*p)->index - 1] = (*p);
dnamlk.c:      *p = treep->get_forknode(treep, nodei);
dnamlk.c:      ((ml_node*)*p)->allocx((ml_node*)*p, endsite, rcategs);
dnamlk.c:      (*p)->index = nodei;
dnamlk.c:      (*p)->initialized = false;
dnamlk.c:      (*p)->v = initialv;
dnamlk.c:      (*p)->iter = true;
dnamlk.c:      if ((*p)->back != NULL)
dnamlk.c:        (*p)->back->iter = true;
dnamlk.c:      (*p)->v = valyew / divisor / fracchange;
dnamlk.c:      (*p)->iter = false;
dnamlk.c:      if ((*p)->back != NULL)
dnamlk.c:        (*p)->back->v = (*p)->v;
dnamlk.c:        (*p)->back->iter = false;
dnamlk.c:  if (!p->tip)
dnamlk.c:      sib_ptr = sib_ptr->next;
dnamlk.c:      tymetrav(sib_ptr->back, x);
dnamlk.c:  if (!p->tip)
dnamlk.c:    while (q->next != p)
dnamlk.c:      q = q->next;
dnamlk.c:  (*x) = get_tyme(p) - p->v ;
dnamlk.c:  if (p->tip)
dnamlk.c:    p->xcoord = 0;
dnamlk.c:    p->ycoord = (*tipy);
dnamlk.c:    p->ymin   = (*tipy);
dnamlk.c:    p->ymax   = (*tipy);
dnamlk.c:  q = p->next;
dnamlk.c:    dnamlk_coordinates(q->back, tipy);
dnamlk.c:    q = q->next;
dnamlk.c:  q = p->next;
dnamlk.c:  first  = q->back;
dnamlk.c:    if (i == p1) pp1 = q->back;
dnamlk.c:    if (i == p2) pp2 = q->back;
dnamlk.c:    last = q->back;
dnamlk.c:    q = q->next;
dnamlk.c:  p->xcoord = (long)(0.5 - over * get_tyme(p));
dnamlk.c:  p->ycoord = (pp1->ycoord + pp2->ycoord) / 2;
dnamlk.c:  p->ymin = first->ymin;
dnamlk.c:  p->ymax = last->ymax;
dnamlk.c:  p = curtree->root;
dnamlk.c:  q = curtree->root;
dnamlk.c:  if ((long)(p->ycoord) == i)
dnamlk.c:    if (p->index - spp >= 10)
dnamlk.c:      fprintf(outfile, "-%2ld", p->index - spp);
dnamlk.c:      fprintf(outfile, "--%ld", p->index - spp);
dnamlk.c:    if (!p->tip)
dnamlk.c:      r = p->next;
dnamlk.c:        if (i >= r->back->ymin && i <= r->back->ymax)
dnamlk.c:          q = r->back;
dnamlk.c:        r = r->next;
dnamlk.c:      first = p->next->back;
dnamlk.c:      r = p->next;
dnamlk.c:      while (r->next != p)
dnamlk.c:        r = r->next;
dnamlk.c:      last = r->back;
dnamlk.c:    n = (long)(scale * ((long)(p->xcoord) - (long)(q->xcoord)) + 0.5);
dnamlk.c:    if (n < 3 && !q->tip)
dnamlk.c:      n--;
dnamlk.c:    if ((long)(q->ycoord) == i && !done)
dnamlk.c:      if (p->ycoord != q->ycoord)
dnamlk.c:        putc('-', outfile);
dnamlk.c:      if (!q->tip)
dnamlk.c:        for (j = 1; j <= n - 2; j++)
dnamlk.c:          putc('-', outfile);
dnamlk.c:        if (q->index - spp >= 10)
dnamlk.c:          fprintf(outfile, "%2ld", q->index - spp);
dnamlk.c:          fprintf(outfile, "-%ld", q->index - spp);
dnamlk.c:          putc('-', outfile);
dnamlk.c:    else if (!p->tip)
dnamlk.c:      if ((long)(last->ycoord) > i && (long)(first->ycoord) < i &&
dnamlk.c:          i != (long)(p->ycoord))
dnamlk.c:  if ((long)(p->ycoord) == i && p->tip)
dnamlk.c:      putc(nayme[p->index - 1][j], outfile);
dnamlk.c:  dnamlk_coordinates(curtree->root, &tipy);
dnamlk.c:  p = curtree->root;
dnamlk.c:  while (!p->tip)
dnamlk.c:    p = p->next->back;
dnamlk.c:  scale = 1.0 / (long)(get_tyme(p) - get_tyme(curtree->root) + 1.000);
dnamlk.c:  for (i = 1; i <= tipy - down; i++)
dnamlk.c:  if (p == curtree->root)
dnamlk.c:    fprintf(outfile, "%4ld          ", p->back->index - spp);
dnamlk.c:  if (p->tip)
dnamlk.c:      putc(nayme[p->index - 1][i], outfile);
dnamlk.c:    fprintf(outfile, "%4ld      ", p->index - spp);
dnamlk.c:  if (p != curtree->root)
dnamlk.c:    fprintf(outfile, "%11.5f", fracchange * (get_tyme(p) - get_tyme(curtree->root)));
dnamlk.c:    v = fracchange * ( get_tyme(p) - get_tyme(curtree->nodep[p->back->index - 1]));
dnamlk.c:  if (!p->tip)
dnamlk.c:      sib_ptr      = sib_ptr->next;
dnamlk.c:      sib_back_ptr = sib_ptr->back;
dnamlk.c:  j = location[ally[n]-1] - 1;
dnamlk.c:    if (p == curtree->root)    /* ... as  x  has not been computed there */
dnamlk.c:      f = ((dna_node*)p)->x[j][mx-1][i];
dnamlk.c:      q = q->next;
dnamlk.c:      f *= ((dna_node*)q)->x[j][mx-1][i];
dnamlk.c:      f = exp(log(f)/(num_sibs-1.0));
dnamlk.c:    putc(toupper(basechar[m - 1]), outfile);
dnamlk.c:    putc(basechar[m - 1], outfile);
dnamlk.c:    mx = mp[n][mx - 1];
dnamlk.c:  if (p->tip)
dnamlk.c:      putc(nayme[p->index-1][i], outfile);
dnamlk.c:    fprintf(outfile, "%4ld      ", p->index - spp);
dnamlk.c:    if (p->tip)
dnamlk.c:      putc(inputSequences[p->index-1][i], outfile);
dnamlk.c:  if (!p->tip)
dnamlk.c:      sib_ptr = sib_ptr->next;
dnamlk.c:      rectrav(sib_ptr->back, m, n);
dnamlk.c:  for (i = 0; i <= sites-1; ++i)
dnamlk.c:  fprintf(outfile, "\nLn Likelihood = %11.5f\n\n", curtree->score);
dnamlk.c:  fprintf(outfile, " --------      ----      ---- ------     ------\n");
dnamlk.c:  describe(curtree->root);
dnamlk.c:    for (i = sites - 1; i >= 0; i--)
dnamlk.c:            if (lambda * probcat[k - 1] * like[k - 1] > nulike[j])
dnamlk.c:              nulike[j] = lambda * probcat[k - 1] * like[k - 1];
dnamlk.c:        if ((ally[i] > 0) && (location[ally[i]-1] > 0))
dnamlk.c:          nulike[j] *= contribution[location[ally[i] - 1] - 1][j];
dnamlk.c:      if (probcat[i - 1] * like[i - 1] > mode)
dnamlk.c:        mode = probcat[i - 1] * like[i - 1];
dnamlk.c:      mx = mp[i - 1][mx - 1];
dnamlk.c:    for (i = sites - 1; i >= 0; i--)
dnamlk.c:            nulike[j] += lambda * probcat[k - 1] * like[k - 1];
dnamlk.c:        if ((ally[i] > 0) && (location[ally[i]-1] > 0))
dnamlk.c:          nulike[j] *= contribution[location[ally[i] - 1] - 1][j];
dnamlk.c:            nulike[j] += lambda * probcat[k - 1] * like[k - 1];
dnamlk.c:    for (i = 0; (i < 13) && (i < ((sites + (sites-1)/10 - 39) / 2)); i++)
dnamlk.c:        k = sites - 1;
dnamlk.c:      rectrav(curtree->root, i, k);
dnamlk.c:  if (p->tip)
dnamlk.c:      if (nayme[p->index - 1][i - 1] != ' ')
dnamlk.c:      c = nayme[p->index - 1][i];
dnamlk.c:    for (i=0; i < (num_sibs - 1); i++)
dnamlk.c:      sib_ptr = sib_ptr->next;
dnamlk.c:      dnamlk_treeout(sib_ptr->back);
dnamlk.c:    sib_ptr = sib_ptr->next;
dnamlk.c:    dnamlk_treeout(sib_ptr->back);
dnamlk.c:  if (p == curtree->root)
dnamlk.c:  x = fracchange * ( get_tyme(p) - get_tyme(curtree->nodep[p->back->index - 1]));
dnamlk.c:    w = (long)(0.4342944822 * log(-x)) + 1;
dnamlk.c:  lowertyme = get_tyme(p->next->back);
dnamlk.c:    sib_ptr      = sib_ptr->next;
dnamlk.c:    sib_back_ptr = sib_ptr->back;
dnamlk.c:  set_tyme(p, lowertyme - initialv);
dnamlk.c:    sib_ptr = sib_ptr->next;
dnamlk.c:    sib_back_ptr = sib_ptr->back;
dnamlk.c:    sib_back_ptr->v = ( get_tyme(sib_back_ptr) - get_tyme(p) );
dnamlk.c:    sib_ptr->v = sib_back_ptr->v;
dnamlk.c:  if (p->tip)
dnamlk.c:    sib_ptr      = sib_ptr->next;
dnamlk.c:    sib_back_ptr = sib_ptr->back;
dnamlk.c:  if (p->tip)
dnamlk.c:  if (p->initialized)
dnamlk.c:    sib_ptr      = sib_ptr->next;
dnamlk.c:    sib_back_ptr = sib_ptr->back;
dnamlk.c:  t->nuview(t, p);
dnamlk.c:  p->initialized = true;
dnamlk.c:  if (p == curtree->root)
dnamlk.c:  if (p->tip)
dnamlk.c:    travinit(curtree, p->back);
dnamlk.c:      sib_ptr      = sib_ptr->next;
dnamlk.c:      sib_back_ptr = sib_ptr->back;
dnamlk.c:      curtree->nodep[i]->initialized = false;
dnamlk.c:      sib_ptr = curtree->nodep[i];
dnamlk.c:      sib_ptr->initialized = false;
dnamlk.c:        sib_ptr      = sib_ptr->next;
dnamlk.c:        sib_ptr->initialized = false;
dnamlk.c:    initrav(curtree->root);
dnamlk.c:    travsp(curtree->root);
dnamlk.c:      curtree->smoothall(curtree, curtree->root); /* already is a loop within smoothall, we need more! */
dnamlk.c:    curtree->smoothall(curtree, curtree->root); /* we should already be close */
dnamlk.c:  curtree->evaluate(curtree, curtree->root, false);
dnamlk.c:      enterorder[i - 1] = i;
dnamlk.c:    curtree->root = curtree->nodep[enterorder[0]-1];
dnamlk.c:    curtree->root = curtree->nodep[curtree->root->index - 1];
dnamlk.c:      curtree->nodep[i]->back = NULL;
dnamlk.c:      q = curtree->nodep[i];
dnamlk.c:      q->back = NULL;
dnamlk.c:      while ((q = q->next) != curtree->nodep[i])
dnamlk.c:        q->back = NULL;
dnamlk.c:    curtree->insert_(curtree, curtree->nodep[enterorder[1]-1], curtree->nodep[enterorder[0] - 1], false, false);
dnamlk.c:      bestree->score = UNDEFINED;
dnamlk.c:      there = curtree->root;
dnamlk.c:      item = curtree->nodep[enterorder[i - 1] - 1];
dnamlk.c:      curtree->addtraverse(curtree, item, curtree->root, true, &there, &bestyet, bestree, priortree, false, &multf);
dnamlk.c:      curtree->insert_(curtree, item, there, true, multf);
dnamlk.c:      curtree->smoothall(curtree, curtree->root);/* do we need this */
dnamlk.c:      curtree->locrearrange(curtree, curtree->root, false, priortree, bestree);
dnamlk.c:        writename(i - 1, 1, enterorder);
dnamlk.c:          if ( (j-spp) % (( nonodes / 72 ) + 1 ) == 0 )
dnamlk.c:            sprintf(progbuf, "-");
dnamlk.c:      curtree->globrearrange(curtree, progress, true);
dnamlk.c:      curtree->copy(curtree, bestree);
dnamlk.c:    curtree->copy(curtree, bestree);
dnamlk.c:      for (i = 0; i < spp - 1; i++ )
dnamlk.c:        curtree->re_move(curtree, curtree->nodep[i], &dummy, false);
dnamlk.c:      curtree->root = NULL;
dnamlk.c:      if (jumb == 1 || bestree2->score < bestree->score)
dnamlk.c:        bestree->copy(bestree, bestree2);
dnamlk.c:        bestree2->copy(bestree2, curtree);
dnamlk.c:        bestree->copy(bestree, curtree);
dnamlk.c:      curtree->score = curtree->evaluate(curtree, curtree->root, false);
dnamlk.c:        dnamlk_treeout(curtree->root);
dnamlk.c:    /* Open in binary: ftell() is broken for UNIX line-endings under WIN32 */
dnamlk.c:      fprintf(outfile, "User-defined tree");
dnamlk.c:         since multiple trees require re-initialization */
dnamlk.c:      treeread(curtree, intree, &curtree->root, curtree->nodep, &goteof, &dummy_first, &nextnode, &dummy_haslengths, initdnamlknode, false, nonodes);
dnamlk.c:        tymetrav(curtree->root, &x);
dnamlk.c:        printf ("\tNumber of trees actually in file:\t%ld.\n\n", which - 1);
dnamlk.c:        exxit(-1);
dnamlk.c:        dnamlk_treeout(curtree->root);
dnamlk.c:        freex_notip(nonodes, curtree->nodep);
dnamlk.c:    freex(nonodes, curtree->nodep);
dnamlk.c:      freex(nonodes, bestree->nodep);
dnamlk.c:        freex(nonodes, bestree2->nodep);
dnamlk.c:/*?? Dnaml has a clean-up function for freeing memory, closing files, etc.
dnamlk.c:  funcs->node_new = dna_node_new;
dnamlk.c:  funcs->tree_new = dnamlk_tree_new;
dnamlk.c:    // User-defined HMM of rates
dnamlk.c:      initgammacat(rcategs-1, alpha, rrate, probcat);
dnamlk.c:      for (i = 0; i < rcategs-1; i++)
dnamlk.c:        probcat[i] = probcat[i]*(1.0-invarfrac);
dnamlk.c:      probcat[rcategs-1] = invarfrac;
dnamlk.c:      rrate[rcategs-1] = 0.0;
dnamlk.c:  funcs->node_new = dna_node_new;
dnamlk.c:  funcs->tree_new = dnamlk_tree_new;
dnamove.c:/* Version 4.0. (c) Copyright 1993-2013 by the University of Washington.
dnamove.c:boolean reversed[(long)question - (long)horiz + 1];
dnamove.c:boolean graphic[(long)question - (long)horiz + 1];
dnamove.c:unsigned char chh[(long)question - (long)horiz + 1];
dnamove.c:  if (p->tip)
dnamove.c:  q = p->next;
dnamove.c:    numdesctrav(q->back);
dnamove.c:    q = q->next;
dnamove.c:    alias[i - 1] = i;
dnamove.c:    ally[i - 1] = i;
dnamove.c:    if (ally[i - 1] == i)
dnamove.c:    location[alias[i - 1] - 1] = i;
dnamove.c:  /* configure to machine -- set up special characters */
dnamove.c:  chh[(long)overt] = '-';
dnamove.c:  if (below != curtree->nodep[below->index - 1])
dnamove.c:    below = curtree->nodep[below->index - 1];
dnamove.c:    newfork = curtree->get_forkring(curtree);
dnamove.c:  if (below->back != NULL)
dnamove.c:    below->back->back = newfork;
dnamove.c:  newfork->back = below->back;
dnamove.c:  rtdesc->back = newfork->next->next;
dnamove.c:  newfork->next->next->back = rtdesc;
dnamove.c:  newfork->next->back = leftdesc;
dnamove.c:  leftdesc->back = newfork->next;
dnamove.c:  if (curtree->root == below)
dnamove.c:    curtree->root = newfork;
dnamove.c:  curtree->root->back = NULL;
dnamove.c:  if (atnode != curtree->nodep[atnode->index - 1])
dnamove.c:    atnode = curtree->nodep[atnode->index - 1];
dnamove.c:  q = curtree->nodep[newtip->index-1]->back;
dnamove.c:    q = curtree->nodep[q->index-1];
dnamove.c:    if (newtip == q->next->next->back)
dnamove.c:      q->next->back = newtip;
dnamove.c:      newtip->back = q->next;
dnamove.c:      q->next->next->back = NULL;
dnamove.c:  if (newtip->back != NULL)
dnamove.c:    add_at(atnode, newtip, curtree->nodep[newtip->back->index-1]);
dnamove.c:  if (parent != curtree->nodep[parent->index - 1])
dnamove.c:    parent = curtree->nodep[parent->index - 1];
dnamove.c:  newnode = curtree->get_forknode(curtree, parent->index);
dnamove.c:  newnode->tip = false;
dnamove.c:  newnode->deleted=false;
dnamove.c:  newnode->deadend=false;
dnamove.c:    newnode->nayme[i] = '\0';
dnamove.c:    q = q->next;
dnamove.c:  } while (q->next != parent);
dnamove.c:  newnode->next = parent;
dnamove.c:  q->next = newnode;
dnamove.c:  newnode->back = newchild;
dnamove.c:  newchild->back = newnode;
dnamove.c:  if (newchild->haslength)
dnamove.c:    newnode->length = newchild->length;
dnamove.c:    newnode->haslength = true;
dnamove.c:    newnode->haslength = false;
dnamove.c:  if(outgroup->back->index == curtree->root->index)
dnamove.c:  q = curtree->root->next;
dnamove.c:    q = p->next;
dnamove.c:  } while (q != curtree->root);
dnamove.c:  p = outgroup->back;
dnamove.c:  while (p->index != curtree->root->index)
dnamove.c:    q = curtree->nodep[p->index - 1]->back;
dnamove.c:    curtree->nodep[p->index - 1] = p;
dnamove.c:    curtree->nodep[p->index - 1] = p;
dnamove.c:    r->next = curtree->root->next;
dnamove.c:    curtree->root->next = NULL;
dnamove.c:    curtree->root = curtree->get_forkring(curtree);
dnamove.c:      /* root->haslength remains false, or else treeout() will generate
dnamove.c:      curtree->root->next->haslength = true;
dnamove.c:      curtree->root->next->next->haslength = true;
dnamove.c:    q = curtree->root->next;
dnamove.c:    q->back->back = r->back;
dnamove.c:    r->back->back = q->back;
dnamove.c:      r->back->length = r->back->length + q->back->length;
dnamove.c:      q->back->length = r->back->length;
dnamove.c:  curtree->root->next->back = outgroup;
dnamove.c:  curtree->root->next->next->back = outgroup->back;
dnamove.c:  outgroup->back->back = curtree->root->next->next;
dnamove.c:  outgroup->back = curtree->root->next;
dnamove.c:    templen = outgroup->length / 2.0;
dnamove.c:    outgroup->length = templen;
dnamove.c:    outgroup->back->length = templen;
dnamove.c:    curtree->root->next->next->length = templen;
dnamove.c:    curtree->root->next->next->back->length = templen;
dnamove.c:    if ((*pos) >= leftedge && (*pos) - leftedge + 1 < screenwidth)
dnamove.c:  if (i == p->ycoord && (p == curtree->root || subtree))
dnamove.c:      switch (p->state)
dnamove.c:    if (p->index >= 100)
dnamove.c:      nnwrite(p->index, 3, &pos, leftedge, screenwidth);
dnamove.c:    else if (p->index >= 10)
dnamove.c:      nnwrite(p->index, 2, &pos, leftedge, screenwidth);
dnamove.c:      nnwrite(p->index, 1, &pos, leftedge, screenwidth);
dnamove.c:    if (!p->tip)
dnamove.c:      r = p->next;
dnamove.c:        if (i >= r->back->ymin && i <= r->back->ymax)
dnamove.c:          q = r->back;
dnamove.c:        r = r->next;
dnamove.c:      first = p->next->back;
dnamove.c:      r = p->next;
dnamove.c:      while (r->next != p)
dnamove.c:        r = r->next;
dnamove.c:      last = r->back;
dnamove.c:    n = p->xcoord - q->xcoord;
dnamove.c:    if (n < 3 && !q->tip)
dnamove.c:      n--;
dnamove.c:    if (q->ycoord == i && !done)
dnamove.c:      else if ((long)q->ycoord == (long)p->ycoord)
dnamove.c:        switch (q->state)
dnamove.c:        grwrite(c, n - 3, &pos);
dnamove.c:      if (q->index >= 100)
dnamove.c:        nnwrite(q->index, 3, &pos, leftedge, screenwidth);
dnamove.c:      else if (q->index >= 10)
dnamove.c:        nnwrite(q->index, 2, &pos, leftedge, screenwidth);
dnamove.c:        nnwrite(q->index, 1, &pos, leftedge, screenwidth);
dnamove.c:    else if (!q->tip)
dnamove.c:      if (last->ycoord > i && first->ycoord < i && i != p->ycoord)
dnamove.c:        if (i < p->ycoord)
dnamove.c:          st = p->next->back->state;
dnamove.c:          st = p->next->next->back->state;
dnamove.c:        chwrite(' ', n - 1, &pos, leftedge, screenwidth);
dnamove.c:  if (p->ycoord == i && p->tip)
dnamove.c:      if (nayme[p->index - 1][j - 1] != '\0')
dnamove.c:      chwrite(nayme[p->index - 1][j], 1, &pos, leftedge, screenwidth);
dnamove.c:    nuroot = curtree->root;
dnamove.c:    curtree->evaluate(curtree, curtree->root, 0);
dnamove.c:    dow--;
dnamove.c:    printf("%10.1f Steps", -like);
dnamove.c:    if (-like < bestyet)
dnamove.c:      bestyet = -like;
dnamove.c:    else if (fabs(-like - bestyet) < 0.000001)
dnamove.c:      if (-like < gotlike)
dnamove.c:      else if (-like > gotlike)
dnamove.c:  treelines = tipy - dow;
dnamove.c:    printf("** %ld lines above screen **\n", topedge - 1);
dnamove.c:  if ((treelines - topedge + 1) > (screenlines - vmargin))
dnamove.c:    if (i >= topedge && i < topedge + screenlines - vmargin)
dnamove.c:  if ((treelines - topedge + 1) > (screenlines - vmargin))
dnamove.c:    printf("** %ld", treelines - (topedge - 1 + screenlines - vmargin));
dnamove.c:  if (treelines - topedge + vmargin + 1 < screenlines)
dnamove.c:  gotlike = -like;
dnamove.c:  curtree->root = curtree->nodep[0];
dnamove.c:  hookup(curtree->nodep[0], curtree->nodep[1]);
dnamove.c:    curtree->insert_(curtree, curtree->nodep[i - 1], curtree->nodep[i - 2], false, false);
dnamove.c:  curtree->root = curtree->nodep[0];
dnamove.c:  hookup(curtree->nodep[0], curtree->nodep[1]);
dnamove.c:      putchar(nayme[i - 1][j]);
dnamove.c:      ok = (ok && ((j >= 1 && j < i) || (j > spp && j < spp + i - 1)));
dnamove.c:    if (j >= i)   /* has user chosen a non-tip? if so, offer choice */
dnamove.c:        if (!curtree->nodep[j - 1]->tip)
dnamove.c:          add_child(curtree->nodep[j - 1], curtree->nodep[i - 1]);
dnamove.c:        printf("dnamove_add(below %ld, newtip %ld, newfork %ld)\n", j-1, i-1, spp+i-2);
dnamove.c:        curtree->insert_(curtree, curtree->nodep[i-1], curtree->nodep[j-1], false, false);
dnamove.c:      /* Open in binary: ftell() is broken for UNIX line-endings under WIN32 */
dnamove.c:      treeread(curtree, intree, &curtree->root, curtree->nodep, &goteof, &firsttree, &nextnode, &haslengths, initparsnode, true, nonodes);
dnamove.c:        p = curtree->nodep[i];
dnamove.c:          ((dnapars_node*)p)->base = (baseptr)Malloc(chars * sizeof(long));
dnamove.c:          p = p->next;
dnamove.c:    if (curtree->root->tip)
dnamove.c:      outgrno = curtree->root->index;
dnamove.c:      outgrno = curtree->root->next->back->index;
dnamove.c:    dnamove_reroot(curtree->nodep[outgrno - 1]);
dnamove.c:          // RSGdebug: Potential infinite loop.  When crashing on memory-protection, j has value 9005.
dnamove.c:          done = (done && (((dnapars_node*)curtree->nodep[k - 1])->base[i] & sett[j - 1]) != 0);
dnamove.c:  start = curtree->nodep[index - 1];
dnamove.c:  q = start->next;
dnamove.c:    q = q->next;
dnamove.c:    r->next = NULL; // FIXME: is garbage collection needed?
dnamove.c:  q->next = NULL; // FIXME: is garbage collection needed?
dnamove.c:    r = curtree->nodep[i - 1];
dnamove.c:    if (!(r->tip))
dnamove.c:      r->index--;
dnamove.c:    if (!(r->tip))
dnamove.c:      q = r->next;
dnamove.c:        q->index--;
dnamove.c:        q = q->next;
dnamove.c:    curtree->nodep[i - 1] = curtree->nodep[i];
dnamove.c:  nonodes--;
dnamove.c:  ok1 = (ok1 && i >= 1 && i <= (spp * 2 - 1) && i != curtree->root->index);
dnamove.c:    ok1 = !curtree->nodep[i - 1]->deleted;
dnamove.c:    ok2 = (ok2 && j >= 1 && j <= (spp * 2 - 1));
dnamove.c:      if (j != curtree->root->index)
dnamove.c:        ok2 = !curtree->nodep[curtree->nodep[j - 1]->back->index - 1]->deleted;
dnamove.c:      ok2 = (nodep[j - 1] != nodep[nodep[i - 1]->back->index - 1]);
dnamove.c:      p = curtree->nodep[j - 1];
dnamove.c:      while (p != curtree->root)
dnamove.c:        ok2 = (ok2 && p != curtree->nodep[i - 1]);
dnamove.c:        p = curtree->nodep[p->back->index - 1];
dnamove.c:            exxit(-1);
dnamove.c:          if (!(curtree->nodep[j - 1]->deleted) && !curtree->nodep[j - 1]->tip)
dnamove.c:            curtree->copy(curtree, treesets[othertree]);
dnamove.c:            curtree->re_move(curtree, curtree->nodep[i - 1], &q, false);
dnamove.c:            add_child(curtree->nodep[j - 1], curtree->nodep[i - 1]);
dnamove.c:              consolidatetree(q->index);
dnamove.c:          if (j != curtree->root->index) /* can't insert at root */
dnamove.c:            curtree->copy(curtree, treesets[othertree]);
dnamove.c:            curtree->re_move(curtree, curtree->nodep[i-1], &q, true);
dnamove.c:              curtree->nodep[q->index-1]->next->back = curtree->nodep[i-1];
dnamove.c:              curtree->nodep[i-1]->back = curtree->nodep[q->index-1]->next;
dnamove.c:            add_before(curtree->nodep[j - 1], curtree->nodep[i - 1]);
dnamove.c:  } while (!(necsteps[dispchar - 1] != numsteps[dispchar - 1] ||
dnamove.c:  dispchar--;
dnamove.c:  curtree->insert_(curtree, *item, p, false, false);
dnamove.c:  curtree->evaluate(curtree, curtree->root, 0);
dnamove.c:  place[p->index - 1] = -like;
dnamove.c:  curtree->re_move(curtree, *item, nufork, false);
dnamove.c:  if (!p->tip)
dnamove.c:    q = p->next;
dnamove.c:      addpreorder(q->back, item, nufork, place);
dnamove.c:      q = q->next;
dnamove.c:  if (!(ok && i >= 1 && i <= nonodes && i != curtree->root->index))
dnamove.c:  curtree->copy(curtree, treesets[othertree]);
dnamove.c:    place[j] = -1.0;
dnamove.c:  curtree->evaluate(curtree, curtree->root, 0);
dnamove.c:  current = -like;
dnamove.c:  q = curtree->nodep[curtree->nodep[i - 1]->back->index - 1];
dnamove.c:  saveparent = q->index;
dnamove.c:  if (q->next->back->index == i)
dnamove.c:    fromwhere = q->next->next->back->index;
dnamove.c:    fromwhere = q->next->back->index;
dnamove.c:  rute = curtree->root;
dnamove.c:  if (q->next->next->next == q)
dnamove.c:    if (curtree->root == curtree->nodep[curtree->nodep[i - 1]->back->index - 1])
dnamove.c:      /* if i is left child then rute becomes right child, and vice-versa */
dnamove.c:      if (curtree->nodep[curtree->nodep[i - 1]->back->index - 1]->next->back == curtree->nodep[i - 1])
dnamove.c:        rute = curtree->nodep[curtree->nodep[i - 1]->back->index - 1]->next->next->back;
dnamove.c:        rute = curtree->nodep[curtree->nodep[i - 1]->back->index - 1]->next->back;
dnamove.c:  curtree->re_move(curtree, curtree->nodep[i-1], &dummy, false);
dnamove.c:    curtree->get_forkring(curtree);
dnamove.c:  curtree->root = rute;
dnamove.c:  addpreorder(curtree->root, curtree->nodep[i - 1], dummy, place);
dnamove.c:    add_child(curtree->nodep[saveparent - 1], curtree->nodep[i - 1]);
dnamove.c:    nonodes--;
dnamove.c:    curtree->insert_(curtree, curtree->nodep[what - 1], curtree->nodep[fromwhere- 1], true, false);
dnamove.c:  like = -current;
dnamove.c:    if (place[j - 1] < current && place[j - 1] >= 0.0)
dnamove.c:      printf("%3ld:%6.2f", j, place[j - 1]);
dnamove.c:    if (fabs(place[j - 1] - current) < 1.0e-6 && j != fromwhere)
dnamove.c:  treeout(curtree->root, 1, &col, curtree->root);
dnamove.c:      nuroot = curtree->nodep[i - 1];
dnamove.c:      nuroot = curtree->root;
dnamove.c:  if (p->tip)
dnamove.c:  q = p->next;
dnamove.c:    if (q->next->next == p)
dnamove.c:      r = q->next;
dnamove.c:    q = q->next;
dnamove.c:    lprev->next = r;
dnamove.c:    rprev->next = l;
dnamove.c:    temp = r->next;
dnamove.c:    r->next = l->next;
dnamove.c:    l->next = temp;
dnamove.c:    if (i < (loopcount - 1))
dnamove.c:      q = p->next;
dnamove.c:        if (q == lprev->next && !lprevflag)
dnamove.c:          l = q->next;
dnamove.c:        if (q->next == rprev)
dnamove.c:          r = q->next;
dnamove.c:        q = q->next;
dnamove.c:    q = p->next;
dnamove.c:      fliptrav(q->back, true);
dnamove.c:      q = q->next;
dnamove.c:  /* flip at a node left-right */
dnamove.c:    curtree->copy(curtree, treesets[othertree]);
dnamove.c:    fliptrav(curtree->nodep[i - 1], true);
dnamove.c:          i != curtree->root->index);
dnamove.c:  curtree->copy(curtree, treesets[othertree]);
dnamove.c:  dnamove_reroot(curtree->nodep[outgrno - 1]);
dnamove.c:    printf("NEXT? (Options: R # + - S . T U W O F H J K L C ? X Q) ");
dnamove.c:    if (strchr("HJKLCFORSTUXQ+#-.W?", ch) != NULL)
dnamove.c:        case '-':
dnamove.c:    if (curtree->nodep[i]==NULL)
dnamove.c:  bestyet = -like;
dnamove.c:  gotlike = -like;
dnapars.c:/* Version 4.0 (c) Copyright 1993-2013 by the University of Washington.
dnapars.c:extern long nextree;    /* parsimony.c -- for counting stored trees */
dnapars.c:      printf("  .  Use dot-differencing to display them  %s\n",
dnapars.c:    bestrees[i - 1].btree = (long *)Malloc(nonodes * sizeof(long));
dnapars.c:    alias[i - 1] = i;
dnapars.c:    oldweight[i - 1] = weight[i - 1];
dnapars.c:    ally[i - 1] = i;
dnapars.c:    if (ally[i - 1] == i)
dnapars.c:    location[alias[i - 1] - 1] = i;
dnapars.c:    fprintf(outfile, "\nrequires a total of %10.3f\n", -(curtree->score));
dnapars.c:    fprintf(outfile, "  -------      ---       ------\n");
dnapars.c:    printbranchlengths(curtree->root);
dnapars.c:    treeout3(curtree->root, nextree, &col, curtree->root);
dnapars.c:          sprintf(progbuf, "-");
dnapars.c:      long missedCount = nextree - 1 - maxtrees;
dnapars.c:        reroot(curtree->nodep[outgrno - 1], curtree->root);
dnapars.c:        curtree->evaluate(curtree, curtree->root, false);
dnapars.c:        curtree->root = root_tree(curtree, curtree->root);
dnapars.c:        curtree->nodep[curtree->root->index - 1] = curtree->root;
dnapars.c:        dna_treelength(curtree->root, chars, curtree->nodep);
dnapars.c:        reroot_tree(curtree, curtree->root);                // RSGbugfix: Name change.
dnapars.c:    /* Open in binary: ftell() is broken for UNIX line-endings under WIN32 */
dnapars.c:      exxit(-1);
dnapars.c:      fprintf(outfile, "User-defined tree");
dnapars.c:      fsteps[j - 1] = (long *)Malloc(endsite * sizeof(long));
dnapars.c:      treeread(curtree, intree, &curtree->root, curtree->nodep, &goteof, &firsttree, &nextnode, &haslengths, initparsnode, false, nonodes);
dnapars.c:      reroot_tree(curtree, curtree->root);                // RSGbugfix: Name change.
dnapars.c:      curtree->evaluate(curtree, curtree->root, false);
dnapars.c:      curtree->root = root_tree(curtree, curtree->root);
dnapars.c:        reroot(curtree->nodep[outgrno - 1], curtree->root);
dnapars.c:      dna_treelength(curtree->root, chars, curtree->nodep);
dnapars.c:      free(fsteps[j - 1]);
dnapars.c:    free(bestrees[i - 1].btree);
dnapars.c:  curtree->free(curtree);
dnaparsimony.c:/* Version 4.0. (c) Copyright 1993-2013 by the University of Washington.
dnaparsimony.c:  t->evaluate = dnapars_tree_evaluate;
dnaparsimony.c:  t->nuview = dnapars_tree_nuview;
dnaparsimony.c:  ((pars_tree*)t)->branchcollapsible = dna_branchcollapsible;
dnaparsimony.c:  n->copy = dnapars_node_copy;
dnaparsimony.c:  n->init = dnapars_node_init;
dnaparsimony.c:  n->reinit = dnapars_node_reinit;
dnaparsimony.c:  n->free = dnapars_node_free;
dnaparsimony.c:  if (dn->base)
dnaparsimony.c:    free(dn->base);
dnaparsimony.c:  dn->base = Malloc(endsite * sizeof(long));
dnaparsimony.c:  if (dn->numnuc) free(dn->numnuc);
dnaparsimony.c:  dn->numnuc = Malloc(endsite * sizeof(nucarray));
dnaparsimony.c:  if (dn->base)
dnaparsimony.c:    free(dn->base);
dnaparsimony.c:  dn->base = Malloc(endsite * sizeof(long));
dnaparsimony.c:  if (dn->numnuc)
dnaparsimony.c:    free(dn->numnuc);
dnaparsimony.c:  dn->numnuc = Malloc(endsite * sizeof(nucarray));
dnaparsimony.c:  free(dp->base);
dnaparsimony.c:  free(dp->numnuc);
dnaparsimony.c:  if (dst->base == NULL )
dnaparsimony.c:    dst->base = Malloc(endsite * sizeof(long));
dnaparsimony.c:    dst->numnuc = Malloc(endsite * sizeof(nucarray));
dnaparsimony.c:  memcpy(dst->base, src->base, endsite * sizeof(long));
dnaparsimony.c:  memcpy(dst->numnuc, src->numnuc, endsite * sizeof(nucarray));
dnaparsimony.c:      p->cumlengths[i] = 0;
dnaparsimony.c:      p->numreconst[i] = 1;
dnaparsimony.c:      if (p->base[sitei - 1] & (1 << i))
dnaparsimony.c:        p->cumlengths[i] = 0;
dnaparsimony.c:        p->numreconst[i] = 1;
dnaparsimony.c:        p->cumlengths[i] = -1;
dnaparsimony.c:        p->numreconst[i] = 0;
dnaparsimony.c:      if (((dnapars_node*)desc)->cumlengths[j] == -1)
dnaparsimony.c:        desclen = ((dnapars_node*)desc)->cumlengths[j];
dnaparsimony.c:        descrecon += ((dnapars_node*)desc)->numreconst[j];
dnaparsimony.c:    ((dnapars_node*)p)->cumlengths[i] += minn;
dnaparsimony.c:    ((dnapars_node*)p)->numreconst[i] *= descrecon;
dnaparsimony.c:  p->initialized = true;
dnaparsimony.c:  if (subtr1->tip)
dnaparsimony.c:  if (subtr1->index == outgrno)
dnaparsimony.c:      if (((dnapars_node*)subtr1)->cumlengths[i] != -1 &&
dnaparsimony.c:          (((dnapars_node*)subtr2)->cumlengths[j] != -1))
dnaparsimony.c:        if (((dnapars_node*)subtr1)->cumlengths[i] +
dnaparsimony.c:            cost + ((dnapars_node*)subtr2)->cumlengths[j] < minn)
dnaparsimony.c:          minn = ((dnapars_node*)subtr1)->cumlengths[i] + cost +
dnaparsimony.c:            ((dnapars_node*)subtr2)->cumlengths[j];
dnaparsimony.c:        if (((dnapars_node*)subtr1)->cumlengths[i] + cost +
dnaparsimony.c:            ((dnapars_node*)subtr2)->cumlengths[j] == minn)
dnaparsimony.c:          nom += ((dnapars_node*)subtr1)->numreconst[i] *
dnaparsimony.c:            ((dnapars_node*)subtr2)->numreconst[j] * cost;
dnaparsimony.c:          denom += ((dnapars_node*)subtr1)->numreconst[i] *
dnaparsimony.c:            ((dnapars_node*)subtr2)->numreconst[j];
dnaparsimony.c:  if (p->tip)
dnaparsimony.c:    p->initialized = true;
dnaparsimony.c:  q = p->next;
dnaparsimony.c:    inittreetrav(q->back, sitei);
dnaparsimony.c:    q = q->next;
dnaparsimony.c:  p->initialized = false;
dnaparsimony.c:  q = p->next;
dnaparsimony.c:    q->initialized = false;
dnaparsimony.c:    q = q->next;
dnaparsimony.c:  /* traverses an n-ary tree, computing minimum steps at each node */
dnaparsimony.c:  if (p->tip)
dnaparsimony.c:  q = p->next;
dnaparsimony.c:    if (q->back)
dnaparsimony.c:      minpostorder(q->back, treenode);
dnaparsimony.c:    q = q->next;
dnaparsimony.c:  if (!p->initialized)
dnaparsimony.c:    q = p->next;
dnaparsimony.c:      if (q->back)
dnaparsimony.c:        dna_compmin(p, q->back);
dnaparsimony.c:      q = q->next;
dnaparsimony.c:  if (p->tip)
dnaparsimony.c:  if (p->index == outgrno)
dnaparsimony.c:    p = p->back;
dnaparsimony.c:  q = p->next;
dnaparsimony.c:    if (q->back)
dnaparsimony.c:      branchlength(q, q->back, brlen, treenode);
dnaparsimony.c:      q->v += (weight[sitei - 1] * (*brlen)/chars);
dnaparsimony.c:      q->back->v += (weight[sitei - 1] * (*brlen)/chars);
dnaparsimony.c:      if (!q->back->tip)
dnaparsimony.c:        branchlentrav(q->back, root, sitei, chars, brlen, treenode);
dnaparsimony.c:    q = q->next;
dnaparsimony.c:  if (p->tip)
dnaparsimony.c:  q = p->next;
dnaparsimony.c:    if (q->back)
dnaparsimony.c:      memcpy(((dnapars_node*)q)->numnuc, ((dnapars_node*)p)->numnuc, endsite * sizeof(nucarray));
dnaparsimony.c:        if (((dnapars_node*)q->back)->base[sitei - 1] & (1 << i))
dnaparsimony.c:          ((dnapars_node*)q)->numnuc[sitei - 1][i]--;
dnaparsimony.c:      if (p->back)
dnaparsimony.c:          if (((dnapars_node*)p->back)->base[sitei - 1] & (1 << i))
dnaparsimony.c:            ((dnapars_node*)q)->numnuc[sitei - 1][i]++;
dnaparsimony.c:      largest = dna_getlargest(((dnapars_node*)q)->numnuc[sitei - 1]);
dnaparsimony.c:      ((dnapars_node*)q)->base[sitei - 1] = 0;
dnaparsimony.c:        if (((dnapars_node*)q)->numnuc[sitei - 1][i] == largest)
dnaparsimony.c:          ((dnapars_node*)q)->base[sitei - 1] |= (1 << i);
dnaparsimony.c:    q = q->next;
dnaparsimony.c:  q = p->next;
dnaparsimony.c:    dna_initbase(q->back, sitei);
dnaparsimony.c:    q = q->next;
dnaparsimony.c:  if (!Vars.r->tip)
dnaparsimony.c:    memset(((dnapars_node*)Vars.r)->numnuc, 0, endsite * sizeof(nucarray));
dnaparsimony.c:  for (i = b1 - 1; i < b2; i++)
dnaparsimony.c:    j = location[ally[i] - 1];
dnaparsimony.c:    Vars.anc = Vars.hypset[j - 1];
dnaparsimony.c:    if (!Vars.r->tip)
dnaparsimony.c:      p = Vars.r->next;
dnaparsimony.c:          ((dnapars_node*)Vars.r)->numnuc[j - 1][k]++;
dnaparsimony.c:          if (((dnapars_node*)p->back)->base[j - 1] & (1 << k))
dnaparsimony.c:            ((dnapars_node*)Vars.r)->numnuc[j - 1][k]++;
dnaparsimony.c:        p = p->next;
dnaparsimony.c:      largest = dna_getlargest(((dnapars_node*)Vars.r)->numnuc[j - 1]);
dnaparsimony.c:        if (((dnapars_node*)Vars.r)->numnuc[j - 1][k] == largest)
dnaparsimony.c:      ((dnapars_node*)Vars.r)->base[j - 1] = Vars.tempset;
dnaparsimony.c:      Vars.anc = ((dnapars_node*)t->nodep[Vars.r->back->index - 1])
dnaparsimony.c:        ->base[j - 1];
dnaparsimony.c:    Vars.nonzero = (Vars.nonzero || (((dnapars_node*)Vars.r)->base[j - 1] & Vars.anc) == 0);
dnaparsimony.c:    Vars.maybe = (Vars.maybe || ((dnapars_node*)Vars.r)->base[j - 1] != Vars.anc);
dnaparsimony.c:  if (!Vars.r->tip)
dnaparsimony.c:    memcpy(tempnuc, ((dnapars_node*)Vars.r)->numnuc, endsite * sizeof(nucarray));
dnaparsimony.c:    q = Vars.r->next;
dnaparsimony.c:      memcpy(((dnapars_node*)Vars.r)->numnuc, tempnuc, endsite * sizeof(nucarray));
dnaparsimony.c:      for (i = b1 - 1; i < b2; i++)
dnaparsimony.c:        j = location[ally[i] - 1];
dnaparsimony.c:          if (((dnapars_node*)q->back)->base[j - 1] & (1 << k))
dnaparsimony.c:            ((dnapars_node*)Vars.r)->numnuc[j - 1][k]--;
dnaparsimony.c:        largest = dna_getlargest(((dnapars_node*)Vars.r)->numnuc[j - 1]);
dnaparsimony.c:        ancset[j - 1] = 0;
dnaparsimony.c:          if (((dnapars_node*)Vars.r)->numnuc[j - 1][k] == largest)
dnaparsimony.c:            ancset[j - 1] |= (1 << k);
dnaparsimony.c:          Vars.anc = ancset[j - 1];
dnaparsimony.c:      dna_hyptrav(t, q->back, ancset, b1, b2, Vars.bottom, basechar);
dnaparsimony.c:      q = q->next;
dnaparsimony.c:  for (i = 1; i <= ((chars - 1) / 40 + 1); i++)
dnaparsimony.c:    dna_hyptrav(t, t->root, nothing, i * 40 - 39, n, true, basechar);
dnaparsimony.c:  if (htrav->bottom)
dnaparsimony.c:    fprintf(outfile, "%4ld   ", htrav->r->back->index - spp);
dnaparsimony.c:  if (htrav->r->tip)
dnaparsimony.c:      putc(nayme[htrav->r->index - 1][i], outfile);
dnaparsimony.c:    fprintf(outfile, "%4ld      ", htrav->r->index - spp);
dnaparsimony.c:  if (htrav->bottom)
dnaparsimony.c:  else if (htrav->nonzero)
dnaparsimony.c:  else if (htrav->maybe)
dnaparsimony.c:    j = location[ally[i - 1] - 1];
dnaparsimony.c:    htrav->tempset = ((dnapars_node*)htrav->r)->base[j - 1];
dnaparsimony.c:    htrav->anc = htrav->hypset[j - 1];
dnaparsimony.c:    if (!htrav->bottom)
dnaparsimony.c:      htrav->anc = ((dnapars_node*)t->nodep[htrav->r->back->index - 1])->base[j - 1];
dnaparsimony.c:    dot = dotdiff && (htrav->tempset == htrav->anc && !htrav->bottom);
dnaparsimony.c:    else if (htrav->tempset == (1 << A))
dnaparsimony.c:    else if (htrav->tempset == (1 << C))
dnaparsimony.c:    else if (htrav->tempset == (1 << G))
dnaparsimony.c:    else if (htrav->tempset == (1 << T))
dnaparsimony.c:    else if (htrav->tempset == (1 << O))
dnaparsimony.c:      putc('-', outfile);
dnaparsimony.c:        if (((1 << b) & htrav->tempset) != 0)
dnaparsimony.c:      putc(basechar[n - 1], outfile);
dnaparsimony.c:  dnapars_node* q = (dnapars_node*)n->back;
dnaparsimony.c:    steps = ((pars_node*)p)->numsteps[i] + ((pars_node*)q)->numsteps[i];
dnaparsimony.c:    base1 = p->base[i];
dnaparsimony.c:    base2 = q->base[i];
dnaparsimony.c:    if ( ((pars_tree*)t)->supplement)
dnaparsimony.c:      steps += ((pars_tree*)t)->supplement(t, i);
dnaparsimony.c:      fsteps[which - 1][i] = term;
dnaparsimony.c:    nsteps[which - 1] = sum;
dnaparsimony.c:  t->score = -sum;
dnaparsimony.c:  return t->score;
dnaparsimony.c:    for ( q = p->next ; q != p ; q = q->next )
dnaparsimony.c:      qback = (dnapars_node*)q->back;
dnaparsimony.c:      base1 = qback->base[i];
dnaparsimony.c:      steps += ((pars_node*)qback)->numsteps[i];
dnaparsimony.c:          for ( q = p->next ; q != p ; q = q->next )
dnaparsimony.c:            qback = (dnapars_node*) q->back;
dnaparsimony.c:            if ( qback->base[i] & (1 << j) )
dnaparsimony.c:        steps += (weight[i]) * (count_sibs(p) - largest - root);
dnaparsimony.c:        newbase = ((dnapars_node*)p->next->back)->base[i] | ((dnapars_node*)p->next->next->back)->base[i];
dnaparsimony.c:    ((dnapars_node*)p)->base[i] = newbase;
dnaparsimony.c:    ((pars_node*)p)->numsteps[i] = steps;
dnaparsimony.c:  p->initialized = true;
dnaparsimony.c:  if ( n->tip == true || n->back->tip == true )
dnaparsimony.c:  q = n->back;
dnaparsimony.c:  if ( q->initialized == false ) t->nuview(t, q);
dnaparsimony.c:  if ( n->initialized == false ) t->nuview(t, n);
dnaparsimony.c:    if ( (((dnapars_node*)q)->base[i] & ((dnapars_node*)n)->base[i] ) == 0)
dnaparsimony.c:      switch (inputSequences[i][alias[j] - 1])
dnaparsimony.c:        case '-':
dnaparsimony.c:      ((dnapars_node*)t->nodep[i])->base[j] = ns;
dnaparsimony.c:      ((pars_node*)t->nodep[i])->numsteps[j] = 0;
dnapenny.c:/* Version 4.0. (c) Copyright 1993-2013 by the University of Washington.
dnapenny.c:  t->try_insert_ = dnapenny_tree_try_insert_;
dnapenny.c:  ((pars_tree*)t)->supplement = dnapenny_supplement;
dnapenny.c:      j = i - gap;
dnapenny.c:        if (a[j - 1] > a[j + gap - 1])
dnapenny.c:          rtemp = a[j - 1];
dnapenny.c:          a[j - 1] = a[j + gap - 1];
dnapenny.c:          a[j + gap - 1] = rtemp;
dnapenny.c:          itemp = b[j - 1];
dnapenny.c:          b[j - 1] = b[j + gap - 1];
dnapenny.c:          b[j + gap - 1] = itemp;
dnapenny.c:        j -= gap;
dnapenny.c:    printf(" branch-and-bound to find all most parsimonious trees\n\n");
dnapenny.c:    bestorders[i - 1].btree = (long*)Malloc(spp * sizeof(long));
dnapenny.c:  fprintf(outfile, " branch-and-bound to find all");
dnapenny.c:    alias[i - 1] = i;
dnapenny.c:    oldweight[i - 1] = weight[i - 1];
dnapenny.c:    ally[i - 1] = i;
dnapenny.c:    if (ally[i - 1] == i)
dnapenny.c:    location[alias[i - 1] - 1] = i;
dnapenny.c:  long m = ((dnapenny_tree*)t)->m;
dnapenny.c:  if ( simple && supplement_cache[m - 1] == true )
dnapenny.c:    return supplements[m - 1][i];
dnapenny.c:    supplements[m-1][j] = calculate_supplement(j);
dnapenny.c:  supplement_cache[m - 1] = true;
dnapenny.c:  return supplements[m - 1][i];
dnapenny.c:    has = (((dnapars_node*)curtree->nodep[k])->base[i]);
dnapenny.c:  if (true ||((dnapenny_tree*)t)->m <= 2 )
dnapenny.c:    if ( p->back == NULL )
dnapenny.c:      t->insert_(t, item, p, false, false);
dnapenny.c:      t->nodep[i]->initialized = false;
dnapenny.c:        t->nodep[i]->next->initialized = false;
dnapenny.c:        t->nodep[i]->next->next->initialized = false;
dnapenny.c:    ((dnapenny_tree*)t)->n++;
dnapenny.c:    like = t->evaluate(t, item, 0);
dnapenny.c:      t->re_move(t, item, &qwhere, false);
dnapenny.c:      t->root->back = NULL;
dnapenny.c:      item->back = NULL;
dnapenny.c:          sprintf(progbuf, "%16.1f", -*bestyet);
dnapenny.c:          sprintf(progbuf, "            -   ");
dnapenny.c:        sprintf(progbuf, "%17ld%20.2f\n", nextree - 1, fracdone * 100);
dnapenny.c:    ((dnapenny_tree*)t)->valyew[(((dnapenny_tree*)t)->n) - 1] = -like;
dnapenny.c:    ((dnapenny_tree*)t)->place[(((dnapenny_tree*)t)->n) - 1] = p;
dnapenny.c:  valyew = mvalyew[m-1];
dnapenny.c:  bestval = mbestval[m-1];
dnapenny.c:  place = mplace[m-1];
dnapenny.c:  bestplace = mbestplace[m-1];
dnapenny.c:    added[order[m-1] - 1] = true;
dnapenny.c:    dcurtree->valyew = valyew;
dnapenny.c:    dcurtree->place = place;
dnapenny.c:    dcurtree->n = n;
dnapenny.c:    curtree->addtraverse(curtree, curtree->nodep[order[m - 1] - 1], curtree->root, true, NULL, &bestyet, NULL, NULL, true, &multf);
dnapenny.c:    n = dcurtree->n;
dnapenny.c:    besttoadd = order[m - 1];
dnapenny.c:      if (!added[i - 1])
dnapenny.c:        added[i - 1] = true;
dnapenny.c:        dcurtree->m = m;
dnapenny.c:        dcurtree->valyew = valyew;
dnapenny.c:        dcurtree->place = place;
dnapenny.c:        dcurtree->n = n;
dnapenny.c:        curtree->addtraverse(curtree, curtree->nodep[i - 1], curtree->root, true, NULL, &bestyet, NULL, NULL, true, &multf);
dnapenny.c:        n = dcurtree->n;
dnapenny.c:        added[i - 1] = false;
dnapenny.c:          sum += -valyew[j];
dnapenny.c:  order[m - 1] = besttoadd;
dnapenny.c:    if (-valyew[i] >= bestyet || bestyet == UNDEFINED)
dnapenny.c:    if (-valyew[i] >= bestyet || bestyet > 0.0 )
dnapenny.c:      current[m - 1] = place[i];
dnapenny.c:      if ( place[i]->back == NULL )
dnapenny.c:        hookup(place[i], curtree->nodep[besttoadd - 1]);
dnapenny.c:        curtree->insert_(curtree, curtree->nodep[besttoadd - 1], place[i], true, false);
dnapenny.c:      added[besttoadd - 1] = true;
dnapenny.c:        if (-valyew[i] > bestyet || bestyet > 0.0)
dnapenny.c:          bestyet = -valyew[i];
dnapenny.c:          memcpy(bestorders[nextree - 1].btree, save, spp * sizeof(long));
dnapenny.c:        curtree->re_move(curtree, curtree->nodep[besttoadd - 1], &dum, true);
dnapenny.c:        curtree->nodep[besttoadd - 1]->back->back = NULL;
dnapenny.c:        curtree->nodep[besttoadd - 1]->back = NULL;
dnapenny.c:      added[besttoadd - 1] = false;
dnapenny.c:  if (outgroup->back->index == curtree->root->index)
dnapenny.c:  newbottom = outgroup->back;
dnapenny.c:  p = curtree->nodep[newbottom->index - 1]->back;
dnapenny.c:  while (p->index != curtree->root->index)
dnapenny.c:    oldbottom = curtree->nodep[p->index - 1];
dnapenny.c:    curtree->nodep[p->index - 1] = p;
dnapenny.c:    p = oldbottom->back;
dnapenny.c:  p = curtree->root->next;
dnapenny.c:  q = curtree->root->next->next;
dnapenny.c:  p->back->back = q->back;
dnapenny.c:  q->back->back = p->back;
dnapenny.c:  p->back = outgroup;
dnapenny.c:  q->back = outgroup->back;
dnapenny.c:  outgroup->back->back = curtree->root->next->next;
dnapenny.c:  outgroup->back = curtree->root->next;
dnapenny.c:  curtree->nodep[newbottom->index - 1] = newbottom;
dnapenny.c:    fprintf(outfile, "  -------      ---       ------\n");
dnapenny.c:    printbranchlengths(curtree->root);
dnapenny.c:    treeout3(curtree->root, nextree, &col, curtree->root);
dnapenny.c:    sprintf(progbuf, "----------     ------------     ------------       ------------\n");
dnapenny.c:  curtree->root = curtree->nodep[0];
dnapenny.c:  long missedCount = nextree - 1 - maxtrees;
dnapenny.c:    fprintf(outfile, "\nrequires a total of %18.3f\n\n", -bestyet );
dnapenny.c:    like = curtree->evaluate(curtree, curtree->root, 0);
dnapenny.c:    curtree->root = root_tree(curtree, curtree->nodep[outgrno - 1]->back);
dnapenny.c:    dna_treelength(curtree->root, chars, curtree->nodep);
dnapenny.c:    reroot_tree(curtree, curtree->root); // RSGbugfix: Name change.
dnapenny.c:{  /* Penny's branch-and-bound method for DNA sequences */
dnapenny.c:}  /* Penny's branch-and-bound method for DNA sequences */
dollo.c:/* Version 4.0. (c) Copyright 1993-2013 by the University of Washington.
dollo.c:  if (p->tip)
dollo.c:    if (p->back == NULL) {
dollo.c:      s0 = treenode[p->back->index - 1]->statezero[i];
dollo.c:      s1 = treenode[p->back->index - 1]->stateone[i];
dollo.c:    z0 = (s0 & p->statezero[i]) |
dollo.c:         (p->next->back->statezero[i] & p->next->next->back->statezero[i]);
dollo.c:    z1 = (s1 & p->stateone[i]) |
dollo.c:         (p->next->back->stateone[i] & p->next->next->back->stateone[i]);
dollo.c:    p->statezero[i] = z0 | (temp & s0 & (~s1));
dollo.c:    p->stateone[i] = z1 | (temp & s1 & (~s0));
dollo.c:    p->stateone[i] = p->next->back->stateone[i] | p->next->next->back->stateone[i];
dollo.c:    p->statezero[i] = p->next->back->statezero[i] | p->next->next->back->statezero[i];
dollo.c:  if (p->tip)
dollo.c:  postorder(p->next->back);
dollo.c:  postorder(p->next->next->back);
dollo.c:    if (((1L << l) & stps[j - 1]) != 0) {
dollo.c:      if (((1L << l) & zeroanc[j - 1]) != 0)
dollo.c:  if (r->tip)
dollo.c:  filltrav(r->next->back);
dollo.c:  filltrav(r->next->next->back);
dollo.c:  if (Hyptrav->bottom)
dollo.c:    fprintf(outfile, "%3ld    ", Hyptrav->r->back->index - spp);
dollo.c:  if (Hyptrav->r->tip) {
dollo.c:      putc(nayme[Hyptrav->r->index - 1][i], outfile);
dollo.c:    fprintf(outfile, "%4ld      ", Hyptrav->r->index - spp);
dollo.c:  if (Hyptrav->nonzero)
dollo.c:    k = (j - 1) / bits + 1;
dollo.c:    l = (j - 1) % bits + 1;
dollo.c:    dot = (((1L << l) & dohyp[k - 1]) == 0 && guess[j - 1] == '?');
dollo.c:    s0 = (((1L << l) & Hyptrav->r->statezero[k - 1]) != 0);
dollo.c:    s1 = (((1L << l) & Hyptrav->r->stateone[k - 1]) != 0);
dollo.c:    a0 = (((1L << l) & Hyptrav->zerobelow->bits_[k - 1]) != 0);
dollo.c:    a1 = (((1L << l) & Hyptrav->onebelow->bits_[k - 1]) != 0);
dollo.c:  if (!HypVars.r->tip)
dollo.c:  HypVars.bottom = (HypVars.r->back == NULL);
dollo.c:    memcpy(HypVars.zerobelow->bits_, zeroanc, words * sizeof(long));
dollo.c:    memcpy(HypVars.onebelow->bits_, oneanc, words * sizeof(long));
dollo.c:    memcpy(HypVars.zerobelow->bits_, treenode[HypVars.r->back->index - 1]->statezero, words * sizeof(long));
dollo.c:    memcpy(HypVars.onebelow->bits_, treenode[HypVars.r->back->index - 1]->stateone, words * sizeof(long));
dollo.c:                       ((HypVars.r->stateone[i] & HypVars.zerobelow->bits_[i])
dollo.c:                        | (HypVars.r->statezero[i]
dollo.c:                           & HypVars.onebelow->bits_[i])) != 0);
dollo.c:  if (!HypVars.r->tip)
dollo.c:    hyptrav(HypVars.r->next->back, unknown, dohyp, fullset, dollo, guess, treenode, garbage, zeroanc, oneanc);
dollo.c:    hyptrav(HypVars.r->next->next->back, unknown, dohyp, fullset, dollo, guess, treenode, garbage, zeroanc, oneanc);
dollo.c:      zeroanc[j - 1] = ((long)zeroanc[j - 1]) | (1L << k);
dollo.c:      oneanc[j - 1] = ((long)oneanc[j - 1]) | (1L << k);
dollo.c:  if (i == (long)p->ycoord && p == root) {
dollo.c:    if (p->index - spp >= 10)
dollo.c:      fprintf(outfile, "-%2ld", p->index - spp);
dollo.c:      fprintf(outfile, "--%ld", p->index - spp);
dollo.c:    if (!p->tip) {
dollo.c:      r = p->next;
dollo.c:        if (i >= r->back->ymin && i <= r->back->ymax) {
dollo.c:          q = r->back;
dollo.c:        r = r->next;
dollo.c:      first = p->next->back;
dollo.c:      r = p->next;
dollo.c:      while (r->next != p)
dollo.c:        r = r->next;
dollo.c:      last = r->back;
dollo.c:    n = (long)(scale * (p->xcoord - q->xcoord) + 0.5);
dollo.c:    if (n < 3 && !q->tip)
dollo.c:      n--;
dollo.c:    if ((long)q->ycoord == i && !done) {
dollo.c:      if (!q->tip) {
dollo.c:        for (j = 1; j <= n - 2; j++)
dollo.c:          putc('-', outfile);
dollo.c:        if (q->index - spp >= 10)
dollo.c:          fprintf(outfile, "%2ld", q->index - spp);
dollo.c:          fprintf(outfile, "-%ld", q->index - spp);
dollo.c:          putc('-', outfile);
dollo.c:    } else if (!p->tip) {
dollo.c:      if ((long)last->ycoord > i && (long)first->ycoord < i
dollo.c:          && i != (long)p->ycoord) {
dollo.c:  if ((long)p->ycoord == i && p->tip) {
dollo.c:      putc(nayme[p->index - 1][j], outfile);
dollo.c:  for (i = 1; i <= (tipy - down); i++)
dollo.c:  fprintf(outfile, "\n     *-----------------------------------------\n");
dollo.c:        fprintf(outfile, "%4ld", numsteps[k - 1] + extras[k - 1]);
dollop.c:/* Version 4.0. (c) Copyright 1993-2013 by the University of Washington.
dollop.c:      fsteps[i - 1] = (double *)Malloc(chars * sizeof(double));
dollop.c:      fsteps[i - 1] = (double *)Malloc(chars * sizeof(double));
dollop.c:    bestrees[i - 1].btree = (long *)Malloc(nonodes * sizeof(long));
dollop.c:  alloctree(&(curtree->nodep));
dollop.c:  setuptree(curtree->nodep);
dollop.c:    inputdata(curtree->nodep, dollo, printdata, outfile);
dollop.c:      steps[i] = (curtree->nodep[p->back->index - 1]->stateone[i] & p->statezero[i] & zeroanc[i]) | (curtree->nodep[p->back->index - 1]->statezero[i] & p->stateone[i] & fullset & (~zeroanc[i]));
dollop.c:      steps[i] = curtree->nodep[p->back->index - 1]->stateone[i] & curtree->nodep[p->back->index - 1]->statezero[i] & p->stateone[i] & p->statezero[i];
dollop.c:    if (((1L << l) & steps[j - 1]) != 0)
dollop.c:      if (((1L << l) & zeroanc[j - 1]) != 0)
dollop.c:  if (!p->tip)
dollop.c:    preorder(p->next->back, numsone, numszero, words, dollo, fullset, zeroanc, treenode);
dollop.c:    preorder(p->next->next->back, numsone, numszero, words, dollo, fullset, zeroanc, treenode);
dollop.c:  if (p->back != NULL)
dollop.c:      fsteps[which - 1][i] = term;
dollop.c:    nsteps[which - 1] = sum;
dollop.c:  like = -sum;
dollop.c:  place[curtree->root->index - 1] = 1;
dollop.c:    p = curtree->nodep[i - 1];
dollop.c:    while (place[p->index - 1] == 0)
dollop.c:      place[p->index - 1] = i;
dollop.c:      p = p->back;
dollop.c:        p = curtree->nodep[p->index - 1];
dollop.c:      place[i - 1] = place[p->index - 1];
dollop.c:      j = place[p->index - 1];
dollop.c:        place[p->index - 1] = spp + i - 1;
dollop.c:        p = curtree->nodep[p->index - 1];
dollop.c:        p = p->back;
dollop.c:          done = (place[p->index - 1] != j);
dollop.c:  for (i =nextree - 1; i >= (*pos); i--)
dollop.c:    memcpy(bestrees[i].btree, bestrees[i - 1].btree, spp * sizeof(long));
dollop.c:    bestrees[i].gloreange = bestrees[i - 1].gloreange;
dollop.c:    bestrees[i].locreange = bestrees[i - 1].locreange;
dollop.c:    bestrees[i].collapse = bestrees[i - 1].collapse;
dollop.c:    bestrees[(*pos) - 1].btree[i] = place[i];
dollop.c:  add(p, *item, *nufork, &(curtree->root), curtree->nodep);
dollop.c:  evaluate(curtree->root);
dollop.c:  re_move(item, nufork, &(curtree->root), curtree->nodep);
dollop.c:  if (!p->tip)
dollop.c:    addpreorder(p->next->back, item, nufork);
dollop.c:    addpreorder(p->next->next->back, item, nufork);
dollop.c:  if (p->back == NULL)
dollop.c:  forknode = curtree->nodep[p->back->index - 1];
dollop.c:  if (forknode->back == NULL)
dollop.c:  if (p->back->next->next == forknode)
dollop.c:    frombelow = forknode->next->next->back;
dollop.c:    frombelow = forknode->next->back;
dollop.c:  whereto = forknode->back;
dollop.c:  re_move(&p, &forknode, &(curtree->root), curtree->nodep);
dollop.c:  add(whereto, p, forknode, &(curtree->root), curtree->nodep);
dollop.c:    re_move(&p, &forknode, &(curtree->root), curtree->nodep);
dollop.c:    add(frombelow, p, forknode, &(curtree->root), curtree->nodep);
dollop.c:  if (!p->tip)
dollop.c:    repreorder(p->next->back, r, success);
dollop.c:    repreorder(p->next->next->back, r, success);
dollop.c:    fprintf(outfile, "\nrequires a total of %10.3f\n", -like);
dollop.c:    hypstates(fullset, dollo, guess, curtree->nodep, curtree->root, garbage, zeroanc, oneanc);
dollop.c:    treeout(curtree->root, nextree, &col, curtree->root);
dollop.c:      treep->nodep[nodei - 1] = *p;
dollop.c:      match_names_to_data (str, treep->nodep, p, spp);
dollop.c:  fullset = (1L << (bits + 1)) - (1L << 1);
dollop.c:      enterorder[i - 1] = i;
dollop.c:    curtree->root = curtree->nodep[enterorder[0] - 1];
dollop.c:    add(curtree->nodep[enterorder[0] - 1], curtree->nodep[enterorder[1] - 1], curtree->nodep[spp], &curtree->root, curtree->nodep);
dollop.c:      bestyet = -350.0 * spp * chars;
dollop.c:      item = curtree->nodep[enterorder[i - 1] - 1];
dollop.c:      nufork = curtree->nodep[spp + i - 2];
dollop.c:      addpreorder(curtree->root, item, nufork);
dollop.c:      add(there, item, nufork, &curtree->root, curtree->nodep);
dollop.c:      rearrange(&curtree->root);
dollop.c:        writename(i - 1, 1, enterorder);
dollop.c:              sprintf(progbuf, "-");
dollop.c:            bestyet = - 350.0 * spp * chars;
dollop.c:            item = curtree->nodep[j];
dollop.c:            if (item != curtree->root)
dollop.c:              nufork = curtree->nodep[j]->back;
dollop.c:              re_move(&item, &nufork, &curtree->root, curtree->nodep);
dollop.c:              there = curtree->root;
dollop.c:              addpreorder(curtree->root, item, nufork);
dollop.c:              add(there, item, nufork, &curtree->root, curtree->nodep);
dollop.c:    for (i = spp - 1; i >= 1; i--)
dollop.c:      re_move(&(curtree->nodep[i]), &dummy, &curtree->root, curtree->nodep);
dollop.c:          fprintf(outfile, "%6ld trees in all found\n", nextree - 1);
dollop.c:      for (i = 0; i <= (nextree - 2); i++)
dollop.c:        curtree->root = curtree->nodep[0];
dollop.c:        add(curtree->nodep[0], curtree->nodep[1], curtree->nodep[spp], &curtree->root, curtree->nodep);
dollop.c:          add(curtree->nodep[bestrees[i].btree[j - 1] - 1], curtree->nodep[j - 1], curtree->nodep[spp + j - 2], &curtree->root, curtree->nodep);}
dollop.c:        evaluate(curtree->root);
dollop.c:        printree(1.0, treeprint, curtree->root);
dollop.c:          re_move(&(curtree->nodep[j]), &dummy, &curtree->root, curtree->nodep);
dollop.c:    /* Open in binary: ftell() is broken for UNIX line-endings under WIN32 */
dollop.c:      exxit(-1);
dollop.c:      fprintf(outfile, "User-defined tree");
dollop.c:      treeread(curtree, intree, &(curtree->root), curtree->nodep, &goteof, &firsttree, &nextnode, &haslengths, initdollopnode, false, nonodes);
dollop.c:        p = curtree->nodep[i];
dollop.c:          p->stateone = (bitptr)Malloc(words * sizeof(long));
dollop.c:          p->statezero = (bitptr)Malloc(words * sizeof(long));
dollop.c:          p = p->next;
dollop.c:      evaluate(curtree->root);
dollop.c:      printree(1.0, treeprint, curtree->root);
dollop.c:  bits = 8 * sizeof(long) - 1;
dollop.c:  bits = 8 * sizeof(long) - 1;
dolmove.c:/* Version 4.0. (c) Copyright 1993-2013 by the University of Washington.
dolmove.c:unsigned char cha[(long)question - (long)horiz + 1];
dolmove.c:boolean reversed[(long)question - (long)horiz + 1];
dolmove.c:boolean graphic[(long)question - (long)horiz + 1];
dolmove.c:  alloctree(&(curtree->nodep));
dolmove.c:  setuptree(curtree->nodep);
dolmove.c:  inputdata(curtree->nodep, dollo, false, stdout);
dolmove.c:  /* configure to machine -- set up special characters */
dolmove.c:  cha[(long)overt] = '-';
dolmove.c:  if (p->tip)
dolmove.c:    if (p->back == NULL) {
dolmove.c:      s0 = curtree->nodep[p->back->index - 1]->statezero[i];
dolmove.c:      s1 = curtree->nodep[p->back->index - 1]->stateone[i];
dolmove.c:    z0 = (s0 & p->statezero[i]) | (p->next->back->statezero[i] & p->next->next->back->statezero[i]);
dolmove.c:    z1 = (s1 & p->stateone[i]) | (p->next->back->stateone[i] & p->next->next->back->stateone[i]);
dolmove.c:    p->statezero[i] = z0 | (temp & s0 & (~s1));
dolmove.c:    p->stateone[i] = z1 | (temp & s1 & (~s0));
dolmove.c:      steps[i] = (curtree->nodep[p->back->index - 1]->stateone[i] &
dolmove.c:                  p->statezero[i] & zeroanc[i]) |
dolmove.c:                 (curtree->nodep[p->back->index - 1]->statezero[i] &
dolmove.c:                  p->stateone[i] & oneanc[i]);
dolmove.c:      steps[i] = curtree->nodep[p->back->index - 1]->stateone[i] &
dolmove.c:                 curtree->nodep[p->back->index - 1]->statezero[i] & p->stateone[i] &
dolmove.c:                 p->statezero[i];
dolmove.c:    if (((1L << l) & steps[j - 1]) != 0) {
dolmove.c:      if (((1L << l) & zeroanc[j - 1]) != 0)
dolmove.c:  if (!p->tip) {
dolmove.c:    preorder(p->next->back);
dolmove.c:    preorder(p->next->next->back);
dolmove.c:  if (p->back != NULL)
dolmove.c:  like = -sum;
dolmove.c:  if (outgroup->back->index == curtree->root->index)
dolmove.c:  newbottom = outgroup->back;
dolmove.c:  p = curtree->nodep[newbottom->index - 1]->back;
dolmove.c:  while (p->index != curtree->root->index) {
dolmove.c:    oldbottom = curtree->nodep[p->index - 1];
dolmove.c:    curtree->nodep[p->index - 1] = p;
dolmove.c:    p = oldbottom->back;
dolmove.c:  onleft = (p == curtree->root->next);
dolmove.c:      p = curtree->root->next->next;
dolmove.c:      q = curtree->root->next;
dolmove.c:      p = curtree->root->next;
dolmove.c:      q = curtree->root->next->next;
dolmove.c:      oldoutgrno = curtree->root->next->next->back->index;
dolmove.c:      oldoutgrno = curtree->root->next->back->index;
dolmove.c:    p = curtree->root->next;
dolmove.c:    q = curtree->root->next->next;
dolmove.c:  p->back->back = q->back;
dolmove.c:  q->back->back = p->back;
dolmove.c:  p->back = outgroup;
dolmove.c:  q->back = outgroup->back;
dolmove.c:      outgroup->back->back = curtree->root->next;
dolmove.c:      outgroup->back = curtree->root->next->next;
dolmove.c:      outgroup->back->back = curtree->root->next->next;
dolmove.c:      outgroup->back = curtree->root->next;
dolmove.c:    outgroup->back->back = curtree->root->next->next;
dolmove.c:    outgroup->back = curtree->root->next;
dolmove.c:  curtree->nodep[newbottom->index - 1] = newbottom;
dolmove.c:  if (!r->tip)
dolmove.c:  if (((1L << dispbit) & r->stateone[dispword - 1]) != 0) {
dolmove.c:    if (((1L << dispbit) & r->statezero[dispword - 1]) != 0) {
dolmove.c:        r->state = '?';
dolmove.c:        r->state = 'P';
dolmove.c:      r->state = '1';
dolmove.c:    if (((1L << dispbit) & r->statezero[dispword - 1]) != 0)
dolmove.c:      r->state = '0';
dolmove.c:      r->state = '?';
dolmove.c:  if (!r->tip) {
dolmove.c:    dolmove_hyptrav(r->next->back);
dolmove.c:    dolmove_hyptrav(r->next->next->back);
dolmove.c:      zeroanc[j - 1] = ((long)zeroanc[j - 1]) | (1L << k);
dolmove.c:      oneanc[j - 1] = ((long)oneanc[j - 1]) | (1L << k);
dolmove.c:  filltrav(curtree->root);
dolmove.c:  dolmove_hyptrav(curtree->root);
dolmove.c:    if ((*pos) >= leftedge && (*pos) - leftedge + 1 < screenwidth)
dolmove.c:  if (i == (long)p->ycoord && (p == curtree->root || subtree)) {
dolmove.c:      if (p == curtree->root)
dolmove.c:        cc = guess[dispchar - 1];
dolmove.c:        cc = p->state;
dolmove.c:    if (p->index >= 100)
dolmove.c:      nnwrite(p->index, 3, &pos, leftedge, screenwidth);
dolmove.c:    else if (p->index >= 10) {
dolmove.c:      nnwrite(p->index, 2, &pos, leftedge, screenwidth);
dolmove.c:      nnwrite(p->index, 1, &pos, leftedge, screenwidth);
dolmove.c:    if (!p->tip) {
dolmove.c:      r = p->next;
dolmove.c:        if (i >= r->back->ymin && i <= r->back->ymax) {
dolmove.c:          q = r->back;
dolmove.c:        r = r->next;
dolmove.c:      first = p->next->back;
dolmove.c:      r = p->next;
dolmove.c:      while (r->next != p)
dolmove.c:        r = r->next;
dolmove.c:      last = r->back;
dolmove.c:    n = (long)p->xcoord - (long)q->xcoord;
dolmove.c:    if (n < 3 && !q->tip)
dolmove.c:      n--;
dolmove.c:    if ((long)q->ycoord == i && !done) {
dolmove.c:      if ((long)q->ycoord > (long)p->ycoord)
dolmove.c:      s = q->state;
dolmove.c:      if (s == 'P' && p->state != 'P')
dolmove.c:        s = p->state;
dolmove.c:        grwrite(c, n - 3, &pos);
dolmove.c:      if (q->index >= 100)
dolmove.c:        nnwrite(q->index, 3, &pos, leftedge, screenwidth);
dolmove.c:      else if (q->index >= 10) {
dolmove.c:        nnwrite(q->index, 2, &pos, leftedge, screenwidth);
dolmove.c:        nnwrite(q->index, 1, &pos, leftedge, screenwidth);
dolmove.c:    } else if (!q->tip) {
dolmove.c:      if ((long)last->ycoord > i && (long)first->ycoord < i
dolmove.c:          && i != (long)p->ycoord) {
dolmove.c:        if (i < (long)p->ycoord)
dolmove.c:          s = p->next->back->state;
dolmove.c:          s = p->next->next->back->state;
dolmove.c:        if (s == 'P' && p->state != 'P')
dolmove.c:          s = p->state;
dolmove.c:        chwrite(' ', n - 1, &pos, leftedge, screenwidth);
dolmove.c:  if ((long)p->ycoord == i && p->tip) {
dolmove.c:      if (nayme[p->index - 1][j - 1] != '\0')
dolmove.c:      chwrite(nayme[p->index - 1][j], 1, &pos, leftedge, screenwidth);
dolmove.c:    nuroot = curtree->root;
dolmove.c:    evaluate(curtree->root);
dolmove.c:    dow--;
dolmove.c:    printf("%10.1f Steps", -like);
dolmove.c:  printf("%-20s", dollo ? "Dollo" : "Polymorphism");
dolmove.c:    if (-like < bestyet) {
dolmove.c:      bestyet = -like;
dolmove.c:    } else if (fabs(-like - bestyet) < 0.000001)
dolmove.c:      if (-like < gotlike)
dolmove.c:      else if (-like > gotlike)
dolmove.c:  treelines = tipy - dow;
dolmove.c:    printf("** %ld lines above screen **\n", topedge - 1);
dolmove.c:  if ((treelines - topedge + 1) > (screenlines - vmargin))
dolmove.c:    if (i >= topedge && i < topedge + screenlines - vmargin)
dolmove.c:  if ((treelines - topedge + 1) > (screenlines - vmargin))
dolmove.c:           treelines - (topedge - 1 + screenlines - vmargin));
dolmove.c:  if (treelines - topedge + vmargin + 1 < screenlines)
dolmove.c:  gotlike = -like;
dolmove.c:  curtree->root = curtree->nodep[0];
dolmove.c:  add2(curtree->nodep[0], curtree->nodep[1], curtree->nodep[spp], &(curtree->root), restoring, wasleft, curtree->nodep);
dolmove.c:    add2(curtree->nodep[spp + i - 3], curtree->nodep[i - 1], curtree->nodep[spp + i - 2], &(curtree->root),
dolmove.c:      restoring, wasleft, curtree->nodep);
dolmove.c:  curtree->root = curtree->nodep[0];
dolmove.c:  add2(curtree->nodep[0], curtree->nodep[1], curtree->nodep[spp], &(curtree->root), restoring, wasleft, curtree->nodep);
dolmove.c:      putchar(nayme[i - 1][j]);
dolmove.c:      ok = (ok && ((j >= 1 && j < i) || (j > spp && j < spp + i - 1)));
dolmove.c:    add2(curtree->nodep[j - 1], curtree->nodep[i - 1], curtree->nodep[spp + i - 2], &(curtree->root),
dolmove.c:         restoring, wasleft, curtree->nodep);
dolmove.c:      *p = treep->get_forknode(treep, nodei);
dolmove.c:      treenode[nodei - 1] = *p;
dolmove.c:      *p = treep->get_forknode(treep, nodei);
dolmove.c:      /* Open in binary: ftell() is broken for UNIX line-endings under WIN32 */
dolmove.c:      treeread(curtree, intree, &(curtree->root), curtree->nodep, &goteof, &firsttree,
dolmove.c:        p = curtree->nodep[i];
dolmove.c:          p->stateone = (bitptr)Malloc(words * sizeof(long));
dolmove.c:          p->statezero = (bitptr)Malloc(words * sizeof(long));
dolmove.c:          p = p->next;
dolmove.c:  outgrno = curtree->root->next->back->index;
dolmove.c:  if (in_tree[outgrno - 1])
dolmove.c:    reroot(curtree->nodep[outgrno - 1]);
dolmove.c:  ok1 = (ok1 && i >= 1 && i < spp * 2 && i != curtree->root->index);
dolmove.c:      ok2 = (curtree->nodep[j - 1] != curtree->nodep[curtree->nodep[i - 1]->back->index - 1]);
dolmove.c:      p = curtree->nodep[j - 1];
dolmove.c:      while (p != curtree->root) {
dolmove.c:        ok2 = (ok2 && p != curtree->nodep[i - 1]);
dolmove.c:        p = curtree->nodep[p->back->index - 1];
dolmove.c:        q = curtree->nodep[curtree->nodep[i - 1]->back->index - 1];
dolmove.c:        if (q->next->back->index == i)
dolmove.c:          fromwhere = q->next->next->back->index;
dolmove.c:          fromwhere = q->next->back->index;
dolmove.c:        re_move2(&curtree->nodep[i - 1], &q, &(curtree->root), &wasleft, curtree->nodep);
dolmove.c:        add2(curtree->nodep[j - 1], curtree->nodep[i - 1], q, &(curtree->root), restoring, wasleft, curtree->nodep);
dolmove.c:  add2(p, *item, *nufork, &(curtree->root), restoring, wasleft, curtree->nodep);
dolmove.c:  evaluate(curtree->root);
dolmove.c:  place[p->index - 1] = -like;
dolmove.c:  re_move2(item, nufork, &(curtree->root), &wasleft, curtree->nodep);
dolmove.c:  if (!p->tip) {
dolmove.c:    addpreorder(p->next->back, item, nufork, place);
dolmove.c:    addpreorder(p->next->next->back, item, nufork, place);
dolmove.c:  if (!(ok && i >= 1 && i <= nonodes && i != curtree->root->index)) {
dolmove.c:    place[j] = -1.0;
dolmove.c:  evaluate(curtree->root);
dolmove.c:  current = -like;
dolmove.c:  q = curtree->nodep[curtree->nodep[i - 1]->back->index - 1];
dolmove.c:  if (q->next->back->index == i)
dolmove.c:    fromwhere = q->next->next->back->index;
dolmove.c:    fromwhere = q->next->back->index;
dolmove.c:  rute = curtree->root;
dolmove.c:  if (curtree->root->index == curtree->nodep[i - 1]->back->index) {
dolmove.c:    if (curtree->nodep[curtree->nodep[i - 1]->back->index - 1]->next->back == curtree->nodep[i - 1])
dolmove.c:      rute = curtree->nodep[curtree->nodep[i - 1]->back->index - 1]->next->next->back;
dolmove.c:      rute = curtree->nodep[curtree->nodep[i - 1]->back->index - 1]->next->back;
dolmove.c:  re_move2(&curtree->nodep[i - 1], &dummy, &(curtree->root), &wasleft, curtree->nodep);
dolmove.c:  curtree->root = rute;
dolmove.c:  addpreorder(curtree->root, curtree->nodep[i - 1], dummy, place);
dolmove.c:  add2(curtree->nodep[fromwhere - 1], curtree->nodep[what - 1], dummy, &(curtree->root),
dolmove.c:       restoring, wasleft, curtree->nodep);
dolmove.c:  like = -current;
dolmove.c:    if (place[j - 1] < current && place[j - 1] >= 0.0)
dolmove.c:      printf("%3ld:%6.2f", j, place[j - 1]);
dolmove.c:    if (fabs(place[j - 1] - current) < 1.0e-6 && j != fromwhere)
dolmove.c:      re_move2(&curtree->nodep[what - 1], &q, &(curtree->root), &wasleft, curtree->nodep);
dolmove.c:      add2(curtree->nodep[fromwhere - 1], curtree->nodep[what - 1], q, &(curtree->root),
dolmove.c:           restoring, wasleft, curtree->nodep);
dolmove.c:      q = curtree->nodep[atwhat - 1]->next->back;
dolmove.c:      curtree->nodep[atwhat - 1]->next->back =
dolmove.c:        curtree->nodep[atwhat - 1]->next->next->back;
dolmove.c:      curtree->nodep[atwhat - 1]->next->next->back = q;
dolmove.c:      curtree->nodep[atwhat - 1]->next->back->back = curtree->nodep[atwhat - 1]->next;
dolmove.c:      curtree->nodep[atwhat - 1]->next->next->back->back =
dolmove.c:        curtree->nodep[atwhat - 1]->next->next;
dolmove.c:      reroot(curtree->nodep[outgrno - 1]);
dolmove.c:  treeout(curtree->root, 1, &col, curtree->root);
dolmove.c:      nuroot = curtree->nodep[i - 1];
dolmove.c:      nuroot = curtree->root;
dolmove.c:  /* flip at a node left-right */
dolmove.c:    p = curtree->nodep[i - 1]->next->back;
dolmove.c:    curtree->nodep[i - 1]->next->back = curtree->nodep[i - 1]->next->next->back;
dolmove.c:    curtree->nodep[i - 1]->next->next->back = p;
dolmove.c:    curtree->nodep[i - 1]->next->back->back = curtree->nodep[i - 1]->next;
dolmove.c:    curtree->nodep[i - 1]->next->next->back->back = curtree->nodep[i - 1]->next->next;
dolmove.c:    ok = (ok && in_tree[i - 1] && i >= 1 && i <= nonodes &&
dolmove.c:          i != curtree->root->index);
dolmove.c:  if (in_tree[outgrno - 1])
dolmove.c:    reroot(curtree->nodep[outgrno - 1]);
dolmove.c:    printf("NEXT? (Options: R # + - S . T U W O F H J K L C ? X Q) ");
dolmove.c:    if (strchr("RSWH#.O?+TFX-UCQHJKL", ch) != NULL)
dolmove.c:        case '-':
dolmove.c:  fullset = (1L << (bits + 1)) - (1L << 1);
dolmove.c:  bestyet = -like;
dolmove.c:  gotlike = -like;
dolmove.c:  bits = 8 * sizeof(long) - 1;
dolpenny.c:/* Version 4.0. (c) Copyright 1993-2013 by the University of Washington.
dolpenny.c:    printf(" branch-and-bound to find all most parsimonious trees\n\n");
dolpenny.c:    bestorders[i - 1] = (long *)Malloc(spp * sizeof(long));
dolpenny.c:    bestrees[i - 1] = (long *)Malloc(spp * sizeof(long));
dolpenny.c:  fprintf(outfile, " branch-and-bound to find all");
dolpenny.c:  if (!p->tip) {
dolpenny.c:    preorder(p->next->back);
dolpenny.c:    preorder(p->next->next->back);
dolpenny.c:  if (p->back == NULL)
dolpenny.c:      stps[i] = (treenode[p->back->index - 1]->stateone[i] & p->statezero[i] &
dolpenny.c:                (treenode[p->back->index - 1]->statezero[i] & p->stateone[i] &
dolpenny.c:      stps[i] = treenode[p->back->index - 1]->stateone[i] &
dolpenny.c:                treenode[p->back->index - 1]->statezero[i] & p->stateone[i] &
dolpenny.c:                p->statezero[i];
dolpenny.c:    bestyet = -1.0;
dolpenny.c:        sprintf(progbuf, "         -        ");
dolpenny.c:      sprintf(progbuf, "%17ld%20.2f\n", nextree - 1, fracdone * 100);
dolpenny.c:  valyew[*n - 1] = like;
dolpenny.c:  place[*n - 1] = a->index;
dolpenny.c:  if (!a->tip) {
dolpenny.c:    addtraverse(a->next->back, b, c, place, valyew, n);
dolpenny.c:    addtraverse(a->next->next->back, b, c, place, valyew, n);
dolpenny.c:    added[order[m - 1] - 1] = true;
dolpenny.c:    addtraverse(root, treenode[order[m - 1] - 1], treenode[spp + m - 2],
dolpenny.c:    besttoadd = order[m - 1];
dolpenny.c:    bestsum = -1.0;
dolpenny.c:      if (!added[i - 1])
dolpenny.c:        added[i - 1] = true;
dolpenny.c:        addtraverse(root, treenode[i - 1], treenode[spp + m - 2],
dolpenny.c:        added[i - 1] = false;
dolpenny.c:  order[m - 1] = besttoadd;
dolpenny.c:      current[m - 1] = place[i];
dolpenny.c:      add(treenode[place[i] - 1], treenode[besttoadd - 1],
dolpenny.c:          treenode[spp + m - 2], &root, treenode);
dolpenny.c:      added[besttoadd - 1] = true;
dolpenny.c:          memcpy(bestorders[nextree - 1], order, spp * sizeof(long));
dolpenny.c:          memcpy(bestrees[nextree - 1], current, spp * sizeof(long));
dolpenny.c:      re_move(&treenode[besttoadd - 1], &treenode[spp + m - 2], &root, treenode);
dolpenny.c:      added[besttoadd - 1] = false;
dolpenny.c:  fullset = (1L << (bits + 1)) - (1L << 1);
dolpenny.c:    sprintf(progbuf, "----------     ------------     ------------       ------------\n");
dolpenny.c:  bestyet = -1.0;
dolpenny.c:      fprintf(outfile, "%5ld trees in all found\n", nextree - 1);
dolpenny.c:  for (i = 0; i <= (nextree - 2); i++)
dolpenny.c:      add(treenode[bestrees[i][j - 1] - 1],
dolpenny.c:          treenode[bestorders[i][j - 1] - 1], treenode[spp + j - 2],
dolpenny.c:    for (j = k - 1; j < spp; j++)
dolpenny.c:      re_move(&treenode[bestorders[i][j] - 1], &dummy, &root, treenode);
dolpenny.c:  bits = 8 * sizeof(long) - 1;
dolpenny.c:{ /* branch-and-bound method for Dollo, polymorphism parsimony */
dolpenny.c:  bits = 8 * sizeof(long) - 1;
dolpenny.c:}  /* branch-and-bound method for Dollo, polymorphism parsimony */
draw2.c:/* Version 4.0. (c) Copyright 1993-2013 by the University of Washington.
draw2.c:  iy0 = strptop - iy;
draw2.c:      iy2 = 7 - iy0;
draw2.c:      iy2 = 7 - iy0;
draw2.c:      iy2 = 5 - iy0 % 6;
draw2.c:      ix0 = (ix - 1) / 8 + 1;
draw2.c:      iy2 = 7 - ((ix - 1) & 7);
draw2.c:      ix0 = (ix - 1) / 8 + 1;
draw2.c:      iy2 = 7 - ((ix - 1) & 7);
draw2.c:      ix0 = (ix - 1) / 8 + 1;
draw2.c:      iy2 = 7 - ((ix - 1) & 7);
draw2.c:      ix0 = (ix - 1) / 8 + 1;
draw2.c:      iy2 = (ix - 1) & 7;
draw2.c:  stripe[iy1 - 1][ix0 - 1] |= (unsigned char)1<<iy2;
draw2.c:  plotdot(x0+x,y0+y-1);
draw2.c:  plotdot(x0+y-1,y0+x);
draw2.c:  plotdot(x0-x,y0+y);
draw2.c:  plotdot(x0-x,y0+y-1);
draw2.c:  plotdot(x0-y,y0+x);
draw2.c:  plotdot(x0-y+1,y0+x);
draw2.c:  plotdot(x0+x,y0-y);
draw2.c:  plotdot(x0+x,y0-y+1);
draw2.c:  plotdot(x0+y,y0-x);
draw2.c:  plotdot(x0+y-1,y0-x);
draw2.c:  plotdot(x0-x,y0-y);
draw2.c:  plotdot(x0-x,y0-y+1);
draw2.c:  plotdot(x0-y,y0-x);
draw2.c:  plotdot(x0-y+1,y0-x);
draw2.c:  d = 1-radius;
draw2.c:  deltaSE = -2 * radius + 5;
draw2.c:      y--;
draw2.c:  xdiff = ixabs - ixnow;
draw2.c:  ydiff = iyabs - iynow;
draw2.c:      err = -(xdiff / 2);
draw2.c:          err -= xdiff;
draw2.c:    err = -(ydiff / 2);
draw2.c:        err -= ydiff;
draw2.c:  if (xdiff < -ydiff) {
draw2.c:      y1--;
draw2.c:  err = -(xdiff / 2);
draw2.c:    err -= ydiff;
draw2.c:      iynow--;
draw2.c:      err -= xdiff;
draw2.c:  /* added to give every line a name in vrml! - danieyek 981110 */
draw2.c:  double episilon = 1.0e-10;
draw2.c:          XDrawLine(display,mainwin,gc1,(long)oldx,(long)(height-oldy), (long)xabs,(long)(height-yabs));
draw2.c:          LineTo(hdc, (int) xabs, (int)(winheight-yabs));
draw2.c:          MoveToEx(hdc, (int) xabs, (int) (winheight-yabs), (LPPOINT) NULL);
draw2.c:        } else {  /* DLS/JMH -- for systems that use EBCDIC coding */
draw2.c:        newy = floor(ysize * yunitspercm - yabs + 0.5);
draw2.c:            dxreal = xabs - oldxreal;
draw2.c:            dyreal = yabs - oldyreal;
draw2.c:                    oldx-(clipx0*xunitspercm), oldy-(clipy0*yunitspercm),
draw2.c:                    xabs-(clipx0*xunitspercm), yabs-(clipy0*yunitspercm));
draw2.c:          fprintf(plotfile, "<path stroke=\"black\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"%.1f\" d=\"M %8.2f %8.2f L %8.2f %8.2f\" fill=\"none\" />\n",
draw2.c:                  treeline, oldx, svg_height - oldy, xabs, svg_height - yabs);
draw2.c:                    (long)(100.0 * (linewidth/2)) - 100,
draw2.c:                    (long)(100.0 * (linewidth/2)) - 100);
draw2.c:                    (long)(100.0 * (linewidth/2)) - 100,
draw2.c:                    (long)(100.0 * (linewidth/2)) - 100);
draw2.c:        newy = fabs(floor(yabs) - getmaxy());
draw2.c:        newy = fabs(floor(yabs) - myscreen.numypixels);
draw2.c:                 winheight - (long)floor((double)yabs + 0.5)+MAC_OFFSET);}
draw2.c:                 winheight - (long)floor((double)yabs + 0.5)+MAC_OFFSET);}
draw2.c:        newy = fabs(floor(yabs + 0.5) - 479);
draw2.c:        newy = floor(ysize*yunitspercm - ysize*yabs + 0.5);
draw2.c:          fprintf(plotfile, "2 1 0 %5ld 0 -1 50 0 -1 0.000 1 1 -1 0 0 2\n",
draw2.c:        if (firstNodeP-- == 1)
draw2.c:                  colors[vrmlskycolornear-1].red,
draw2.c:                  colors[vrmlskycolornear-1].green,
draw2.c:                  colors[vrmlskycolornear-1].blue,
draw2.c:                  colors[vrmlskycolorfar-1].red,
draw2.c:                  colors[vrmlskycolorfar-1].green,
draw2.c:                  colors[vrmlskycolorfar-1].blue);
draw2.c:                  colors[vrmlgroundcolorfar-1].red,
draw2.c:                  colors[vrmlgroundcolorfar-1].green,
draw2.c:                  colors[vrmlgroundcolorfar-1].blue);
draw2.c:          distance = sqrt((newy - oldy)*(newy - oldy) + (newx - oldx)*(newx - oldx));
draw2.c:                    colors[vrmlplotcolor-1].red,
draw2.c:                    colors[vrmlplotcolor-1].green,
draw2.c:                    colors[vrmlplotcolor-1].blue);
draw2.c:            fprintf(plotfile, "          rotation 0 0 1 -1.570796327\n" );
draw2.c:                    colors[vrmlplotcolor-1].red,
draw2.c:                    colors[vrmlplotcolor-1].green,
draw2.c:                    colors[vrmlplotcolor-1].blue );
draw2.c:                    colors[vrmlplotcolor-1].red,
draw2.c:                    colors[vrmlplotcolor-1].green,
draw2.c:                    colors[vrmlplotcolor-1].blue );
draw2.c:    dx = ixabs - ixnow;
draw2.c:    dy = iyabs - iynow;
draw2.c:        (iyabs - cdx <= strptop || iynow - cdx <= strptop)) {
draw2.c:          (long)(100.0 * (linewidth/2)) - 100,
draw2.c:          (long)(100.0 * (linewidth/2)) - 100);
draw2.c:  x1 = x1 - (clipx0 * xunitspercm);
draw2.c:  x2 = x2 - (clipx0 * xunitspercm);
draw2.c:  y1 = y1 - (clipy0 * yunitspercm);
draw2.c:  y2 = y2 - (clipy0 * yunitspercm); /* adjust by clipping region */
draw2.c:                (x1+(0.55*(x2-x1))), y1, x2, (y1+(0.45*(y2-y1))),
draw2.c:                x1, (y1+(0.55*(y2-y1))), (x1+(0.45*(x2-x1))), y2,
draw2.c:      fprintf(plotfile,"<path stroke=\"black\" stroke-width=\"%.1f\" d=\"M %8.2f,%8.2f ", treeline, x1, svg_height-y1);
draw2.c:                (x1+(0.55*(x2-x1))), svg_height-y1, x2, svg_height-(y1+(0.45*(y2-y1))),
draw2.c:                x2, svg_height-y2);
draw2.c:                x1, svg_height-(y1+(0.55*(y2-y1))), (x1+(0.45*(x2-x1))), svg_height-y2,
draw2.c:                x2, svg_height-y2);
draw2.c:        y1 = (ysize * yunitspercm) - y1;
draw2.c:        y2 = (ysize * yunitspercm) - y2;
draw2.c:            dtop = y2 - y1 + y2;
draw2.c:            dleft = x1 - x2 + x1;
draw2.c:            dtop = y2 - y1 + y2;
draw2.c:            dright = x1 + (x1 - x2);
draw2.c:            dtop = y1 + (y1 - y2);
draw2.c:            dright = x2 + (x2 - x1);
draw2.c:            dbottom = y1 + y1 - y2;;
draw2.c:            dright = x2 + (x2 - x1);
draw2.c:        ptop    = (long)floor((dtop - 0) + 0.5);
draw2.c:            pleft--;
draw2.c:      fromy = (long)floor(ysize*yunitspercm - ysize*y1 + 0.5);
draw2.c:      toy = (long)floor(ysize*yunitspercm - ysize*y2 + 0.5);
draw2.c:                (long)floor((x1+(0.55*(x2-x1))) + 0.5), fromy,
draw2.c:                tox, (long)floor((y1+(0.45*(y2-y1))) + 0.5),
draw2.c:                fromx, (long)floor((y1+(0.55*(y2-y1))) + 0.5),
draw2.c:                (long)floor((x1+(0.45*(x2-x1))) + 0.5), toy,
draw2.c:      rx = (fabs(x2 - x1));
draw2.c:      ry = (fabs(y2 - y1));
draw2.c:            costheta  = -1.0,
draw2.c:            dtheta = -90.0 / ((double)segs),
draw2.c:          sintheta  = -1.0,
draw2.c:            dtheta = -90.0 / ((double)segs),
draw2.c:          sintheta  = -1.0,
draw2.c:        newcostheta = (costheta * cosdtheta) - (sintheta * sindtheta);
draw2.c:        else if (i == segs - 1)
draw2.c:          fprintf(plotfile,"PD;AA%ld,%ld,-90,1;\n",(long)x1,(long)y2);
draw2.c:          fprintf(plotfile,"PD;AA%ld,%ld,-90,1;\n",(long)x2,(long)y1);
draw2.c:        h = 1.0 - sqrt(1.0 - g * g);
draw2.c:          x3 = x1 * (1.0 - f) + x2 * f;
draw2.c:          y3 = y1 + (y2 - y1) * h;
draw2.c:          x3 = x1 + (x2 - x1) * h;
draw2.c:          y3 = y1 * (1.0 - f) + y2 * f;
draw2.c:   *  write a 1-bit image header
draw2.c:      reverse_bits (full_pic, (j * padded_width) + (padded_width - i));
draw2.c:              full_pic[(j * padded_width) + (padded_width - i)]) ;
draw2.c:    /* For a non-last-stripe, figure out if the last stripe is going
draw2.c:      last_stripe_offset = DEFAULT_STRIPE_HEIGHT - ((int) ysize %
draw2.c:  pad_size     = padded_width - width;
draw2.c:  offset       = ((total_stripes - increment) *
draw2.c:    - (padded_width * last_stripe_offset)
draw2.c:  for (j = div; j >= 0; j--) {
draw2.c:               (((div-j) * padded_width)
draw2.c:                + (width-i))] = (byte) (*stripe)[j][i];
draw2.c:/* fn--fontname        xo,yo--x and y offsets */
draw2.c:  (*xo) = (xcorner + (xsize - oldxsize * (*scale)) / 2.0) / (*scale);
draw2.c:  (*yo) = (ycorner   + (ysize - oldysize * (*scale)) / 2.0) / (*scale);
draw2.c:  xpag = (int)((pagex-hpmargin-0.01)/(paperx - hpmargin))+1;
draw2.c:  ypag = (int)((pagey-vpmargin-0.01)/(papery - vpmargin))+1;
draw2.c:    plot(penup,(xscale * (*xo))+xscale*i*(paperx - hpmargin),((*yo)*yscale)+0);
draw2.c:    plot(pendown,(xscale * (*xo))+xscale*i*(paperx - hpmargin),((*yo)*yscale)+yscale*pagey);
draw2.c:    plot(penup,(xscale * (*xo)),((*yo)*yscale)+yscale*j*(papery-vpmargin));
draw2.c:    plot(pendown,(xscale * (*xo))+xscale*pagex,((*yo)*yscale)+yscale*j*(papery-hpmargin));
draw2.c:/* added for vrml - danieyek 981111 */
draw2.c:  if ((newx-oldx) == 0 )
draw2.c:    /* pi/2 or -pi/2! */
draw2.c:    else if (newy < oldy) angle = -pi/2;
draw2.c:      /* added - danieyek 990130 */
draw2.c:    angle = atan( (newy-oldy)/(newx-oldx) );
draw2.c:      /* First quardrant - no adjustment */
draw.c:/* Version 4.0. (c) Copyright 2012-2013 by the University of Washington.
draw.c:  {1.0, -100.0, 100.0, 100.0},
draw.c:  {0.5, 100.0, -100.0, -100.0},
draw.c:  {0.3, 0.0, -100.0, 100.0},
draw.c:  n->init = draw_node_init;
draw.c:  dn->theta = 0.0;
draw.c: * - update to adobe 3.0
draw.c: * - drop the PaperSize, deprecated in 2.1
draw.c: * - drop the PageBoundingBox, the BoundingBox
draw.c: * - hardwiring the BoundingBox makes no sense
draw.c: * pagex = ( (double)n * ( paperx - hpmargin) + hpmargin );
draw.c: * pagey = ( (double)m * ( papery - vpmargin) + vpmargin );
draw.c: * so it is ( paperx - 2 * xmargin ) in units by
draw.c: * the bounding box is paper size - margins, so the lower
draw.c: *  ( unit * ( paperx - xmargin ) ), ( unit * ( papery - ymargin ) )
draw.c:  int bb_ur_x = (int)( dm_x - bb_ll_x );  /* re-cycle the margins for */
draw.c:  int bb_ur_y = (int)( dm_y - bb_ll_y );  /* upper-right dimensions   */
draw.c:  fprintf( plotfile, "%s\n",       "%!PS-Adobe-3.0"                );
draw.c:      oldxhigh = -1.0;
draw.c:      oldxlow = -1.0;
draw.c:      oldyhigh = -1.0;
draw.c:      oldylow = -1.0;
draw.c:      nmoves = 0;       /* DLS/JMH -- See function  PLOT                  */
draw.c:                -xsize * 1.8, xsize * 1.5);
draw.c:                xsize * 0.5, -xsize * 1.21, ysize * 0.55);
draw.c:                -ysize * 1.8, ysize * 1.5);
draw.c:                xsize * 0.5, -ysize * 1.21, ysize * 0.55);
draw.c:      fprintf(plotfile, "/* %.10s */\n", colors[treecolor - 1].name);
draw.c:              colors[treecolor - 1].red, colors[treecolor - 1].green,
draw.c:              colors[treecolor - 1].blue);
draw.c:      fprintf(plotfile, "/* %.10s */\n", colors[namecolor - 1].name);
draw.c:              colors[namecolor - 1].red, colors[namecolor - 1].green,
draw.c:              colors[namecolor - 1].blue);
draw.c:      fprintf(plotfile, "/* %.10s */\n", colors[backcolor - 1].name);
draw.c:              colors[backcolor - 1].red, colors[backcolor - 1].green,
draw.c:              colors[backcolor - 1].blue);
draw.c:                ymargin - ysize / (ntips - 1));
draw.c:              colors[treecolor-1].red,
draw.c:              colors[treecolor-1].green,
draw.c:              colors[treecolor-1].blue);
draw.c:              colors[namecolor-1].red,
draw.c:              colors[namecolor-1].green,
draw.c:              colors[namecolor-1].blue);
draw.c:                -xsize * 0.5, -xsize * 1.21, ysize * 0.55);
draw.c:                -xsize * 0.5, -ysize * 1.21, ysize * 0.55);
draw.c:              -xsize * 0.5, ysize * 0.5);
draw.c:              colors[backcolor-1].red,
draw.c:              colors[backcolor-1].green,
draw.c:              colors[backcolor-1].blue);
draw.c:                  ymargin - ysize / (ntips - 1));
draw.c:                colors[bottomcolor-1].red,
draw.c:                colors[bottomcolor-1].green,
draw.c:                colors[bottomcolor-1].blue);
draw.c:      fprintf(plotfile, "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \n");
draw.c:      fprintf(plotfile, "%c%c", (unsigned char)lobyte(hres - 1),
draw.c:              (unsigned char)upbyte(hres - 1)); /* Xmax */
draw.c:      fprintf(plotfile, "%c%c", (unsigned char)lobyte(vres - 1),
draw.c:              (unsigned char)upbyte(vres - 1)); /* Ymax */
draw.c:      fprintf(plotfile, "-2\n");
draw.c:  /* the dot-skip is resolution-independent. */
draw.c:  /* this makes all the point-skip instructions skip the same # of dots. */
draw.c:    ok = (ok && mystripe[j - 1][pos - 1] == null);
draw.c:      ok = (ok && mystripe[j][i - 1] == '\0');
draw.c:        done = done || (stripe[i] && (stripe[i][width - 1] != null));
draw.c:        width--;
draw.c:          while ((stripe[j][t + i - 1]) == (stripe[j][t + i])
draw.c:            putc(255 - stripe[j][t - 1], plotfile);
draw.c:            if (255 - (stripe[j][t - 1] & 255) >= 192) {
draw.c:            putc(255 - stripe[j][t - 1], plotfile);
draw.c:          x = FirstBlack(stripe, x, deep);    /* all-black strip is now    */
draw.c:          Skip((x - theend - 1) * 8);        /* x..theend                 */
draw.c:          theend = FirstWhite(stripe, x, deep) - 1;/* like lastblack            */
draw.c:                    (int)DigitsInt(theend - x + 1), theend - x + 1);
draw.c:                    (int)DigitsInt(theend - x + 1), (int) (theend - x + 1));
draw.c:            /* dump theend-x+1 bytes */
draw.c:            for (t = x - 1; t < theend; t++)
draw.c:            filesize += theend - x + DigitsInt(theend - x + 1) + 5;
draw.c:          Skip((theend - x + 1) * 8);
draw.c:      width = ((strpwide -1) / 8) +1;
draw.c:      width = ((strpwide -1) / 8) +1;
draw.c:      exxit(-1);
draw.c:      exxit(-1);
draw.c:      if ((i - charstart - 3) % 10 == 0)
draw.c:      if(fscanf(fontfile, "%hd", &font[i - 1]) < 1)
draw.c:        exxit(-1);
draw.c:    } while (abs(font[i - 1]) < 10000);
draw.c:    font[charstart - 1] = i + 1;
draw.c:  font[charstart - 1] = 0;
draw.c:    printf(" (1)               Tree color:  %.10s\n", colors[treecolor-1].name);
draw.c:    printf(" (2)      Species names color:  %.10s\n", colors[namecolor-1].name);
draw.c:    printf(" (3)         Background color:  %.10s\n", colors[backcolor-1].name);
draw.c:    printf(" (1)               Tree color:  %.10s\n", colors[treecolor-1].name);
draw.c:    printf(" (2)      Species names color:  %.10s\n", colors[namecolor-1].name);
draw.c:    printf(" (3)         Background color:  %.10s\n", colors[backcolor-1].name);
draw.c:           "(none)\0" : colors[bottomcolor-1].name);
draw.c:    printf(" Type Y or N or the number (1-4) of the one to change:\n");
draw.c:  return (ch == 'Y') ? -1 : numtochange;
draw.c:      printf(" Type the number of one that you want to change (1-4):\n");
draw.c:          if (ch == colors[i - 1].name[0]) {
draw.c:          if (ch == colors[i - 1].name[0]) {
draw.c:          if (ch == colors[i - 1].name[0]) {
draw.c:              if (ch == colors[i - 1].name[0]) {
draw.c:  printf(" (1)               Tree color:  %.10s\n", colors[vrmltreecolor-1].name);
draw.c:  printf(" (2)      Species names color:  %.10s\n", colors[vrmlnamecolor-1].name);
draw.c:  printf(" (3)            Horizon color:  %.10s\n", colors[vrmlskycolorfar-1].name);
draw.c:  printf(" (4)             Zenith color:  %.10s\n", colors[vrmlskycolornear-1].name);
draw.c:  printf(" (5)             Ground color:  %.10s\n", colors[vrmlgroundcolornear-1].name);
draw.c:    printf(" Type Y or N or the number (1-5) of the one to change:\n");
draw.c:  return (ch == 'Y') ? -1 : numtochange;
draw.c:      printf(" Type the number of one that you want to change (1-4):\n");
draw.c:          if (ch == colors[i - 1].name[0]) {
draw.c:          if (ch == colors[i - 1].name[0]) {
draw.c:          if (ch == colors[i - 1].name[0]) {
draw.c:          if (ch == colors[i - 1].name[0]) {
draw.c:          if (ch == colors[i - 1].name[0]) {
draw.c:        if (n != -1)
draw.c:      } while (n != -1);
draw.c:        if (n != -1)
draw.c:      } while (n != -1);
draw.c:        if (n != -1)
draw.c:      } while (n != -1);
draw.c:  printf("        W         MS-Windows Bitmap\n");
draw.c:  printf("        H         Hewlett-Packard pen plotter (HPGL file format)\n");
draw.c:  printf("        E         Epson MX-80 dot-matrix printer\n");
draw.c:  printf("        C         Prowriter/Imagewriter dot-matrix printer\n");
draw.c:  printf("        T         Toshiba 24-pin dot-matrix printer\n");
draw.c:  printf("        O         Okidata dot-matrix printer\n");
draw.c:      strcpy(fontname, "Times-Roman");
draw.c:      strcpy(fontname, "Times-Roman");
draw.c:      strcpy(fontname, "Times-Bold");
draw.c:      hpresolution = 75*(1<<(ch-1));
draw.c:      printf("Please select the MS-Windows bitmap file resolution\n");
draw.c:      printf("Please select the X-bitmap file resolution\n");
draw.c:      nmetrics--;
draw.c:      if (charnum != -1 && charnum >= 32)
draw.c:        metric[charnum-31] = charlen;
draw.c:      (strcmp(fontname, "Helvetica-Oblique") == 0))
draw.c:      fontmetric[i-31] = helvetica_metric[i-31];
draw.c:  else if ((strcmp(fontname, "Helvetica-Bold") == 0) ||
draw.c:           (strcmp(fontname, "Helvetica-BoldOblique") == 0))
draw.c:      fontmetric[i-31] = helveticabold_metric[i-31];
draw.c:  else if (strcmp(fontname, "Times-Roman") == 0)
draw.c:      fontmetric[i-31] = timesroman_metric[i-31];
draw.c:      fontmetric[i-31] = timesroman_metric[i-31];
draw.c:  else if (strcmp(fontname, "Times-Italic") == 0)
draw.c:      fontmetric[i-31] = timesitalic_metric[i-31];
draw.c:  else if (strcmp(fontname, "Times-Bold") == 0)
draw.c:      fontmetric[i-31] = timesbold_metric[i-31];
draw.c:  else if (strcmp(fontname, "Times-BoldItalic") == 0)
draw.c:      fontmetric[i-31] = timesbolditalic_metric[i-31];
draw.c:      fontmetric[i-31] = (short)600;
draw.c:        fontmetric[i-31] = unknown_metric[i-31];}
draw.c:          fontmetric[i-31] = unknown_metric[i-31];
draw.c:          fontmetric[i-31] = unknown_metric[i-31];
draw.c:          fontmetric[i-31] = unknown_metric[i-31];
draw.c:          fontmetric[i-31] = unknown_metric[i-31];
draw.c:            fontmetric[i-31] = timesroman_metric[i-31],
draw.c:              unknown_metric[i-31] = timesroman_metric[i-31],
draw.c:              fontmetric[i-31] = unknown_metric[i-31];
draw.c:            printf("Can't read that file. Please re-enter.\n");
draw.c:      while (font[j] != code && font[j - 1] != 0)
draw.c:        j = font[j - 1];
draw.c:      sumbigunits += afmetric[(int)(1+(unsigned char)pstring[i] - 32)];
draw.c:  text->heightfont = text->font[*place + 1];
draw.c:  text->yfactor = text->height / text->heightfont;
draw.c:  text->xfactor = text->yfactor;
draw.c:    text->coord = text->font[*place - 1];
draw.c:    if (text->coord > 0)
draw.c:      text->penstatus = pendown;
draw.c:      text->penstatus = penup;
draw.c:    text->coord = abs(text->coord);
draw.c:    text->coord %= 10000;
draw.c:    text->xfont = (text->coord / 100 - xstart) * text->xfactor;
draw.c:    text->yfont = (text->coord % 100 - ystart) * text->yfactor;
draw.c:    text->xplot = text->xx + (text->xfont * text->cosslope +
draw.c:                              text->yfont * text->sinslope) * text->compress;
draw.c:    text->yplot = text->yy - text->xfont * text->sinslope +
draw.c:      text->yfont * text->cosslope;
draw.c:    plot(text->penstatus, text->xplot, text->yplot);
draw.c:  } while (abs(text->font[*place - 1]) < 10000);
draw.c:  text->xx = text->xplot;
draw.c:  text->yy = text->yplot;
draw.c:  xpag = (int)((pagex-hpmargin-0.01)/(paperx - hpmargin))+1;
draw.c:  ypag = (int)((pagey-vpmargin-0.01)/(papery - vpmargin))+1;
draw.c:        clipx0 = (double)i*(paperx -  hpmargin);
draw.c:        clipx1 = (double)(i*(paperx -  hpmargin))+(paperx - hpmargin);
draw.c:        clipy0 = (double)(j*(papery -  vpmargin));
draw.c:        clipy1 = (double)(j*(papery-hpmargin))+(papery+vpmargin);
draw.c:        if (!(i == xpag - 1 && j == ypag - 1) && plotter == lw)
draw.c:    striprint(( long)((ysize * yunitspercm)- (numlines * strpdeep)),
draw.c:              ( long)((ysize * yunitspercm)- (numlines * strpdeep)));
draw.c:    strpbottom = strptop - strpdeep + 1;
draw.c:    printf("  ----     ------ ---- ----\n");
draw.c:      strptop     = strpbottom - 1;
draw.c:      strpbottom -= strpdeep;
draw.c:        /* large stripe, do in DEFAULT_STRIPE_HEIGHT (20)-line     */
draw.c:              (DEFAULT_STRIPE_HEIGHT -1)) {
draw.c:    strcpy(returnval, "*-helvetica-medium-r-*-120-75-75-*"),
draw.c:  else if (strcmp(fontname, "Helvetica-Oblique") == 0)
draw.c:    strcpy(returnval, "*-helvetica-medium-o-*-140-75-75-*"),
draw.c:  else if (strcmp(fontname, "Helvetica-Bold") == 0)
draw.c:    strcpy(returnval, "*-helvetica-bold-r-*-140-75-75-*"),
draw.c:  else if (strcmp(fontname, "Helvetica-BoldOblique") == 0)
draw.c:    strcpy(returnval, "*-helvetica-medium-o-*-140-75-75-*"),
draw.c:  else if (strcmp(fontname, "Times-Roman") == 0)
draw.c:    strcpy(returnval, "*-times-medium-r-*-140-75-75-*"),
draw.c:  else if (strcmp(fontname, "Times-Italic") == 0)
draw.c:    strcpy(returnval, "*-times-medium-i-*-140-75-75-*"),
draw.c:  else if (strcmp(fontname, "Times-Bold") == 0)
draw.c:    strcpy(returnval, "*-times-medium-i-*-140-75-75-*"),
draw.c:  else if (strcmp(fontname, "Times-BoldItalic") == 0)
draw.c:    strcpy(returnval, "*-times-medium-i-*-140-75-75-*"),
draw.c:    sprintf(returnval, "*-courier-medium-r-*-100-75-75-*"),
draw.c:  else if (strcmp(fontname, "Courier-Italic") == 0)
draw.c:    strcpy(returnval, "*-courier-medium-r-*-120-75-75-*"),
draw.c:  else if (strcmp(fontname, "Courier-Bold") == 0)
draw.c:    strcpy(returnval, "*-courier-bold-r-*-120-75-75-*"),
draw.c:  else if (strcmp(fontname, "Courier-BoldItalic") == 0)
draw.c:    strcpy(returnval, "*-courier-bold-r-*-120-75-75-*"),
draw.c:    sprintf(returnval, "*-times-medium-r-*-120-75-75-*"),
draw.c:  else if (strcmp(fontnam, "TIMES-ROMAN") == 0)
draw.c:      while (text.font[j] != code && text.font[j - 1] != 0)
draw.c:        j = text.font[j - 1];
draw.c:               x - (text.cosslope * pointsize),
draw.c:               x - (text.cosslope * pointsize) + (text.sinslope * textlen))
draw.c:               x - (text.cosslope * pointsize),
draw.c:               x - (text.cosslope * pointsize) + (text.sinslope * textlen))
draw.c:               y - (text.sinslope * pointsize),
draw.c:               y - (text.sinslope * pointsize) + (text.cosslope * textlen))
draw.c:               y - (text.sinslope * pointsize),
draw.c:               y - (text.sinslope * pointsize) + (text.cosslope * textlen))
draw.c:      fprintf(plotfile, "%f %f translate %f rotate\n", x-(clipx0*xunitspercm), y-(clipy0*xunitspercm), -slope);
draw.c:    fprintf(plotfile, "[ %f %f %f %f %f %f ] concat\n", text.cosslope*iscale, -text.sinslope*iscale, text.sinslope*iscale, text.cosslope*iscale, x+216.0, y+285.0);
draw.c:             winheight - (long)floor((double)inputSequences + 0.5)+MAC_OFFSET);
draw.c:      pictoutint(plotfile, (int)floor(ysize * yunitspercm - y + 0.5));
draw.c:    x -= text.height * text.sinslope/8.0;
draw.c:      if (!strcmp(fontname, "Times-Roman"))
draw.c:      else if (!strcmp(fontname, "Times-Bold"))
draw.c:      else if (!strcmp(fontname, "Times-BoldItalic"))
draw.c:      else if (!strcmp(fontname, "Times-Italic"))
draw.c:        sprintf(svgfont, "sans-serif");
draw.c:      else if (!strcmp(fontname, "Helvetica-Bold"))
draw.c:        sprintf(svgfont, "sans-serif");
draw.c:      else if (!strcmp(fontname, "Helvetica-Oblique"))
draw.c:        sprintf(svgfont, "sans-serif");
draw.c:      else if (!strcmp(fontname, "Helvetica-BoldOblique"))
draw.c:        sprintf(svgfont, "sans-serif");
draw.c:      else if (!strcmp(fontname, "Helvetica-Narrow"))
draw.c:        sprintf(svgfont, "sans-serif");
draw.c:      else if (!strcmp(fontname, "Helvetica-Narrow-Oblique"))
draw.c:        sprintf(svgfont, "sans-serif");
draw.c:      else if (!strcmp(fontname, "Helvetica-Narrow-Bold"))
draw.c:        sprintf(svgfont, "sans-serif");
draw.c:      else if (!strcmp(fontname, "Helvetica-Narrow-BoldOblique"))
draw.c:        sprintf(svgfont, "sans-serif");
draw.c:      else if (!strcmp(fontname, "Courier-Bold"))
draw.c:      else if (!strcmp(fontname, "Courier-Oblique"))
draw.c:      else if (!strcmp(fontname, "Courier-BoldOblique"))
draw.c:      else if (!strcmp(fontname, "AvantGarde-Book"))
draw.c:        sprintf(svgfont, "sans-serif");
draw.c:      else if (!strcmp(fontname, "AvantGarde-BookOblique"))
draw.c:        sprintf(svgfont, "sans-serif");
draw.c:      else if (!strcmp(fontname, "AvantGarde-Demi"))
draw.c:        sprintf(svgfont, "sans-serif");
draw.c:      else if (!strcmp(fontname, "AvantGarde-DemiOblique"))
draw.c:        sprintf(svgfont, "sans-serif");
draw.c:      else if (!strcmp(fontname, "Bookman-Light"))
draw.c:      else if (!strcmp(fontname, "Bookman-LightItalic"))
draw.c:      else if (!strcmp(fontname, "Bookman-Demi"))
draw.c:      else if (!strcmp(fontname, "Bookman-DemiItalic"))
draw.c:      else if (!strcmp(fontname, "NewCenturySchlbk-Roman"))
draw.c:      else if (!strcmp(fontname, "NewCenturySchlbk-Italic"))
draw.c:      else if (!strcmp(fontname, "NewCenturySchlbk-Bold"))
draw.c:      else if (!strcmp(fontname, "NewCenturySchlbk-BoldItalic"))
draw.c:      else if (!strcmp(fontname, "Palatino-Roman"))
draw.c:      else if (!strcmp(fontname, "Palatino-Italic"))
draw.c:      else if (!strcmp(fontname, "Palatino-Bold"))
draw.c:      else if (!strcmp(fontname, "Palatino-BoldItalic"))
draw.c:      else if (!strcmp(fontname, "ZapfChancery-MediumItalic"))
draw.c:      fprintf(plotfile, "<text transform=\"translate(%.2f,%.2f) rotate(%.2f)\" font-size=\"%.1f\" font-family=\"%s\" font-style=\"%s\" font-weight=\"%s\">%s</text>\n",
draw.c:              x, svg_height - y, slope, pointsize, svgfont, svgstyle, svgweight, pstring);
draw.c:      fprintf(plotfile, "<text transform=\"translate(%.2f,%.2f) rotate(%.2f)\" font-size=\"%.1f\" font-family=\"%s\">%s</text>\n",
draw.c:              x, svg_height - y, slope, pointsize, fontname, pstring);
draw.c:/* fn--fontname| xo, yo--x and y offsets */
draw.c:  (*xo) = (xcorner + (xsize - oldxsize * (*scale)) / 2.0) / (*scale);
draw.c:  (*yo) = (ycorner   + (ysize - oldysize * (*scale)) / 2.0) / (*scale);
draw.c:  xpag = (int)((pagex-hpmargin-0.01)/(paperx - hpmargin))+1;
draw.c:  ypag = (int)((pagey-vpmargin-0.01)/(papery - vpmargin))+1;
draw.c:    plot(penup, (xscale * (*xo))+xscale*i*(paperx - hpmargin)*xpagecorrection, 
draw.c:    plot(pendown, (xscale * (*xo))+xscale*i*(paperx - hpmargin)*xpagecorrection, 
draw.c:      plot(penup, (xscale * (*xo)) +xscale*i*(paperx - hpmargin)*xpagecorrection+xscale*hpmargin, ((*yo)*yscale));
draw.c:           +xscale*i*(paperx - hpmargin)*xpagecorrection+xscale*hpmargin,
draw.c:    plot(penup, (xscale * (*xo)), ((*yo)*yscale)+yscale*j*(papery-vpmargin)*ypagecorrection);
draw.c:    plot(pendown, (xscale * (*xo))+xscale*pagex*xpagecorrection, ((*yo)*yscale)+yscale*j*(papery-hpmargin)*ypagecorrection);
draw.c:      plot(penup, (xscale * (*xo)), ((*yo)*yscale)+yscale*j*(papery-vpmargin)*ypagecorrection+yscale*vpmargin);
draw.c:      plot(pendown, (xscale * (*xo))+xscale*pagex*xpagecorrection, ((*yo)*yscale)+yscale*j*(papery-hpmargin)*ypagecorrection+yscale*vpmargin);
draw.c:  return i-1;
draw.c:  if (event->type != ClientMessage || event->xclient.data.l[0] !=
drawgram.c:/* Version 4.0.  Copyright (c) 1986-2013 by The University of Washington and
drawgram.c:  "PHYLIP version 4.0 (c) Copyright 1986-2013\r"
drawgram.c:  "PHYLIP version 4.0 (c) Copyright 1986-2013\\n"
drawgram.c:  strcpy(fontname,"Times-Roman");
drawgram.c:      printf(" Epson dot-matrix printer\n");
drawgram.c:      printf(" MS-Windows Bitmap (%d by %d resolution)\n", (int)xsize,
drawgram.c:      printf(" Toshiba 24-pin dot matrix printer\n");
drawgram.c:      printf(" Imagewriter or C.Itoh/TEC/NEC 9-pin dot matrix printer\n");
drawgram.c:      printf(" old Okidata 9-pin dot matrix printer\n");
drawgram.c:      printf(" Rayshade ray-tracing program file format\n");
drawgram.c:      printf(" POV ray-tracing program file format\n");
drawgram.c:  printf(" T      Stem-length/tree-depth:%6.2f\n", stemlength);
drawgram.c:         "So tree is V-shaped");
drawgram.c:            (pagey-vpmargin) / (papery-vpmargin),
drawgram.c:            (pagex-hpmargin) / (paperx-hpmargin)) ;
drawgram.c:  n = (int)((pagex-hpmargin-0.01)/(paperx-hpmargin)+1.0);
drawgram.c:  m = (int)((pagey-vpmargin-0.01)/(papery-vpmargin)+1.0);
drawgram.c:      printf(" C    Cladogram -- v-shaped \n") ;
drawgram.c:      printf(" P    Phenogram -- branches are square\n") ;
drawgram.c:      printf(" V    Curvogram -- branches are 1/4 of an ellipse\n") ;
drawgram.c:      printf(" E    Eurogram -- branches angle outward, then up\n");
drawgram.c:      printf(" S    Swoopogram -- branches curve outward then reverse\n") ;
drawgram.c:      printf(" horizontally (0), or at a 45-degree angle?\n");
drawgram.c:        pagex = ((double)n * (paperx-hpmargin)+hpmargin);
drawgram.c:        pagey = ((double)m * (papery-vpmargin)+vpmargin);
drawgram.c:      printf(" or so that tree is V-shaped\n");
drawgram.c:  if (p == curtree->root)
drawgram.c:    nodeheight = lengthsum + fabs(p->oldlen);
drawgram.c:  if (p->tip) {
drawgram.c:    p->xcoord = *tipx;
drawgram.c:    ((draw_node*)p)->tipsabove = 1;
drawgram.c:      p->ycoord = nodeheight;
drawgram.c:      p->ycoord = 1.0;
drawgram.c:    ((draw_node*)p)->tipsabove = 0;
drawgram.c:    pp = p->next;
drawgram.c:      calctraverse(pp->back, nodeheight, tipx);
drawgram.c:      ((draw_node*)p)->tipsabove += ((draw_node*)pp->back)->tipsabove;
drawgram.c:      sumw += ((draw_node*)pp->back)->tipsabove;
drawgram.c:      sumwx += ((draw_node*)pp->back)->tipsabove * pp->back->xcoord;
drawgram.c:      if (fabs(pp->back->xcoord - 0.5) < fabs(x3 - 0.5))
drawgram.c:        x3 = pp->back->xcoord;
drawgram.c:      pp = pp->next;
drawgram.c:    x1 = p->next->back->xcoord;
drawgram.c:    x2 = plast->back->xcoord;
drawgram.c:    y1 = p->next->back->ycoord;
drawgram.c:    y2 = plast->back->ycoord;
drawgram.c:        w1 = y1 - p->ycoord;
drawgram.c:        w2 = y2 - p->ycoord;
drawgram.c:          p->xcoord = (x1 + x2) / 2.0;
drawgram.c:          p->xcoord = (w2 * x1 + w1 * x2) / (w1 + w2);
drawgram.c:        p->xcoord = (x1 + x2) / 2.0;
drawgram.c:        p->xcoord = sumwx / sumw;
drawgram.c:        p->xcoord = x3;
drawgram.c:          if (!(p == curtree->root)) {
drawgram.c:            panc = curtree->nodep[p->back->index-1];
drawgram.c:            w1 = p->ycoord - panc->ycoord;
drawgram.c:            w2 = y1 - p->ycoord;
drawgram.c:              x4 = (x1+panc->xcoord)/2.0;
drawgram.c:              x4 = (w1*x1+w2*panc->xcoord)/(w1+w2);
drawgram.c:            w2 = y2 - p->ycoord;
drawgram.c:              x5 = (x2+panc->xcoord)/2.0;
drawgram.c:              x5 = (w1*x2+w2*panc->xcoord)/(w1+w2);
drawgram.c:            if (panc->xcoord < p->xcoord)
drawgram.c:              p->xcoord = x5;
drawgram.c:              p->xcoord = x4;
drawgram.c:            if ((y1-2*p->ycoord+y2) < 0.000001)
drawgram.c:              p->xcoord = (x1+x2)/2;
drawgram.c:              p->xcoord = ((y2-p->ycoord)*x1+(y1-p->ycoord))/(y1-2*p->ycoord+y2);
drawgram.c:      p->ycoord = nodeheight;
drawgram.c:      p->ycoord = (y1 + y2 - sqrt((y1 + y2) * (y1 + y2) - 4 * (y1 * y2 -
drawgram.c:                                                               (x2 - p->xcoord) * (p->xcoord - x1)))) / 2.0;
drawgram.c:    if (fabs(x1 - 0.5) > fabs(x2 - 0.5)) {
drawgram.c:      p->ycoord = y1 + x1 - x2;
drawgram.c:      w1 = y2 - p->ycoord;
drawgram.c:      p->ycoord = y2 + x1 - x2;
drawgram.c:      w1 = y1 - p->ycoord;
drawgram.c:      p->ycoord -= fabs(x1 - x2);
drawgram.c:    curtree->nodep[i]->xcoord = 0.0;
drawgram.c:    curtree->nodep[i]->ycoord = 0.0;
drawgram.c:    if (curtree->nodep[i]->naymlength > 0)
drawgram.c:      firstlet[i] = lengthtext(curtree->nodep[i]->nayme, 1L,fontname,font);
drawgram.c:  while (!curtree->nodep[i]->tip);
drawgram.c:    if (curtree->nodep[i]->tip) {
drawgram.c:      textlength[i] = lengthtext(curtree->nodep[i]->nayme,
drawgram.c:                                 curtree->nodep[i]->naymlength, fontname, font);
drawgram.c:      if (textlength[i]-0.5*firstlet[i] > maxtextlength) {
drawgram.c:        maxtextlength = textlength[i]-0.5*firstlet[i];
drawgram.c:    if (curtree->nodep[i]->tip) {
drawgram.c:    labelheight = 1.0 / (nodespace * (spp - 1));
drawgram.c:                  + cos(angle) * (maxtextlength - 0.5*maxfirst)) * labelheight;
drawgram.c:      tipspacing = 1.0 / (spp - 1.0);
drawgram.c:    calctraverse(curtree->root, sum, &tipx);
drawgram.c:  rooty = curtree->root->ycoord;
drawgram.c:  labelheight *= 1.0 - stemlength;
drawgram.c:    //printf("before rescale curtree->nodep[i]->ycoord: %f\n", curtree->nodep[i]->ycoord);
drawgram.c:        curtree->nodep[i]->xcoord *= 1.0 - stemlength;
drawgram.c:      curtree->nodep[i]->ycoord = stemlength * treedepth + (1.0 - stemlength) *
drawgram.c:        treedepth * (curtree->nodep[i]->ycoord - rooty) / (maxheight - rooty);
drawgram.c:      ((draw_node*)curtree->nodep[i])->oldtheta = angle;
drawgram.c:      curtree->nodep[i]->xcoord = curtree->nodep[i]->xcoord * (maxheight - rooty) / treedepth;
drawgram.c:      curtree->nodep[i]->ycoord = stemlength / (1 - stemlength) * (maxheight - rooty) +
drawgram.c:        curtree->nodep[i]->ycoord;
drawgram.c:      ((draw_node*)curtree->nodep[i])->oldtheta = angle;
drawgram.c:    //printf("after rescale curtree->nodep[i]->ycoord: %f\n", curtree->nodep[i]->ycoord);
drawgram.c:      temp = curtree->nodep[i]->xcoord;
drawgram.c:        curtree->nodep[i]->xcoord = (1.0+curtree->nodep[i]->ycoord
drawgram.c:                                     * cos((1.5-2.0*temp)*pi)/treedepth)/2.0;
drawgram.c:        curtree->nodep[i]->ycoord = (1.0+curtree->nodep[i]->ycoord
drawgram.c:                                     * sin((1.5-2.0*temp)*pi)/treedepth)/2.0;
drawgram.c:        ((draw_node*)curtree->nodep[i])->oldtheta = (1.5-2.0*temp)*pi;
drawgram.c:        curtree->nodep[i]->xcoord = (1.0+curtree->nodep[i]->ycoord
drawgram.c:                                     * cos((1.0-2.0*temp)*pi)/treedepth)/2.0;
drawgram.c:        curtree->nodep[i]->ycoord = (1.0+curtree->nodep[i]->ycoord
drawgram.c:                                     * sin((1.0-2.0*temp)*pi)/treedepth)/2.0;
drawgram.c:        ((draw_node*)curtree->nodep[i])->oldtheta = (1.0-2.0*temp)*pi;
drawgram.c:  maxx = curtree->nodep[0]->xcoord;
drawgram.c:  maxy = curtree->nodep[0]->ycoord;
drawgram.c:  minx = curtree->nodep[0]->xcoord;
drawgram.c:    miny = curtree->nodep[0]->ycoord;
drawgram.c:    if (curtree->nodep[i]->xcoord > maxx)
drawgram.c:      maxx = curtree->nodep[i]->xcoord;
drawgram.c:    if (curtree->nodep[i]->ycoord > maxy)
drawgram.c:      maxy = curtree->nodep[i]->ycoord;
drawgram.c:    if (curtree->nodep[i]->xcoord < minx)
drawgram.c:      minx = curtree->nodep[i]->xcoord;
drawgram.c:    if (curtree->nodep[i]->ycoord < miny)
drawgram.c:      miny = curtree->nodep[i]->ycoord;
drawgram.c:    //printf("end of loop curtree->nodep[i]: (%f, %f) nmaxy: %f miny: %f maxx: %f minx: %f\n", curtree->nodep[i]->xcoord, curtree->nodep[i]->ycoord, maxy, miny, maxx, minx);
drawgram.c:      if (curtree->nodep[i]->tip) {
drawgram.c:        angle = ((draw_node*)curtree->nodep[i])->oldtheta;
drawgram.c:          angle -= pi;
drawgram.c:        top = (curtree->nodep[i]->ycoord - maxy) / labelheight +
drawgram.c:          sin(((draw_node*)curtree->nodep[i])->oldtheta);
drawgram.c:        rig = (curtree->nodep[i]->xcoord - maxx) / labelheight +
drawgram.c:          cos(((draw_node*)curtree->nodep[i])->oldtheta);
drawgram.c:        bot = (miny - curtree->nodep[i]->ycoord) / labelheight -
drawgram.c:          sin(((draw_node*)curtree->nodep[i])->oldtheta);
drawgram.c:        lef = (minx - curtree->nodep[i]->xcoord) / labelheight -
drawgram.c:          cos(((draw_node*)curtree->nodep[i])->oldtheta);
drawgram.c:        if (cos(((draw_node*)curtree->nodep[i])->oldtheta) > 0) {
drawgram.c:          top += sin(angle - 1.25 * pi) * gap * firstlet[i];
drawgram.c:            bot -= sin(angle) * textlength[i];
drawgram.c:          bot -= sin(angle - 0.75 * pi) * gap * firstlet[i];
drawgram.c:            rig += cos(angle - 0.75 * pi) * gap * firstlet[i];
drawgram.c:            rig += cos(angle - 1.25 * pi) * gap * firstlet[i];
drawgram.c:            lef -= cos(angle - 1.25 * pi) * gap * firstlet[i];
drawgram.c:            lef -= cos(angle - 0.75 * pi) * gap * firstlet[i];
drawgram.c:            top -= sin(angle) * textlength[i];
drawgram.c:          bot -= sin(angle - 0.25 * pi) * gap * firstlet[i];
drawgram.c:            rig += cos(angle - 0.25 * pi) * gap * firstlet[i];
drawgram.c:            lef -= cos(angle + 0.25 * pi) * gap * firstlet[i];
drawgram.c:            lef -= cos(angle - 0.25 * pi) * gap * firstlet[i];
drawgram.c:      (1.0 + sin(angle) * (maxtextlength - 0.5 * maxfirst)
drawgram.c:      (cos(angle) * (textlength[nextnode-1] - 0.5 * maxfirst)
drawgram.c:  treeheight = maxy - miny;
drawgram.c:  treewidth = maxx - minx;
drawgram.c:        labelheight *= (maxheight - rooty) / treedepth;
drawgram.c:        topoflabels *= (maxheight - rooty) / treedepth;
drawgram.c:        bottomoflabels *= (maxheight - rooty) / treedepth;
drawgram.c:        leftoflabels *= (maxheight - rooty) / treedepth;
drawgram.c:        rightoflabels *= (maxheight - rooty) / treedepth;
drawgram.c:        treewidth *= (maxheight - rooty) / treedepth;
drawgram.c:      expand = (xsize - 2 * xmargin) / treewidth;
drawgram.c:      if ((ysize - 2 * ymargin) / treeheight < expand)
drawgram.c:        expand = (ysize - 2 * ymargin) / treeheight;
drawgram.c:    extrax = (xsize - 2 * xmargin - treewidth * expand) / 2.0;
drawgram.c:    extray = (ysize - 2 * ymargin - treeheight * expand) / 2.0;
drawgram.c:      expand = (ysize - 2 * ymargin) / treewidth;
drawgram.c:      if ((xsize - 2 * xmargin) / treeheight < expand)
drawgram.c:        expand = (xsize - 2 * xmargin) / treeheight;
drawgram.c:    extrax = (xsize - 2 * xmargin - treeheight * expand) / 2.0;
drawgram.c:    extray = (ysize - 2 * ymargin - treewidth * expand) / 2.0;
drawgram.c:      //printf("before rescale i: %li, curtree->nodep[i]: %f, %f\n", i, curtree->nodep[i]->xcoord, curtree->nodep[i]->ycoord);
drawgram.c:    curtree->nodep[i]->xcoord = expand * (curtree->nodep[i]->xcoord + leftoflabels);
drawgram.c:    curtree->nodep[i]->ycoord = expand * (curtree->nodep[i]->ycoord + bottomoflabels);
drawgram.c:      temp = curtree->nodep[i]->ycoord;
drawgram.c:      curtree->nodep[i]->ycoord = expand * treewidth - curtree->nodep[i]->xcoord;
drawgram.c:      curtree->nodep[i]->xcoord = temp;
drawgram.c:      //printf("after rescale i: %li, curtree->nodep[i]: %f, %f\n", i, curtree->nodep[i]->xcoord, curtree->nodep[i]->ycoord);
drawgram.c:    curtree->nodep[i]->xcoord += xmargin + extrax;
drawgram.c:    curtree->nodep[i]->ycoord += ymargin + extray;
drawgram.c:  x2 = xscale * (xoffset + p->xcoord);
drawgram.c:  y2 = yscale * (yoffset + p->ycoord);
drawgram.c:  if (p != curtree->root) {
drawgram.c:    x1 = xscale * (xoffset + q->xcoord);
drawgram.c:    y1 = yscale * (yoffset + q->ycoord);
drawgram.c:    //printf("branch p: %f, %f q: %f, %f\n",p->xcoord, p->ycoord, q->xcoord, q->ycoord);
drawgram.c:        if ((grows == vertical && fabs(y1 - y2) >= epsilon) ||
drawgram.c:            (grows == horizontal && fabs(x1 - x2) >= epsilon)) {
drawgram.c:            miny = p->ycoord;
drawgram.c:            miny = p->xcoord;
drawgram.c:          pp = q->next;
drawgram.c:              minny = pp->back->ycoord;
drawgram.c:              minny = pp->back->xcoord;
drawgram.c:            pp = pp->next;
drawgram.c:            fract = 0.3333 * (miny - y1) / (y2 - y1);
drawgram.c:            fract = 0.3333 * (miny - x1) / (x2 - x1);
drawgram.c:        } if ((grows == vertical && fabs(y1 - y2) >= epsilon) ||
drawgram.c:              (grows == horizontal && fabs(x1 - x2) >= epsilon)) {
drawgram.c:            miny = p->ycoord;
drawgram.c:            miny = p->xcoord;
drawgram.c:          pp = q->next;
drawgram.c:              minny = pp->back->ycoord;
drawgram.c:              minny = pp->back->xcoord;
drawgram.c:            pp = pp->next;
drawgram.c:            fract = 0.3333 * (miny - y1) / (y2 - y1);
drawgram.c:            fract = 0.3333 * (miny - x1) / (x2 - x1);
drawgram.c:        swoopspline(x1,y1,x1+fract*(x2-x1),y1+fract*(y2-y1),
drawgram.c:        if (fabs(x1-x00)+fabs(y1-y00) > 0.00001) {
drawgram.c:          g = ((x1-x00)*(x2-x00)+(y1-y00)*(y2-y00))
drawgram.c:            /sqrt(((x1-x00)*(x1-x00)+(y1-y00)*(y1-y00))
drawgram.c:                  *((x2-x00)*(x2-x00)+(y2-y00)*(y2-y00)));
drawgram.c:          if (g < -1.0)
drawgram.c:            g = -1.0;
drawgram.c:          if ((x2-x00)*(y1-y00)>(x1-x00)*(y2-y00))
drawgram.c:            f = -f;
drawgram.c:          if (fabs(g-1.0) > 0.0001) {
drawgram.c:              x4 = x00 + cc*(x3-x00) - ss*(y3-y00);
drawgram.c:              y4 = y00 + ss*(x3-x00) + cc*(y3-y00);
drawgram.c:        x1 =  xscale *  (xoffset + p->xcoord);
drawgram.c:        y1 =  yscale *  (yoffset + p->ycoord);
drawgram.c:  if (p->tip)
drawgram.c:  pp = p->next;
drawgram.c:    plottree(pp->back, p);
drawgram.c:    pp = pp->next;
drawgram.c:    if (curtree->nodep[i]->tip) {
drawgram.c:      lp = curtree->nodep[i];
drawgram.c:      firstlet[i] = lengthtext(curtree->nodep[i]->nayme,1L,fontname,font)
drawgram.c:      textlength[i] = lengthtext(curtree->nodep[i]->nayme,
drawgram.c:                                 curtree->nodep[i]->naymlength, fontname, font)/fontheight;
drawgram.c:      labangle = ((draw_node*)curtree->nodep[i])->oldtheta;
drawgram.c:        right = cos(((draw_node*)curtree->nodep[i])->oldtheta) > 0.0;
drawgram.c:          dx = labelheight * expand * cos(((draw_node*)curtree->nodep[i])->oldtheta);
drawgram.c:          dy = labelheight * expand * sin(((draw_node*)curtree->nodep[i])->oldtheta);
drawgram.c:          dx += labelheight * expand * 0.5 * vec * (-cosl*sinv+sinl*cosv);
drawgram.c:          dy += labelheight * expand * 0.5 * vec * (-sinl*sinv-cosl*cosv);
drawgram.c:          dx = labelheight * expand * cos(((draw_node*)curtree->nodep[i])->oldtheta);
drawgram.c:          dy = labelheight * expand * sin(((draw_node*)curtree->nodep[i])->oldtheta);
drawgram.c:          dx -= labelheight * expand * textlength[i] * cosl;
drawgram.c:          dy -= labelheight * expand * textlength[i] * sinl;
drawgram.c:          dy += labelheight * expand * 0.5 * vec * (-sinl*cosv-cosl*sinv);
drawgram.c:        dx = labelheight * expand * cos(((draw_node*)curtree->nodep[i])->oldtheta);
drawgram.c:        dy = labelheight * expand * sin(((draw_node*)curtree->nodep[i])->oldtheta);
drawgram.c:        dx -= labelheight * expand * 0.5 * firstlet[i] * (cosl-sinl*sinv);
drawgram.c:        dy -= labelheight * expand * 0.5 * firstlet[i] * (sinl+cosl*sinv);
drawgram.c:        plottext(lp->nayme, lp->naymlength,
drawgram.c:                 xscale * (lp->xcoord + dx + xoffset),
drawgram.c:                 yscale * (lp->ycoord + dy + yoffset), 180 * (-labangle) / pi,
drawgram.c:          plottext(lp->nayme, lp->naymlength,
drawgram.c:                   xscale * (lp->xcoord + dx + xoffset),
drawgram.c:                   yscale * (lp->ycoord + dy + yoffset),
drawgram.c:                   -labelrotation, font,fontname);
drawgram.c:          plottext(lp->nayme, lp->naymlength, labelheight *
drawgram.c:                   expand * yscale, compr, xscale * (lp->xcoord + dy + xoffset),
drawgram.c:                   yscale * (lp->ycoord - dx + yoffset), 90.0 - labelrotation,
drawgram.c:    exit(-1);
drawgram.c:    /* Open in binary: ftell() is broken for UNIX line-endings under WIN32 */
drawgram.c:  treeread (curtree,intree, &curtree->root, curtree->nodep, &goteof, &firsttree, &nextnode,
drawgram.c:            &haslengths, initdrawgramnode, true, -1);
drawgram.c:  curtree->root->oldlen = 0.0;
drawgram.c:        canbeplotted = plotpreview(fontname,&xoffset,&yoffset,&scale,spp,curtree->root);
drawgram.c:    funcs->node_new = draw_node_new;
drawgram.c:  drawit(fontname,&xoffset,&yoffset,numlines,curtree->root);
drawgram.c:  funcs->node_new = draw_node_new;
drawgram.c:    drawit(fontname,&xoffset,&yoffset,numlines,curtree->root);
drawinit.c:/* Version 4.0. (c) Copyright 2012-2013 by the University of Washington.
drawinit.c:      *p = treep->get_forknode(treep, nodei);
drawinit.c:      (*p)->index = nodei;
drawinit.c:      (*p)->tip = false;
drawinit.c:        (*p)->nayme[i] = '\0';
drawinit.c:      treep->nodep[(*p)->index - 1] = (*p);
drawinit.c:      *p = treep->get_forknode(treep, nodei);
drawinit.c:      (*p)->index = nodei;
drawinit.c:      *p = treep->get_forknode(treep, nodei);
drawinit.c:      treep->nodep[(*ntips) - 1] = *p;
drawinit.c:      (*p)->tip        = true;
drawinit.c:      (*p)->naymlength = len ;
drawinit.c:      strncpy ((*p)->nayme, str, MAXNCH);
drawinit.c:        (*p)->oldlen = valyew / divisor;
drawinit.c:            (*p)->oldlen = valyew / divisor;
drawinit.c:            (*p)->oldlen = 0.0;
drawinit.c:            (*p)->oldlen = fabs ( valyew / divisor );
drawinit.c:            if ( (*p)->oldlen < epsilon )
drawinit.c:              (*p)->oldlen = epsilon;
drawinit.c:      if ((*p)->back != NULL)
drawinit.c:        (*p)->back->oldlen = (*p)->oldlen;
drawinit.c:      (*p)->naymlength = len ;
drawinit.c:      strncpy ((*p)->nayme, str, MAXNCH);
drawtree.c:/* Version 4.0.  Copyright (c) 1986-2013 by the University of Washington and
drawtree.c:  "PHYLIP version 4.0 (c) Copyright 1986-2013\r"
drawtree.c:  "PHYLIP version 4.0 (c) Copyright 1986-2013\\n"
drawtree.c:  n->init = drawtree_node_init;
drawtree.c:  dtn->r = 0;
drawtree.c:  strcpy(fontname, "Times-Roman");
drawtree.c:      printf(" Epson dot-matrix printer\n");
drawtree.c:      printf(" MS-Windows Bitmap (%d by %d resolution)\n",
drawtree.c:      printf(" Toshiba 24-pin dot matrix printer\n");
drawtree.c:      printf(" Imagewriter or C.Itoh/TEC/NEC 9-pin dot matrix printer\n");
drawtree.c:      printf(" old Okidata 9-pin dot matrix printer\n");
drawtree.c:      printf(" Rayshade ray-tracing program file format\n");
drawtree.c:      printf(" POV ray-tracing program file format\n");
drawtree.c:    else if (labelrotation <= -10.0)
drawtree.c:  else if (treea <= -100.0)
drawtree.c:  else if (treea <= -10.0)
drawtree.c:    else if (treea <= -100.0)
drawtree.c:    else if (treea <= -10.0)
drawtree.c:      printf("n-Body algorithm\n");
drawtree.c:      printf("Equal-Daylight algorithm\n");
drawtree.c:            (pagey-vpmargin) / (papery-vpmargin),
drawtree.c:            (pagex-hpmargin) / (paperx-hpmargin)) ;
drawtree.c:  n = (int)((pagex-hpmargin-0.01)/(paperx-hpmargin)+1.0);
drawtree.c:  m = (int)((pagey-vpmargin-0.01)/(papery-vpmargin)+1.0);
drawtree.c:        pagex = ((double)n * (paperx-hpmargin)+hpmargin);
drawtree.c:        pagey = ((double)m * (papery-vpmargin)+vpmargin);
drawtree.c:        printf(" horizontally (0), or downwards (-90) ?\n");
drawtree.c:          printf(" Choose an angle in degrees from 90 to -90: \n");
drawtree.c:        } while ((labelrotation < -90.0 || labelrotation > 90.0) &&
drawtree.c:                 labelrotation != -99.0);
drawtree.c:        printf(" Choose an angle in degrees from 360 to -360: \n");
drawtree.c:      } while (treeangle < -360.0 && treeangle > 360.0);
drawtree.c:  //printf("  in getwidth p->type: %i nayme: %s index: %li\n", p->type, p->nayme, p->index); //JRMDebug
drawtree.c:  if (p->tip)
drawtree.c:    pp = p->next;
drawtree.c:      //printf("pp->back: %p\n", pp->back); //JRMDebug
drawtree.c:      getwidth(pp->back);
drawtree.c:      nw += ((drawtree_node*)pp->back)->width;
drawtree.c:      if (((drawtree_node*)pp->back)->depth > nd)
drawtree.c:        nd = ((drawtree_node*)pp->back)->depth;
drawtree.c:      pp = pp->next;
drawtree.c:    } while (((p != curtree->root) && (pp != qq)) || ((p == curtree->root) && (pp != p->next)));
drawtree.c:  ((drawtree_node*)p)->depth = nd + p->length;
drawtree.c:  ((drawtree_node*)p)->width = nw;
drawtree.c:  nn = ((drawtree_node*)p)->width;
drawtree.c:  subangle = (upper - lower) / nn;
drawtree.c:  pp = p->next;
drawtree.c:  if (p->tip)
drawtree.c:    angle -= ((drawtree_node*)pp->back)->width / 2.0 * subangle;
drawtree.c:    pr = ((drawtree_node*)p)->r;
drawtree.c:    ptheta = ((draw_node*)p)->theta;
drawtree.c:        angle2 = 2 * pi / num * (long)(num * angle / (2 * pi) - 0.5);
drawtree.c:      len = fabs(pp->back->oldlen);
drawtree.c:    ((drawtree_node*)pp->back)->r = sqrt(len * len + pr * pr + 2 * len * pr *
drawtree.c:                                         cos(angle2 - ptheta));
drawtree.c:      ((draw_node*)pp->back)->theta = atan((pr * sin(ptheta) +
drawtree.c:      ((draw_node*)pp->back)->theta = pi / 2;
drawtree.c:      ((draw_node*)pp->back)->theta = 1.5 * pi;
drawtree.c:    if (pr * cos(ptheta) + len * cos(angle2) < -epsilon)
drawtree.c:      ((draw_node*)pp->back)->theta += pi;
drawtree.c:    if (!pp->back->tip)
drawtree.c:      plrtrans(pp->back, ((draw_node*)pp->back)->theta,
drawtree.c:               angle - ((drawtree_node*)pp->back)->width * subangle / 2.0,
drawtree.c:               angle + ((drawtree_node*)pp->back)->width * subangle / 2.0);
drawtree.c:      ((draw_node*)pp->back)->oldtheta = angle2;
drawtree.c:    angle -= ((drawtree_node*)pp->back)->width / 2.0 * subangle;
drawtree.c:    pp = pp->next;
drawtree.c:  } while (((p != curtree->root) && (pp != qq)) || ((p == curtree->root) && (pp != p->next)));
drawtree.c:  if (!p->tip) {
drawtree.c:    pp = p->next;
drawtree.c:      coordtrav(pp->back, xx, yy);
drawtree.c:      pp = pp->next;
drawtree.c:      if (p == curtree->root)
drawtree.c:        coordtrav(p->back, xx, yy);
drawtree.c:  (*xx) = ((drawtree_node*)p)->r * cos(((draw_node*)p)->theta);
drawtree.c:  (*yy) = ((drawtree_node*)p)->r * sin(((draw_node*)p)->theta);
drawtree.c:  p->xcoord = (*xx);
drawtree.c:  p->ycoord = (*yy);
drawtree.c:  if (x < -epsilon)
drawtree.c:    theta -= 2 * pi;
drawtree.c:  if (!p->tip)
drawtree.c:    lookatit = (p->next->next != p || p->index != curtree->root->index);
drawtree.c:    x = curtree->nodep[p->index - 1]->xcoord;
drawtree.c:    y = curtree->nodep[p->index - 1]->ycoord;
drawtree.c:    if (p->tip) {
drawtree.c:        if (cos(((draw_node*)p)->oldtheta) < 0.0)
drawtree.c:          labangle = labangle - pi;
drawtree.c:        labangle = ((draw_node*)p)->theta;
drawtree.c:        labangle = ((draw_node*)p)->oldtheta;
drawtree.c:          xxx += GAP * labelheight * cos(((draw_node*)p)->oldtheta);
drawtree.c:          yyy += GAP * labelheight * sin(((draw_node*)p)->oldtheta);
drawtree.c:          xxx += labelheight * cos(labangle) * textlength[p->index - 1];
drawtree.c:          if (textlength[p->index - 1] * sin(((draw_node*)p)->oldtheta) < 1.0)
drawtree.c:            xxx += labelheight * cos(labangle) * textlength[p->index - 1];
drawtree.c:              * textlength[p->index - 1];
drawtree.c:          yyy += labelheight * sin(labangle) * textlength[p->index - 1];
drawtree.c:          xxx += GAP * labelheight * cos(((draw_node*)p)->oldtheta);
drawtree.c:          yyy += GAP * labelheight * sin(((draw_node*)p)->oldtheta);
drawtree.c:          xxx -= labelheight * cos(labangle) * 0.5 * firstlet[p->index - 1];
drawtree.c:          yyy -= labelheight * sin(labangle) * 0.5 * firstlet[p->index - 1];
drawtree.c:          xxx += labelheight * cos(labangle) * textlength[p->index - 1];
drawtree.c:          yyy += labelheight * sin(labangle) * textlength[p->index - 1];
drawtree.c:      if ((yyy - yy) * firstx - (xxx - xx) * firsty < 0.0) {
drawtree.c:        if ((yyy - yy) * (*rightx) - (xxx - xx) * (*righty) < 0.0) {
drawtree.c:          (*rightx) = xxx - xx;
drawtree.c:          (*righty) = yyy - yy;
drawtree.c:      if ((yyy - yy) * firstx - (xxx - xx) * firsty > 0.0) {
drawtree.c:        if ((yyy - yy) * (*leftx) - (xxx - xx) * (*lefty) > 0.0) {
drawtree.c:          (*leftx) = xxx - xx;
drawtree.c:          (*lefty) = yyy - yy;
drawtree.c:    if ((y - yy) * firstx - (x - xx) * firsty < 0.0) {
drawtree.c:      if ((y - yy) * (*rightx) - (x - xx) * (*righty) < 0.0) {
drawtree.c:        (*rightx) = x - xx;
drawtree.c:        (*righty) = y - yy;
drawtree.c:    if ((y - yy) * firstx - (x - xx) * firsty > 0.0) {
drawtree.c:      if ((y - yy) * (*leftx) - (x - xx) * (*lefty) > 0.0) {
drawtree.c:        (*leftx) = x - xx;
drawtree.c:        (*lefty) = y - yy;
drawtree.c:  if (p->tip)
drawtree.c:  pp = p->next;
drawtree.c:      polartrav(pp->back, xx, yy, firstx, firsty, leftx, lefty, rightx, righty);
drawtree.c:    pp = pp->next;
drawtree.c:  pp = curtree->nodep[q->index - 1];
drawtree.c:  x = pp->xcoord;
drawtree.c:  y = pp->ycoord;
drawtree.c:  pp->xcoord = (*xx) + (x - (*xx)) * (*cosphi) + ((*yy) - y) * (*sinphi);
drawtree.c:  pp->ycoord = (*yy) + (x - (*xx)) * (*sinphi) + (y - (*yy)) * (*cosphi);
drawtree.c:  if (q->tip)
drawtree.c:  pp = q->next;
drawtree.c:    if (pp->back != NULL)
drawtree.c:      tilttrav(pp->back, xx, yy, sinphi, cosphi);
drawtree.c:    pp = pp->next;
drawtree.c:  if (fabs(p->xcoord - (*xx)) > epsilon)
drawtree.c:    ((draw_node*)p)->oldtheta = atan((p->ycoord - (*yy)) /
drawtree.c:                                     (p->xcoord - (*xx)));
drawtree.c:  else if (p->ycoord - (*yy) > epsilon)
drawtree.c:    ((draw_node*)p)->oldtheta = pi / 2;
drawtree.c:  if (p->xcoord - (*xx) < -epsilon)
drawtree.c:    ((draw_node*)p)->oldtheta += pi;
drawtree.c:  if (fabs(p->xcoord - curtree->root->xcoord) > epsilon)
drawtree.c:    ((draw_node*)p)->theta =
drawtree.c:      atan((p->ycoord - curtree->root->ycoord) / (p->xcoord - curtree->root->xcoord));
drawtree.c:  else if (p->ycoord - curtree->root->ycoord > 0.0)
drawtree.c:    ((draw_node*)p)->theta = pi / 2;
drawtree.c:    ((draw_node*)p)->theta = 1.5 * pi;
drawtree.c:  if (p->xcoord - curtree->root->xcoord < -epsilon)
drawtree.c:    ((draw_node*)p)->theta += pi;
drawtree.c:  TEMP = p->xcoord - curtree->root->xcoord;
drawtree.c:  TEMP1 = p->ycoord - curtree->root->ycoord;
drawtree.c:  ((drawtree_node*)p)->r = sqrt(TEMP * TEMP + TEMP1 * TEMP1);
drawtree.c:  firstx = curtree->nodep[p->back->index-1]->xcoord - xx;
drawtree.c:  firsty = curtree->nodep[p->back->index-1]->ycoord - yy;
drawtree.c:  if (p->back != NULL)
drawtree.c:    polartrav(p->back, xx, yy, firstx, firsty, &leftx, &lefty, &rightx, &righty);
drawtree.c:    langle = ((draw_node*)p->back)->oldtheta;
drawtree.c:    rangle = ((draw_node*)p->back)->oldtheta;
drawtree.c:  while (langle - rangle > 2*pi)
drawtree.c:    langle -= 2 * pi;
drawtree.c:      rangle -= 2 * pi;
drawtree.c:    rangle -= 2 * pi;
drawtree.c:    langle -= 2 * pi;
drawtree.c:  ((drawtree_node*)p)->lefttheta = langle;
drawtree.c:  ((drawtree_node*)p)->righttheta = rangle;
drawtree.c:  if (p->tip)
drawtree.c:  xx = p->xcoord;
drawtree.c:  yy = p->ycoord;
drawtree.c:  pp = p->next;
drawtree.c:    pp = pp->next;
drawtree.c:  } while ((pp != p->next));
drawtree.c:  if (p == curtree->root) {
drawtree.c:    pp = p->next;
drawtree.c:      pp = pp->next;
drawtree.c:    } while (pp != curtree->root);
drawtree.c:    ((drawtree_node*)p)->righttheta = ((drawtree_node*)qq)->righttheta;
drawtree.c:    ((drawtree_node*)p)->lefttheta = ((drawtree_node*)p->next)->lefttheta;
drawtree.c:  pp = p->next;
drawtree.c:  ppp = p->next->next;
drawtree.c:    langle = ((drawtree_node*)qq)->righttheta -
drawtree.c:      ((drawtree_node*)pp)->lefttheta;
drawtree.c:    rangle = ((drawtree_node*)pp)->righttheta -
drawtree.c:      ((drawtree_node*)ppp)->lefttheta;
drawtree.c:      langle -= 2*pi;
drawtree.c:    while (langle < -pi)
drawtree.c:      rangle -= 2*pi;
drawtree.c:    while (rangle < -pi)
drawtree.c:    olddiff = fabs(langle-rangle);
drawtree.c:    sumrot = (langle - rangle) /2.0;
drawtree.c:    if (sumrot < -rangle)
drawtree.c:      sumrot = -rangle;
drawtree.c:    if (p != curtree->root) {
drawtree.c:      ((draw_node*)pp->back)->oldtheta += sumrot;
drawtree.c:      tilttrav(pp->back, &xx, &yy, &sinphi, &cosphi);
drawtree.c:      polarize(pp->back, &xx, &yy);
drawtree.c:      langle = ((drawtree_node*)qq)->righttheta -
drawtree.c:        ((drawtree_node*)pp)->lefttheta;
drawtree.c:      rangle = ((drawtree_node*)pp)->righttheta -
drawtree.c:        ((drawtree_node*)ppp)->lefttheta;
drawtree.c:        langle -= 2*pi;
drawtree.c:      while (langle < -pi)
drawtree.c:        rangle -= 2*pi;
drawtree.c:      while (rangle < -pi)
drawtree.c:      while ((fabs(langle-rangle) > olddiff) && (fabs(sumrot) > 0.01)) {
drawtree.c:        cosphi = cos(-sumrot);
drawtree.c:        sinphi = sin(-sumrot);
drawtree.c:        ((draw_node*)pp->back)->oldtheta -= sumrot;
drawtree.c:        tilttrav(pp->back, &xx, &yy, &sinphi, &cosphi);
drawtree.c:        polarize(pp->back, &xx, &yy);
drawtree.c:        langle = ((drawtree_node*)qq)->righttheta -
drawtree.c:          ((drawtree_node*)pp)->lefttheta;
drawtree.c:        rangle = ((drawtree_node*)pp)->righttheta -
drawtree.c:          ((drawtree_node*)ppp)->lefttheta;
drawtree.c:          langle -= 2*pi;
drawtree.c:        if (langle < -pi)
drawtree.c:          rangle -= 2*pi;
drawtree.c:        if (rangle < -pi)
drawtree.c:    pp = pp->next;
drawtree.c:    ppp = ppp->next;
drawtree.c:  } while (((p == curtree->root) && (pp != p->next)) || ((p != curtree->root) && (pp != p)));
drawtree.c:  pp = p->next;
drawtree.c:    improvtrav(pp->back);
drawtree.c:    pp = pp->next;
drawtree.c:  while (((p == curtree->root) && (pp != p->next)) || ((p != curtree->root) && (pp != p)));
drawtree.c:  distanceX = pFromSubNode->xcoord - pToSubNode->xcoord;
drawtree.c:  distanceY = pFromSubNode->ycoord - pToSubNode->ycoord;
drawtree.c:  *pAngle = computeAngle(pFromSubNode->xcoord, pFromSubNode->ycoord,
drawtree.c:                         pToSubNode->xcoord, pToSubNode->ycoord);
drawtree.c:  while (pSubNode->next != NULL && pSubNode->next != pPivotSubNode)
drawtree.c:    pSubNode = pSubNode->next;
drawtree.c:    if ( pSubNode->back != NULL && pSubNode->back != pToSubNode)
drawtree.c:      totalForceOnNode(pSubNode->back, pToSubNode, pTotalForce, pAngle,
drawtree.c:  /* visit this branch; You need to visit it for the first time - at root only!
drawtree.c:  if ( pPivotSubNode == curtree->root && pPivotSubNode->back != NULL
drawtree.c:       && pPivotSubNode->back != pToSubNode)
drawtree.c:    totalForceOnNode(pPivotSubNode->back, pToSubNode, pTotalForce, pAngle,
drawtree.c:  force_1to1(curtree->nodep[pPivotSubNode->index-1], pToSubNode, &force, &angle,
drawtree.c:      angle = angle - 2*pi;
drawtree.c:    printf("ERROR:  drawtree - division by zero in angleBetVectors()!\n");
drawtree.c:  if (cosTheta > 1) /* cosTheta will only be > 1 or < -1 due to rounding errors */
drawtree.c:  else if (cosTheta < -1)
drawtree.c:    theta = pi; /* cosTheta = -1 */
drawtree.c:  angleForce = angleForce - angleReference;
drawtree.c:    /* positive sign - force pointing toward the left of the reference
drawtree.c:    sign = -1;
drawtree.c:  Pivot   o-----------
drawtree.c:  xDelta = curtree->nodep[pToSubNode->index-1]->xcoord -
drawtree.c:    curtree->nodep[pPivotSubNode->index-1]->xcoord;
drawtree.c:  yDelta = curtree->nodep[pToSubNode->index-1]->ycoord -
drawtree.c:    curtree->nodep[pPivotSubNode->index-1]->ycoord;
drawtree.c:  if (xDelta < 0) tempx = -xDelta;
drawtree.c:  if (yDelta < 0) tempy = -yDelta;
drawtree.c:    alpha = theta - pi/2;
drawtree.c:    alpha = pi/2 - theta;
drawtree.c:  if (forcePerpendicular < -epsilon)
drawtree.c:    printf("ERROR:  drawtree - forcePerpendicular applied at an angle should"
drawtree.c:  /* added - danieyek 990128 */
drawtree.c:     to convert the x-y coordinates to theta and radius, you won't get result on
drawtree.c:     except the starting subnode (where the parent is), thus converting the x-y
drawtree.c:  polarize( curtree->nodep[pStartingSubNode->index - 1], xx, yy);
drawtree.c:  while (pSubNode->next != NULL && pSubNode->next != pStartingSubNode)
drawtree.c:    pSubNode = pSubNode->next;
drawtree.c:    if ( pSubNode->tip != true )
drawtree.c:      polarizeABranch(pSubNode->back, xx, yy);
drawtree.c:  /* added - danieyek 990204 */
drawtree.c:    printf("ERROR:  drawtree - error using pushNodeToStack(); ppStackTop is NULL.\n");
drawtree.c:  pStackElem->pStackElemBack = *ppStackTop;
drawtree.c:  pStackElem->pNode = pNode;
drawtree.c:  /* added - danieyek 990205 */
drawtree.c:    printf("ERROR:  drawtree - a call to pop while the stack is empty.\n");
drawtree.c:  *ppStackTop = pStackT->pStackElemBack;
drawtree.c:  *ppNode  = pStackT->pNode;
drawtree.c:  /* added - danieyek 990208 */
drawtree.c:     call to this function) - the center, with
drawtree.c:  while (pSubNode->next != NULL && pSubNode->next != pRootSubNode)
drawtree.c:    pSubNode = pSubNode->next;
drawtree.c:    if ( pSubNode->back != NULL)
drawtree.c:      medianOfDistance(pSubNode->back, false);
drawtree.c:  /* visit this branch; You need to visit it for the first time - at root
drawtree.c:  if ( firstRecursiveCallP == true && pRootSubNode->back != NULL)
drawtree.c:    medianOfDistance(pRootSubNode->back, false);
drawtree.c:  xDelta = curtree->nodep[pSubNode->index-1]->xcoord -
drawtree.c:    curtree->nodep[pReferenceNode->index-1]->xcoord;
drawtree.c:  yDelta = curtree->nodep[pSubNode->index-1]->ycoord -
drawtree.c:    curtree->nodep[pReferenceNode->index-1]->ycoord;
drawtree.c:    printf("Fatal ERROR:  drawtree - Insufficient Memory in medianOfDistance()!\n");
drawtree.c:  pLink->value = distance;
drawtree.c:  pLink->pBack = pFrontOfLinkedList;
drawtree.c:      distance = pFrontOfLinkedList->value;
drawtree.c:      distance = (pFrontOfLinkedList->value +
drawtree.c:                  pFrontOfLinkedList->pBack->value)/(double)2;
drawtree.c:      free(pFrontOfLinkedList->pBack);
drawtree.c:      /* SORT first - use bubble sort; we start with at least 3 elements here. */
drawtree.c:      for (j = 0; j < count - 1; j++)
drawtree.c:        pBackElem = junkLink.pBack->pBack;
drawtree.c:        for (i = j; i < count - 1; i++)
drawtree.c:          if(pMidElem->value < pBackElem->value)
drawtree.c:            /* Swap - carry the smaller value to the root of the linked list. */
drawtree.c:            pMidElem->pBack = pBackElem->pBack;
drawtree.c:            pBackElem->pBack = pMidElem;
drawtree.c:            pFrontElem->pBack = pBackElem;
drawtree.c:            pBackElem = pMidElem->pBack;
drawtree.c:            pBackElem = pBackElem->pBack;
drawtree.c:        pFrontOfLinkedList = pLink->pBack;
drawtree.c:      /* Get the return value!! - only the last return value is the valid one. */
drawtree.c:      distance = pFrontOfLinkedList->value;
drawtree.c:        pFrontOfLinkedList = pLink->pBack;
drawtree.c:/* As usual, pToSubNode->back is the angle
drawtree.c:  /* pPivotNode is nodep[pToSubNode->back->index-1], not pPivotSubNode
drawtree.c:     which is just pToSubNode->back! */
drawtree.c:  /* Make an assumption first - guess "pToSubNode->back->next" is the right
drawtree.c:  if (pToSubNode->back->tip == true)
drawtree.c:    printf("ERROR:  In leftRightLimits() - Pivoted at a leaf! Unable to "
drawtree.c:  else if (pToSubNode->back->next->next == pToSubNode->back)
drawtree.c:  pPivotNode = curtree->nodep[pToSubNode->back->index-1];
drawtree.c:  /* 3 or more branches - the regular case. */
drawtree.c:  /* First, initialize the pRightSubNode - non-repeative portion of the code */
drawtree.c:  pRightSubNode = pToSubNode->back;
drawtree.c:  pLeftSubNode = pToSubNode->back;
drawtree.c:  xToNodeVector = curtree->nodep[pToSubNode->index-1]->xcoord - pPivotNode->xcoord;
drawtree.c:  yToNodeVector = curtree->nodep[pToSubNode->index-1]->ycoord - pPivotNode->ycoord;
drawtree.c:  while( curtree->nodep[pRightSubNode->index-1]->tip != true )
drawtree.c:    pRightSubNode = pRightSubNode->next->back;
drawtree.c:    xRightVector = curtree->nodep[pRightSubNode->index-1]->xcoord - pPivotNode->xcoord;
drawtree.c:    yRightVector = curtree->nodep[pRightSubNode->index-1]->ycoord - pPivotNode->ycoord;
drawtree.c:  while( curtree->nodep[pLeftSubNode->index-1]->tip != true )
drawtree.c:    pSubNode = pLeftSubNode->next->next;
drawtree.c:    while (pSubNode->next != pLeftSubNode)
drawtree.c:      pSubNode = pSubNode->next;
drawtree.c:    pLeftSubNode = pSubNode->back;
drawtree.c:    xLeftVector = curtree->nodep[pLeftSubNode->index-1]->xcoord - pPivotNode->xcoord;
drawtree.c:    yLeftVector = curtree->nodep[pLeftSubNode->index-1]->ycoord - pPivotNode->ycoord;
drawtree.c:  /* added - danieyek 990226 */
drawtree.c:     pPivotSubNode->back is the pToNode, to which node you apply the forces!
drawtree.c:  /* Abandoned as it is similar to day-light algorithm; the first part is
drawtree.c:  /* Base case : a leaf - return 0 & 0.  */
drawtree.c:  if ( curtree->nodep[pCurSubNode->index-1]->tip == true )
drawtree.c:    xPivotVector = curtree->nodep[pPivotSubNode->back->index-1]->xcoord
drawtree.c:      - curtree->nodep[pPivotSubNode->index-1]->xcoord;
drawtree.c:    yPivotVector = curtree->nodep[pPivotSubNode->back->index-1]->ycoord
drawtree.c:      - curtree->nodep[pPivotSubNode->index-1]->ycoord;
drawtree.c:    xCurNodeVector = curtree->nodep[pCurSubNode->index-1]->xcoord
drawtree.c:      - curtree->nodep[pPivotSubNode->index-1]->xcoord;
drawtree.c:    yCurNodeVector = curtree->nodep[pCurSubNode->index-1]->ycoord
drawtree.c:      - curtree->nodep[pPivotSubNode->index-1]->ycoord;
drawtree.c:  pPivot = pToNode->back;
drawtree.c:  xDistance = curtree->nodep[pPivot->index-1]->xcoord - curtree->nodep[pToNode->index-1]->xcoord;
drawtree.c:  yDistance = curtree->nodep[pPivot->index-1]->ycoord - curtree->nodep[pToNode->index-1]->ycoord;
drawtree.c:    else if ( -angleRotate > limitFactor * rightLimit )
drawtree.c:      angleRotate = - limitFactor * rightLimit;
drawtree.c:           &(curtree->nodep[pPivot->index - 1]->xcoord),
drawtree.c:           &(curtree->nodep[pPivot->index - 1]->ycoord),
drawtree.c:                  &(curtree->nodep[pPivot->index - 1]->xcoord),
drawtree.c:                  &(curtree->nodep[pPivot->index - 1]->ycoord));
drawtree.c:  /* improvtrav for n-body. */
drawtree.c:  medianDistance = medianOfDistance(curtree->root, true);
drawtree.c:    /* First, push all subNodes in the root node onto the stack-to-be-used
drawtree.c:    while(pSubNode->next != pStartingSubNode)
drawtree.c:      pSubNode = pSubNode->next;
drawtree.c:        pBackStartNode = pSubNode->back;
drawtree.c:        if (pBackStartNode->tip == true)
drawtree.c:          improveNodeAngle(pSubNode->back, medianDistance);
drawtree.c:          /* Push all subNodes in this pSubNode->back onto the stack-to-be-used,
drawtree.c:           * stack-to-be-used, after poping a pivot subNode. If
drawtree.c:           * pSubNode->back is a leaf, no push on stack. */
drawtree.c:          while(pBackSubNode->next != pBackStartNode)
drawtree.c:            pBackSubNode = pBackSubNode->next;
drawtree.c:          improveNodeAngle(pSubNode->back, medianDistance);
drawtree.c:  if (nbody)       /* n-body algorithm */
drawtree.c:    improvtravn(curtree->root);
drawtree.c:  else {          /* equal-daylight algorithm */
drawtree.c:      improvtrav(curtree->root);
drawtree.c:    ((drawtree_node*)curtree->nodep[i])->width = 1.0;
drawtree.c:  //printf("after nodep->width\n"); //JRMDebug
drawtree.c:    curtree->nodep[i]->xcoord = 0.0;
drawtree.c:  //printf("after nodep->xcoord\n"); //JRMDebug
drawtree.c:    curtree->nodep[i]->ycoord = 0.0;
drawtree.c:  //printf("after nodep->ycoord\n"); //JRMDebug
drawtree.c:      curtree->nodep[i]->length = 1.0;
drawtree.c:      curtree->nodep[i]->length = fabs(curtree->nodep[i]->oldlen);
drawtree.c:           i, ((drawtree_node*)nodep[i])->width, nodep[i]->xcoord, nodep[i]->ycoord, nodep[i]->length);
drawtree.c:  //printf("calling getwidth root: %p root->type: %i nayme: %s index: %li\n", root, root->type, root->nayme, root->index);  //JRMDebug
drawtree.c:  getwidth(curtree->root);
drawtree.c:  nttot = ((drawtree_node*)curtree->root)->width;
drawtree.c:    ((drawtree_node*)curtree->nodep[i])->width = ((drawtree_node*)curtree->nodep[i])->width * spp / nttot;
drawtree.c:    plrtrans(curtree->root, treeangle, treeangle - ark / 2.0, treeangle + ark / 2.0);
drawtree.c:  else plrtrans(curtree->root, treeangle, treeangle - pi, treeangle + pi);
drawtree.c:  coordtrav(curtree->root, &xx, &yy);
drawtree.c:    if (curtree->nodep[i]->tip) {
drawtree.c:      textlength[i] = lengthtext(curtree->nodep[i]->nayme,
drawtree.c:                                curtree->nodep[i]->naymlength, fontname, font);
drawtree.c:      firstlet[i] = lengthtext(curtree->nodep[i]->nayme, 1L, fontname, font)
drawtree.c:    labelheight = charht * (maxx - minx) / (spp - 1);
drawtree.c:    labelheight = charht * (maxx - minx);
drawtree.c:    coordtrav(curtree->root, &xx, &yy);
drawtree.c:    if (curtree->nodep[i]->tip) {
drawtree.c:        labangle = ((draw_node*)curtree->nodep[i])->theta;
drawtree.c:        labangle = ((draw_node*)curtree->nodep[i])->oldtheta;
drawtree.c:        labangle -= pi;
drawtree.c:      firstlet[i] = lengthtext(curtree->nodep[i]->nayme, 1L, fontname, font)
drawtree.c:      top = (curtree->nodep[i]->ycoord - maxy) / labelheight +
drawtree.c:        sin(((draw_node*)curtree->nodep[i])->oldtheta);
drawtree.c:      rig = (curtree->nodep[i]->xcoord - maxx) / labelheight +
drawtree.c:        cos(((draw_node*)curtree->nodep[i])->oldtheta);
drawtree.c:      bot = (miny - curtree->nodep[i]->ycoord) / labelheight -
drawtree.c:        sin(((draw_node*)curtree->nodep[i])->oldtheta);
drawtree.c:      lef = (minx - curtree->nodep[i]->xcoord) / labelheight -
drawtree.c:        cos(((draw_node*)curtree->nodep[i])->oldtheta);
drawtree.c:      if (cos(labangle) * cos(((draw_node*)curtree->nodep[i])->oldtheta) +
drawtree.c:          sin(labangle) * sin(((draw_node*)curtree->nodep[i])->oldtheta) > 0.0) {
drawtree.c:        top += sin(labangle - 1.25 * pi) * GAP * firstlet[i];
drawtree.c:          bot -= sin(labangle) * textlength[i];
drawtree.c:        bot -= sin(labangle - 0.75 * pi) * GAP * firstlet[i];
drawtree.c:          rig += cos(labangle - 0.75 * pi) * GAP * firstlet[i];
drawtree.c:          rig += cos(labangle - 1.25 * pi) * GAP * firstlet[i];
drawtree.c:          lef -= cos(labangle - 1.25 * pi) * GAP * firstlet[i];
drawtree.c:          lef -= cos(labangle - 0.75 * pi) * GAP * firstlet[i];
drawtree.c:          top -= sin(labangle) * textlength[i];
drawtree.c:        bot -= sin(labangle - 0.25 * pi) * GAP * firstlet[i];
drawtree.c:          rig += cos(labangle - 0.25 * pi) * GAP * firstlet[i];
drawtree.c:          lef -= cos(labangle + 0.25 * pi) * GAP * firstlet[i];
drawtree.c:          lef -= cos(labangle - 0.25 * pi) * GAP * firstlet[i];
drawtree.c:  treeheight = maxy - miny + topoflabels + bottomoflabels;
drawtree.c:  treewidth = maxx - minx + rightoflabels + leftoflabels;
drawtree.c:      expand = (xsize - 2 * xmargin) / treewidth;
drawtree.c:      if ((ysize - 2 * ymargin) / treeheight < expand)
drawtree.c:        expand = (ysize - 2 * ymargin) / treeheight;
drawtree.c:    extrax = (xsize - 2 * xmargin - treewidth * expand) / 2.0;
drawtree.c:    extray = (ysize - 2 * ymargin - treeheight * expand) / 2.0;
drawtree.c:      expand = (ysize - 2 * ymargin) / treewidth;
drawtree.c:      if ((xsize - 2 * xmargin) / treeheight < expand)
drawtree.c:        expand = (xsize - 2 * xmargin) / treeheight;
drawtree.c:    extrax = (xsize - 2 * xmargin - treeheight * expand) / 2.0;
drawtree.c:    extray = (ysize - 2 * ymargin - treewidth * expand) / 2.0;
drawtree.c:    curtree->nodep[i]->xcoord = expand * (curtree->nodep[i]->xcoord - minx + leftoflabels);
drawtree.c:    curtree->nodep[i]->ycoord = expand * (curtree->nodep[i]->ycoord - miny + bottomoflabels);
drawtree.c:      temp = curtree->nodep[i]->ycoord;
drawtree.c:      curtree->nodep[i]->ycoord = expand * treewidth - curtree->nodep[i]->xcoord;
drawtree.c:      curtree->nodep[i]->xcoord = temp;
drawtree.c:    curtree->nodep[i]->xcoord += xmargin + extrax;
drawtree.c:    curtree->nodep[i]->ycoord += ymargin + extray;
drawtree.c:  x2 = xscale * (xoffset + p->xcoord);
drawtree.c:  y2 = yscale * (yoffset + p->ycoord);
drawtree.c:  if (p != curtree->root) {
drawtree.c:    x1 = xscale * (xoffset + q->xcoord);
drawtree.c:    y1 = yscale * (yoffset + q->ycoord);
drawtree.c:  if (p->tip)
drawtree.c:  pp = p->next;
drawtree.c:    plottree(pp->back, p);
drawtree.c:    pp = pp->next;
drawtree.c:  } while (((p == curtree->root) && (pp != p->next)) || ((p != curtree->root) && (pp != p)));
drawtree.c:    if (curtree->nodep[i]->tip) {
drawtree.c:      lp = curtree->nodep[i];
drawtree.c:        labangle = ((draw_node*)curtree->nodep[i])->theta;
drawtree.c:        labangle = ((draw_node*)curtree->nodep[i])->oldtheta;
drawtree.c:        labangle -= pi;
drawtree.c:      sino = sin(((draw_node*)curtree->nodep[i])->oldtheta);
drawtree.c:      coso = cos(((draw_node*)curtree->nodep[i])->oldtheta);
drawtree.c:        if ((textlength[i]+1.0)*fabs(tan(((draw_node*)curtree->nodep[i])->oldtheta))
drawtree.c:          dx = -0.5 * textlength[i] * labelheight * expand;
drawtree.c:            if (fabs(((draw_node*)curtree->nodep[i])->oldtheta - pi/2.0) > 1000.0)
drawtree.c:                (2.0*tan(((draw_node*)curtree->nodep[i])->oldtheta));
drawtree.c:            dy = -1.5 * labelheight * expand;
drawtree.c:            if (fabs(((draw_node*)curtree->nodep[i])->oldtheta - pi/2.0) > 1000.0)
drawtree.c:                (2.0*tan(((draw_node*)curtree->nodep[i])->oldtheta));
drawtree.c:            dy = (-0.5 + (0.5*textlength[i]+0.5)*tan(((draw_node*)curtree->nodep[i])->oldtheta))
drawtree.c:            dx = -(textlength[i]+0.5) * labelheight * expand;
drawtree.c:            dy = (-0.5 - (0.5*textlength[i]+0.5)*tan(((draw_node*)curtree->nodep[i])->oldtheta))
drawtree.c:          dx += labelheight * expand * 0.5 * vec * (-cosl*cosv+sinl*sinv);
drawtree.c:          dy += labelheight * expand * 0.5 * vec * (-sinl*cosv-cosl*sinv);
drawtree.c:          dy += labelheight * expand * 0.5 * vec * (sinl*cosv-cosl*sinv);
drawtree.c:          dx -= textlength[i] * labelheight * expand * cosl;
drawtree.c:          dy -= textlength[i] * labelheight * expand * sinl;
drawtree.c:      plottext(lp->nayme, lp->naymlength,
drawtree.c:               xscale * (lp->xcoord + dx + xoffset),
drawtree.c:               yscale * (lp->ycoord + dy + yoffset), -180 * labangle / pi,
drawtree.c:        canbeplotted=plotpreview(fontname, &xoffset, &yoffset, &scale, spp, curtree->root);
drawtree.c:    exxit(-1);
drawtree.c:    /* Open in binary: ftell() is broken for UNIX line-endings under WIN32 */
drawtree.c:  treeread (curtree, intree, &curtree->root, curtree->nodep, &goteof, &firsttree, &nextnode, &haslengths, initdrawtreenode, true, -1);
drawtree.c:  q = curtree->root;
drawtree.c:  r = curtree->root;
drawtree.c:  while (!(q->next == curtree->root))
drawtree.c:    q = q->next;
drawtree.c:  q->next = curtree->root->next;
drawtree.c:  curtree->root = q;
drawtree.c:  curtree->nodep[spp] = q;
drawtree.c:  where = curtree->root;
drawtree.c:    //printf("Tree after reroot root: %p  next: %p back: %p\n", root, root->next, root->back); //JRMDebug
drawtree.c:  funcs->node_new = drawtree_node_new;
drawtree.c:  drawit(fontname, &xoffset, &yoffset, numlines, curtree->root);
drawtree.c:  funcs->node_new = drawtree_node_new;
drawtree.c:    drawit(fontname, &xoffset, &yoffset, numlines, curtree->root);
dumptree.c:/* Version 4.0. (c) Copyright 2012-2013 by the University of Washington.
dumptree.c:      // might also instead use p->node_print_f(p)
dumptree.c:      printf("%p [%p] :: ",p,p->back);
dumptree.c:      p = p->next;
dumptree.c:  printf("%s%p\n",indent,n->back);
dumptree.c:  printf ("%s%3ld: %p %ld\n",indent,index,n,n->index);
dumptree.c:  printf("%sSlist %s length %ld\n",indent,name,s->length);
dumptree.c:  printf ("\ttree root %p\n", t->root);
dumptree.c:  printf ("\tnum nodes %ld\n", t->nonodes);
dumptree.c:  printf ("\tnum spp   %ld\n", t->spp);
dumptree.c:  dumpSlist(t->free_forkrings, "\t", "forkrings");
dumptree.c:  dumpSlist(t->free_forknodes, "\t", "forknodes");
dumptree.c:  dumppointarray(t->nodep,t->nonodes, "\t");
factor.c:/* Version 4.0. (c) Copyright 1988-2013 by the University of Washington.
factor.c:   Additional code by Joe Felsenstein, 1988-1991
factor.c:    printf("\nFactor -- multistate to binary recoding program, version %s\n\n", VERSION);
factor.c:  /* Reads a single character-state tree; puts adjacent symbol
factor.c:    pair[npairs - 1][0] = ch;
factor.c:      exxit(-1);}
factor.c:    nextch(&pair[npairs - 1][1]);
factor.c:    if (eoln(infile) && pair[npairs - 1][1] == ' ') {
factor.c:      exxit(-1);}
factor.c:      if (poynter->state == pair[i][j - 1]) {
factor.c:            if (*otherone != '.' && *otherone != poynter->ancstr->state) {
factor.c:              while (*otherone != symbarray[k - 1])
factor.c:              if (nodes[k - offset - 1] != NULL)
factor.c:                exxit(-1);
factor.c:              ptr->ancstr = poynter;
factor.c:              ptr->descendant = NULL;
factor.c:              ptr->sibling = NULL;
factor.c:              ptr->state = *otherone;
factor.c:                poynter->descendant = ptr;   /* If first */
factor.c:                linker->sibling = ptr;
factor.c:              nodes[k - offset - 1] = ptr;
factor.c:  maketree(poynter->descendant, otherone);
factor.c:  maketree(poynter->sibling, otherone);
factor.c:  ancsymbol[charindex - 1] = '?';
factor.c:        if (pair[i][j - 1] == symbarray[offset + k - 1])
factor.c:        if (pair[i][j - 1] == '.') {
factor.c:            exxit(-1);
factor.c:          ancsymbol[charindex - 1] = '0';
factor.c:          symbarray[offset + nstates - 1] = pair[i][j - 1];
factor.c:    exxit(-1);
factor.c:  root->state = ' ';
factor.c:  root->descendant = (statenode *)Malloc(sizeof(statenode));
factor.c:  root->descendant->ancstr = root;
factor.c:  root = root->descendant;
factor.c:  root->descendant = NULL;
factor.c:  root->sibling = NULL;
factor.c:  root->state = rootstate;
factor.c:  while (symbarray[offset + i - 1] != rootstate)
factor.c:  nodes[i - 1] = root;
factor.c:        exxit(-1);}
factor.c:        poynter = nodes[i]->ancstr;
factor.c:          poynter = poynter->ancstr;
factor.c:          exxit(-1);}
factor.c:  poynter->edge = *edgenum;
factor.c:  numberedges(poynter->descendant, edgenum);
factor.c:  numberedges(poynter->sibling, edgenum);
factor.c:    place = factoroffset + (nstates - 1) * i;
factor.c:    for (j = place; j <= (place + nstates - 2); j++)
factor.c:      symbarray[place + poynter->edge - 1] = '1';
factor.c:      poynter = poynter->ancstr;
factor.c:  /* Process character-state trees */
factor.c:    exxit(-1);
factor.c:      exxit(-1);
factor.c:    readtree();   /* Process character-state tree  */
factor.c:      ancsymbol[charindex - 1] = '?';
factor.c:    charnum[charindex - 1] = charnumber;
factor.c:    chstart[charindex - 1] = offset;
factor.c:    numstates[charindex - 1] = nstates;
factor.c:      exxit(-1);
factor.c:  symbol = '-';
factor.c:    if (symbol == '-')
factor.c:      symbol = '-';
factor.c:  while (ancsymbol[charindex - 1] == '?')
factor.c:      exxit(-1);
factor.c:      writech(multichar[charnum[charindex] - 1], chposition, outfile);
factor.c:      while (symbarray[chstart[charindex] + i - 1] !=
factor.c:             multichar[charnum[charindex] - 1] && i <= numstates[charindex])
factor.c:        if( multichar[charnum[charindex] - 1] == unkchar) {
factor.c:          printf("'%c' is not a documented state.\n\n", multichar[charnum[charindex] - 1]);
factor.c:          exxit(-1);
factor.c:        place = chstart[charindex] + numstates[charindex] + (numstates[charindex] - 1) * (i - 1);
factor.c:        for (i = 0; i <= (numstates[charindex] - 2); i++)
factor.c:      totalfactors += numstates[charindex] - 1;
factor.c:  fprintf(outfile, "\nFactor -- multistate to binary recoding program, version %s\n\n", VERSION);
factor.c:    exxit(-1);
factor.c:  dotrees();   // Read and factor character-state trees
fitch.c:/* Version 4.0. (c) Copyright 1993-2013 by the University of Washington.
fitch.c:#define zsmoothings     10    /* number of zero-branch correction iterations */
fitch.c:  ml_tree_init(&(ft->ml_tree.tree), nonodes, spp);
fitch.c:  t->evaluate = fitch_evaluate;
fitch.c:  t->insert_ = ml_tree_insert_;
fitch.c:  t->re_move = ml_tree_re_move;
fitch.c:  t->nuview = fitch_nuview;
fitch.c:  ft->ml_tree.makenewv = fitch_makenewv;
fitch.c:    printf("\nFitch-Margoliash method version %s\n\n", VERSION);
fitch.c:    printf("  D      Method (F-M, Minimum Evolution)?  %s\n",
fitch.c:           (minev ? "Minimum Evolution" : "Fitch-Margoliash"));
fitch.c:    printf("  -      Negative branch lengths allowed?  %s\n",
fitch.c:    printf("  L         Lower-triangular data matrix?");
fitch.c:    printf("  R         Upper-triangular data matrix?");
fitch.c:      if (((!usertree) && (strchr("DJOUNPG-LRSM01234", ch) != NULL))
fitch.c:          || (usertree && ((strchr("DOUNPG-LRSM01234", ch) != NULL))))
fitch.c:          case '-':
fitch.c:    exxit(-1);
fitch.c:    nonodes--;
fitch.c:  fprintf(outfile, "\nFitch-Margoliash method version %s\n\n", VERSION);
fitch.c:  fprintf(outfile, "                  \\  \\   (Obs - Exp)\n");
fitch.c:  fprintf(outfile, "Sum of squares =  /_ /_  ------------\n");
fitch.c:  z = y + q->v;
fitch.c:  if (q->tip) {
fitch.c:    TEMP = ((dist_node*)q)->d[(*nx) - 1] - z;
fitch.c:    *sum += ((dist_node*)q)->w[(*nx) - 1] * (TEMP * TEMP);
fitch.c:    secondtraverse(q->next->back, z, nx, sum);
fitch.c:    secondtraverse(q->next->next->back, z, nx, sum);
fitch.c:  if (minev && (p != curtree->root))
fitch.c:    *sum += p->v;
fitch.c:  if (p->tip) {
fitch.c:      *nx = p->index;
fitch.c:      secondtraverse(p->back, 0.0, nx, sum);
fitch.c:    firsttraverse(p->next->back, nx, sum);
fitch.c:    firsttraverse(p->next->next->back, nx, sum);
fitch.c:  firsttraverse(p->back, &nx, &sum);
fitch.c:  t->score = -sum;
fitch.c:  return (-sum);
fitch.c:  qprime = x->next;
fitch.c:  rprime = qprime->next->back;
fitch.c:  qprime = qprime->back;
fitch.c:  ny = y->index;
fitch.c:  dil = ((dist_node*)qprime)->d[ny - 1];
fitch.c:  djl = ((dist_node*)rprime)->d[ny - 1];
fitch.c:  wil = ((dist_node*)qprime)->w[ny - 1];
fitch.c:  wjl = ((dist_node*)rprime)->w[ny - 1];
fitch.c:  vi = qprime->v;
fitch.c:  vj = rprime->v;
fitch.c:  ((dist_node*)x)->w[ny - 1] = wil + wjl;
fitch.c:    ((dist_node*)x)->d[ny - 1] = 0.0;
fitch.c:    ((dist_node*)x)->d[ny - 1] = ((dil - vi) * wil + (djl - vj) * wjl) /
fitch.c:  nx = x->index;
fitch.c:  nq = qprime->index;
fitch.c:  nr = rprime->index;
fitch.c:  dil = ((dist_node*)y)->d[nq - 1];
fitch.c:  djl = ((dist_node*)y)->d[nr - 1];
fitch.c:  wil = ((dist_node*)y)->w[nq - 1];
fitch.c:  wjl = ((dist_node*)y)->w[nr - 1];
fitch.c:  ((dist_node*)y)->w[nx - 1] = wil + wjl;
fitch.c:    ((dist_node*)y)->d[nx - 1] = 0.0;
fitch.c:    ((dist_node*)y)->d[nx - 1] = ((dil - vi) * wil + (djl - vj) * wjl) / (wil + wjl);
fitch.c:  r = p->back;
fitch.c:  nr = r->index;
fitch.c:    q = p->next;
fitch.c:    s = q->back;
fitch.c:    ns = s->index;
fitch.c:    if (((dist_node*)s)->w[nr - 1] + ((dist_node*)r)->w[ns - 1] <= 0.0)
fitch.c:      ((dist_node*)p)->dist = 0.0;
fitch.c:      ((dist_node*)p)->dist =
fitch.c:        (((dist_node*)s)->w[nr - 1] * ((dist_node*)s)->d[nr - 1] +
fitch.c:         ((dist_node*)r)->w[ns - 1] * ((dist_node*)r)->d[ns - 1]) /
fitch.c:        (((dist_node*)s)->w[nr - 1] + ((dist_node*)r)->w[ns - 1]);
fitch.c:  q = p->next;
fitch.c:  r = q->next;
fitch.c:    if (p->iter) {
fitch.c:      p->v = (((dist_node*)p)->dist + ((dist_node*)r)->dist -
fitch.c:              ((dist_node*)q)->dist) / 2.0;
fitch.c:      p->back->v = p->v;
fitch.c:  q = p->next;
fitch.c:  r = q->next;
fitch.c:  n = p->back->index;
fitch.c:  nq = q->back->index;
fitch.c:  nr = r->back->index;
fitch.c:      if (p->iter) {
fitch.c:        wr = ((dist_node*)r->back)->w[n - 1] +
fitch.c:          ((dist_node*)p->back)->w[nr - 1];
fitch.c:        wq = ((dist_node*)q->back)->w[n - 1] + ((dist_node*)p->back)->w[nq - 1];
fitch.c:          p->v = 0.0;
fitch.c:          p->v = ((((dist_node*)p)->dist - q->v) * wq +
fitch.c:                  (((dist_node*)r)->dist - r->v) * wr) / (wr + wq);
fitch.c:        if (p->v < 0 && !negallowed)
fitch.c:          p->v = 0.0;
fitch.c:        p->back->v = p->v;
fitch.c:  if (!y->tip) {
fitch.c:    alter(x, y->next->back);
fitch.c:    alter(x, y->next->next->back);
fitch.c:  alter(p, p->back);
fitch.c:  for (q = p->next ; q != p ; q = q->next )
fitch.c:    alter(q, q->back);
fitch.c:  p->initialized = true;
fitch.c:  if (p->tip)
fitch.c:  iter = p->iter;
fitch.c:  for ( q = p->next ; p != q ; q = q->next )
fitch.c:    iter = iter || q->iter;
fitch.c:  t->nuview(t, p);
fitch.c:  WITH = (dist_node*)t->nodep[m - 1];
fitch.c:  memcpy(WITH->d, x[m - 1], (nonodes * sizeof(double)));
fitch.c:  memcpy(n, reps[m - 1], (spp * sizeof(long)));
fitch.c:      if (WITH->d[i] < epsilonf)
fitch.c:        WITH->d[i] = epsilonf;
fitch.c:      WITH->w[i] = n[i] / exp(power * log(WITH->d[i]));
fitch.c:      WITH->w[i] = 0.0;
fitch.c:      WITH->d[i] = 0.0;
fitch.c:    WITH->w[i] = 1.0;
fitch.c:    WITH->d[i] = 0.0;
fitch.c:  WITH->node.index = m;
fitch.c:  if (WITH->node.iter) WITH->node.v = 0.0;
fitch.c:  /* make and initialize a three-species tree */
fitch.c:  q = p->back;
fitch.c:  fprintf(outfile, "%4ld          ", q->index - spp);
fitch.c:  if (p->tip) {
fitch.c:      putc(nayme[p->index - 1][i], outfile);
fitch.c:    fprintf(outfile, "%4ld      ", p->index - spp);
fitch.c:  fprintf(outfile, "%15.5f\n", q->v);
fitch.c:  if (!p->tip) {
fitch.c:    describe(p->next->back);
fitch.c:    describe(p->next->next->back);
fitch.c:    fprintf(outfile, "Sum of squares = %11.5f\n\n", -curtree->score);
fitch.c:    fprintf(outfile, "Sum of branch lengths = %11.5f\n\n", -curtree->score);
fitch.c:          totalnum += reps[i - 1][j - 1];
fitch.c:            100 * sqrt(-curtree->score / (totalnum - 2)));
fitch.c:  fprintf(outfile, "-------        ---            ------\n");
fitch.c:  describe(curtree->root->next->back);
fitch.c:  describe(curtree->root->next->next->back);
fitch.c:  describe(curtree->root->back);
fitch.c:    treeout(curtree->root, &col, 0.43429445222, true, curtree->root);
fitch.c:      ((dist_node*)p)->w[j] = 1.0;
fitch.c:      ((dist_node*)p)->d[j] = 0.0;
fitch.c:    p = p->next;
fitch.c:  if ((!lngths) || p->iter)
fitch.c:    p->v = 1.0;
fitch.c:  if ((!lngths) || p->back->iter)
fitch.c:    p->back->v = 1.0;
fitch.c:  if (p->tip)
fitch.c:  initrav(p->next->back);
fitch.c:  initrav(p->next->next->back);
fitch.c:  /* evaluate user-defined tree, iterating branch lengths */
fitch.c:  initrav(curtree->root);
fitch.c:  if (curtree->root->back != NULL) {
fitch.c:    initrav(curtree->root->back);
fitch.c:    curtree->evaluate(curtree, curtree->root, false);
fitch.c:      oldlike = curtree->score;
fitch.c:      curtree->smoothall(curtree, curtree->root);
fitch.c:      curtree->evaluate(curtree, curtree->root, false);
fitch.c:    } while (fabs(curtree->score - oldlike) > delta);
fitch.c:  curtree->evaluate(curtree, curtree->root, false);
fitch.c:  long nextsp, numtrees=-1;
fitch.c:    /* Open in binary: ftell() is broken for UNIX line-endings under WIN32 */
fitch.c:      exxit(-1);
fitch.c:      fprintf(outfile, "User-defined tree");
fitch.c:      treeread2 (intree, &curtree->root, curtree->nodep,
fitch.c:      printree(curtree->root, treeprint, false);
fitch.c:      enterorder[i - 1] = i;
fitch.c:    curtree->root = curtree->nodep[enterorder[0] - 1]->back;
fitch.c:      fitch_buildnewtip(enterorder[nextsp - 1], curtree, nextsp);
fitch.c:      curtree->copy(curtree, priortree);
fitch.c:      curtree->root = curtree->nodep[enterorder[0] - 1]->back;
fitch.c:      curtree->addtraverse(curtree,
fitch.c:                           curtree->nodep[enterorder[nextsp - 1] - 1], curtree->root, true,
fitch.c:      bestree->copy(bestree, curtree);
fitch.c:        writename(nextsp  - 1, 1, enterorder);
fitch.c:        curtree->root = curtree->nodep[enterorder[0] - 1]->back;
fitch.c:          curtree->globrearrange(curtree, progress, true);
fitch.c:          curtree->locrearrange(curtree, curtree->nodep[enterorder[0]-1], true,
fitch.c:      curtree->copy(curtree, bestree);
fitch.c:          bestree->copy(bestree, bestree2);
fitch.c:          if (bestree2->score < bestree->score)
fitch.c:            bestree->copy(bestree, bestree2);
fitch.c:      if (njumble > 1) bestree2->copy(bestree2, curtree);
fitch.c:      curtree->root = curtree->nodep[outgrno - 1]->back;
fitch.c:      printree(curtree->root, treeprint, false);
fitch.c:  funcs->node_new = dist_node_new;
fitch.c:  funcs->tree_new = fitch_tree_new;
fitch.c:  if (!strcmp(Method, "FM")) // Fitch-Margoliash
fitch.c:  funcs->node_new = dist_node_new;
fitch.c:  funcs->tree_new = fitch_tree_new;
gendist.c:/* Version 4.0. (c) Copyright 1993-2013 by the University of Washington.
gendist.c:    printf("  C                Use Cavalli-Sforza chord measure?  %s\n", cavalli ? "Yes" : "No");
gendist.c:    printf("  U    Use delta-mu-squared microsatellite distance?  %s\n", musat? "Yes" : "No");
gendist.c:    printf("  L                         Form of distance matrix?  %s\n", lower ? "Lower-triangular" : "Square");
gendist.c:      exxit(-1);
gendist.c:  df = totalleles - loci;
gendist.c:    initname(i-1);
gendist.c:        n = alleles[j - 1];
gendist.c:        n = alleles[j - 1] - 1;
gendist.c:        if(fscanf(infile, "%lf", &x[i - 1][m - 1]) < 1)
gendist.c:          exxit(-1);
gendist.c:        sum += x[i - 1][m - 1];
gendist.c:        if (x[i - 1][m - 1] < 0.0) {
gendist.c:          exxit(-1);
gendist.c:      if (all && fabs(sum - 1.0) > epsilong) {
gendist.c:            printf("%f", x[i-1][m-n+m1-2]);
gendist.c:            printf("+%f", x[i-1][m-n+m1-2]);
gendist.c:        exxit(-1);
gendist.c:        x[i - 1][m - 1] = 1.0 - sum;
gendist.c:        if (x[i-1][m-1] < -epsilong) {
gendist.c:              printf("%f", x[i-1][m-n+m1-2]);
gendist.c:              printf("+%f", x[i-1][m-n+m1-2]);
gendist.c:          exxit(-1);
gendist.c:        sprintf(progbuf, "%c", nayme[i - 1][j]);
gendist.c:    for (j = 0; j <= i - 2; j++) { /* ignore the diagonal */
gendist.c:          f = x[i - 1][k] * x[j][k];
gendist.c:        d[i - 1][j] = 4 * (loci - s) / df;
gendist.c:          s1 += x[i - 1][k] * x[j][k];
gendist.c:          temp = x[i - 1][k];
gendist.c:        if (s1 <= 1.0e-20) {
gendist.c:          d[i - 1][j] = -1.0;
gendist.c:              sprintf(progbuf, "%ld AND %ld; -1.0 WAS WRITTEN\n", i, j);
gendist.c:              printf("%ld AND %ld; -1.0 WAS WRITTEN\n", i, j);
gendist.c:          d[i - 1][j] = fabs(-log(s1 / sqrt(s2 * s3)));
gendist.c:          temp = x[i - 1][k] - x[j][k];
gendist.c:          s2 += x[i - 1][k] * x[j][k];
gendist.c:        d[i - 1][j] = s1 / (loci * 2 - 2 * s2);
gendist.c:      if (musat) {    /* delta-mu-squared microsatellite distance */
gendist.c:          temp1 += m * x[i-1][k];   /* add up mean mobility of one species */
gendist.c:          if (m == alleles[locus-1]) {
gendist.c:            s += (temp1-temp2)*(temp1-temp2);  /* add squared difference */
gendist.c:        d[i - 1][j] = s / loci;     /* ... and divide by the number of loci */
gendist.c:      d[j][i - 1] = d[i - 1][j];
gendist.c:  else if (!strcmp(DistMeas, "CS")) // Cavalli-Sforza chord measure
interface.c:   Version 4.0. (c) Copyright 1992-2013 by the University of Washington.
interface.c:  gfxBounds.right=MAX((gfxBounds.bottom-MAC_OFFSET)*.7, 340);
interface.c:  winheight=gfxBounds.bottom-gfxBounds.top-MAC_OFFSET;
interface.c:  winwidth=gfxBounds.right-gfxBounds.left;
interface.c:     correctly as an unbunbled console app -db */
interface.c:  gfx_window = NewCWindow (0L, &gfxBounds, buf2, false, documentProc, (WindowPtr) - 1L, true, 0);
interface.c:  /* changed to support OSX.  Seems to work fine w/ OS 9 -db
interface.c:     UpdateControls(gfx_window, gfx_window->visRgn); */
interface.c:    winheight=newBox.bottom-newBox.top - MAC_OFFSET;
interface.c:    winwidth=newBox.right-newBox.left;
interface.c:    winheight=HiWord(windowsize)-MAC_OFFSET;
interface.c:                             (WindowPtr) - 1L, true, 0);
interface.c:        i = h->contrlRfCon ;
kitsch.c:/* Version 4.0. (c) Copyright 1993-2013 by the University of Washington.
kitsch.c:  n->copy = kitsch_node_copy;
kitsch.c:  dst->weight = src->weight;
kitsch.c:  dst->processed = src->processed;
kitsch.c:  t->globrearrange = rooted_globrearrange;
kitsch.c:  t->insert_ = rooted_tree_insert_;
kitsch.c:  t->re_move = rooted_tree_re_move;
kitsch.c:  t->locrearrange = rooted_locrearrange;
kitsch.c:  t->save_lr_nodes = rooted_tree_save_lr_nodes;
kitsch.c:  t->restore_lr_nodes = rooted_tree_restore_lr_nodes;
kitsch.c:  t->evaluate = kitsch_tree_evaluate;
kitsch.c:  t->smoothall = (tree_smoothall_t)no_op;
kitsch.c:    printf("\nFitch-Margoliash method ");
kitsch.c:    printf("  D      Method (F-M, Minimum Evolution)?  %s\n",
kitsch.c:           (minev ? "Minimum Evolution" : "Fitch-Margoliash"));
kitsch.c:    printf("  -      Negative branch lengths allowed?  %s\n",
kitsch.c:    printf("  L         Lower-triangular data matrix?  %s\n",
kitsch.c:    printf("  R         Upper-triangular data matrix?  %s\n",
kitsch.c:    if (((!usertree) && (strchr("DJUP-LRSM12340", ch) != NULL))
kitsch.c:        || (usertree && ((strchr("DUP-LRSM12340", ch) != NULL))))
kitsch.c:        case '-':
kitsch.c:    exxit(-1);
kitsch.c:  fprintf(outfile, "\nFitch-Margoliash method ");
kitsch.c:  fprintf(outfile, "                  \\  \\   (Obs - Exp)\n");
kitsch.c:  fprintf(outfile, "Sum of squares =  /_ /_  ------------\n");
kitsch.c:    fprintf(outfile, "\n----                       ---------");
kitsch.c:      fprintf(outfile, "-------------");
kitsch.c:    ((dist_node*)curtree->nodep[i])->d[i] = 0.0;
kitsch.c:    ((dist_node*)curtree->nodep[i])->w[i] = 0.0;
kitsch.c:    ((kitsch_node*)curtree->nodep[i])->weight = 0.0;
kitsch.c:          exxit(-1);
kitsch.c:        ((dist_node*)curtree->nodep[i])->d[j - 1] = x;
kitsch.c:            exxit(-1);
kitsch.c:          exxit(-1);
kitsch.c:        ((dist_node*)curtree->nodep[i])->w[j - 1] = n;
kitsch.c:          ((dist_node*)curtree->nodep[j - 1])->d[i] =
kitsch.c:            ((dist_node*)curtree->nodep[i])->d[j - 1];
kitsch.c:          ((dist_node*)curtree->nodep[j - 1])->w[i] =
kitsch.c:            ((dist_node*)curtree->nodep[i])->w[j - 1];
kitsch.c:        if ((i == j) && (fabs(((dist_node*)curtree->nodep[i-1])->d[j-1]) > 0.000000001))
kitsch.c:          exxit(-1);
kitsch.c:        if ((j < i) && (fabs(((dist_node*)curtree->nodep[i])->d[j-1]-
kitsch.c:                             ((dist_node*)curtree->nodep[j-1])->d[i])
kitsch.c:                 ((dist_node*)curtree->nodep[i])->d[j-1],
kitsch.c:                 ((dist_node*)curtree->nodep[j])->d[i-1]);
kitsch.c:          exxit(-1);
kitsch.c:        fprintf(outfile, "%10.5f", ((dist_node*)curtree->nodep[i])->d[j - 1]);
kitsch.c:                  (long)((dist_node*)curtree->nodep[i])->w[j - 1]);
kitsch.c:        if (((dist_node*)curtree->nodep[i])->d[j] < epsilonk)
kitsch.c:          ((dist_node*)curtree->nodep[i])->d[j] = epsilonk;
kitsch.c:        ((dist_node*)curtree->nodep[i])->w[j] /=
kitsch.c:          exp(power * log(((dist_node*)curtree->nodep[i])->d[j]));
kitsch.c:  if (!((dist_node*)u)->sametime) {
kitsch.c:    if (((dist_node*)u)->t > *tmax) {
kitsch.c:      *tmax = ((dist_node*)u)->t;
kitsch.c:  ((dist_node*)u)->t = ((dist_node*)curtree->nodep[u->back->index - 1])->t;
kitsch.c:  if (!u->tip) {
kitsch.c:    scrunchtraverse(u->next->back, closest, tmax);
kitsch.c:    scrunchtraverse(u->next->next->back, closest, tmax);
kitsch.c:  if (((kitsch_node*)a)->weight + ((kitsch_node*)b)->weight <= 0.0)
kitsch.c:    ((dist_node*)a)->t = 0.0;
kitsch.c:    ((dist_node*)a)->t = (((dist_node*)a)->t * ((kitsch_node*)a)->weight + ((dist_node*)b)->t *
kitsch.c:                          ((kitsch_node*)b)->weight) / (((kitsch_node*)a)->weight +
kitsch.c:                                                        ((kitsch_node*)b)->weight);
kitsch.c:  ((kitsch_node*)a)->weight += ((kitsch_node*)b)->weight;
kitsch.c:  ((dist_node*)b)->sametime = true;
kitsch.c:  tmax = -1.0;
kitsch.c:    if (!s->tip) {
kitsch.c:      scrunchtraverse(s->next->back, &closest, &tmax);
kitsch.c:      scrunchtraverse(s->next->next->back, &closest, &tmax);
kitsch.c:    found = (tmax > ((dist_node*)s)->t);
kitsch.c:    tmax = -1.0;
kitsch.c:  if (!(((kitsch_node*)a)->processed || a->tip)) {
kitsch.c:    secondtraverse(a->next->back, q, u, v, i, j, k, sum);
kitsch.c:    secondtraverse(a->next->next->back, q, u, v, i, j, k, sum);
kitsch.c:  if (!(a != q && ((kitsch_node*)a)->processed))
kitsch.c:  l = a->index;
kitsch.c:  wil = ((dist_node*)u)->w[l - 1];
kitsch.c:  wjl = ((dist_node*)v)->w[l - 1];
kitsch.c:  wli = ((dist_node*)a)->w[i - 1];
kitsch.c:  wlj = ((dist_node*)a)->w[j - 1];
kitsch.c:  ((dist_node*)q)->w[l - 1] = wkl;
kitsch.c:  ((dist_node*)a)->w[k - 1] = wlk;
kitsch.c:    ((dist_node*)q)->d[l - 1] = 0.0;
kitsch.c:    ((dist_node*)q)->d[l - 1] = (wil * ((dist_node*)u)->d[l - 1] + wjl *
kitsch.c:                                 ((dist_node*)v)->d[l - 1]) / wkl;
kitsch.c:    ((dist_node*)a)->d[k - 1] = 0.0;
kitsch.c:    ((dist_node*)a)->d[k - 1] = (wli * ((dist_node*)a)->d[i - 1] + wlj *
kitsch.c:                                 ((dist_node*)a)->d[j - 1]) / wlk;
kitsch.c:    TEMP = ((dist_node*)u)->d[l - 1] - ((dist_node*)v)->d[l - 1];
kitsch.c:    TEMP = ((dist_node*)a)->d[i - 1] - ((dist_node*)a)->d[j - 1];
kitsch.c:  ((dist_node*)q)->sametime = false;
kitsch.c:  if (!q->tip)
kitsch.c:    firstraverse(q->next->back, r, sum);
kitsch.c:    firstraverse(q->next->next->back, r, sum);
kitsch.c:  ((kitsch_node*)q)->processed = true;
kitsch.c:  if (q->tip)
kitsch.c:  u = q->next->back;
kitsch.c:  v = q->next->next->back;
kitsch.c:  i = u->index;
kitsch.c:  j = v->index;
kitsch.c:  k = q->index;
kitsch.c:  if (((dist_node*)u)->w[j - 1] + ((dist_node*)v)->w[i - 1] <= 0.0)
kitsch.c:    ((dist_node*)q)->t = 0.0;
kitsch.c:    ((dist_node*)q)->t = (((dist_node*)u)->w[j - 1] * ((dist_node*)u)->d[j - 1] +
kitsch.c:                          ((dist_node*)v)->w[i - 1] * ((dist_node*)v)->d[i - 1]) /
kitsch.c:      (2.0 * (((dist_node*)u)->w[j - 1] + ((dist_node*)v)->w[i - 1]));
kitsch.c:  ((kitsch_node*)q)->weight = ((kitsch_node*)u)->weight +
kitsch.c:    ((kitsch_node*)v)->weight + ((dist_node*)u)->w[j - 1] +
kitsch.c:    ((dist_node*)v)->w[i - 1];
kitsch.c:  u->v = ((dist_node*)q)->t - ((dist_node*)u)->t;
kitsch.c:  v->v = ((dist_node*)q)->t - ((dist_node*)v)->t;
kitsch.c:  u->back->v = u->v;
kitsch.c:  v->back->v = v->v;
kitsch.c:  if (minev && (q != curtree->root))
kitsch.c:    *sum += q->v;
kitsch.c:  if (q->tip)
kitsch.c:  sumtraverse(q->next->back, sum);
kitsch.c:  sumtraverse(q->next->next->back, sum);
kitsch.c:    u = q->next->back;
kitsch.c:    v = q->next->next->back;
kitsch.c:    i = u->index;
kitsch.c:    j = v->index;
kitsch.c:    TEMP = ((dist_node*)u)->d[j - 1] - 2.0 * ((dist_node*)q)->t;
kitsch.c:    TEMP1 = ((dist_node*)v)->d[i - 1] - 2.0 * ((dist_node*)q)->t;
kitsch.c:    (*sum) += ((dist_node*)u)->w[j - 1] * (TEMP * TEMP) +
kitsch.c:      ((dist_node*)v)->w[i - 1] * (TEMP1 * TEMP1);
kitsch.c:  r = t->root;
kitsch.c:  for (i = 0; i < (t->nonodes); i++)
kitsch.c:    ((kitsch_node*)curtree->nodep[i])->processed = curtree->nodep[i]->tip;
kitsch.c:  like = -sum;
kitsch.c:  t->score = like;
kitsch.c:  if (!q->tip)
kitsch.c:    dtraverse(q->next->back);
kitsch.c:  if (q->back != NULL) {
kitsch.c:    fprintf(outfile, "%4ld   ", q->back->index - spp);
kitsch.c:    if (q->index <= spp) {
kitsch.c:        putc(nayme[q->index - 1][i], outfile);
kitsch.c:      fprintf(outfile, "%4ld      ", q->index - spp);
kitsch.c:    fprintf(outfile, "%13.5f", ((dist_node*)curtree->nodep[q->back->index - 1])->t - ((dist_node*)q)->t);
kitsch.c:    q->v = ((dist_node*)curtree->nodep[q->back->index - 1])->t - ((dist_node*)q)->t;
kitsch.c:    q->back->v = q->v;
kitsch.c:    fprintf(outfile, "%16.5f\n", ((dist_node*)curtree->root)->t - ((dist_node*)q)->t);
kitsch.c:  if (!q->tip)
kitsch.c:    dtraverse(q->next->next->back);
kitsch.c:    fprintf(outfile, "\nSum of squares = %10.3f\n\n", -like);
kitsch.c:    fprintf(outfile, "Sum of branch lengths = %10.3f\n\n", -like);
kitsch.c:  if ((fabs(power - 2) < 0.01) && !minev) {
kitsch.c:        if (i + 1 != j + 1 && ((dist_node*)curtree->nodep[i])->d[j] > 0.0)
kitsch.c:          TEMP = ((dist_node*)curtree->nodep[i])->d[j];
kitsch.c:          totalnum += ((dist_node*)curtree->nodep[i])->w[j] * (TEMP * TEMP);
kitsch.c:    totalnum -= 2;
kitsch.c:    fprintf(outfile, "%10.5f\n\n", 100 * sqrt(-(like / totalnum)));
kitsch.c:  fprintf(outfile, "----     --            ------          ------\n\n");
kitsch.c:  dtraverse(curtree->root);
kitsch.c:    treeoutr(curtree->root, &col, curtree);
kitsch.c:      enterorder[i - 1] = i;
kitsch.c:    curtree->root = curtree->nodep[enterorder[0] - 1];
kitsch.c:    curtree->insert_(curtree, curtree->nodep[enterorder[1]-1], curtree->nodep[enterorder[0] - 1], false, false);
kitsch.c:      bestyet = -DBL_MAX;
kitsch.c:      item = curtree->nodep[enterorder[i - 1] - 1];
kitsch.c:      curtree->addtraverse(curtree, item, curtree->root, false, &there, &bestyet, NULL, NULL, false, &multf);
kitsch.c:      curtree->insert_(curtree, item, there, true, multf);
kitsch.c:      curtree->locrearrange(curtree, curtree->root, true, priortree, bestree);
kitsch.c:      examined--;
kitsch.c:        writename(i - 1, 1, enterorder);
kitsch.c:                sprintf(progbuf, "-");
kitsch.c:        curtree->globrearrange(curtree, progress, true);
kitsch.c:            curtree->copy(curtree, bestree);
kitsch.c:        bestree->copy(bestree, curtree);
kitsch.c:      curtree->evaluate(curtree, curtree->root, false);
kitsch.c:      printree(curtree->root, treeprint, true);
kitsch.c:    /* Open in binary: ftell() is broken for UNIX line-endings under WIN32 */
kitsch.c:      fprintf(outfile, "\n\nUser-defined trees:\n\n");
kitsch.c:      treeread2 (intree, &curtree->root, curtree->nodep, lengths, &trweight,
kitsch.c:      if (curtree->root->back) {
kitsch.c:        exxit(-1);
kitsch.c:      curtree->evaluate(curtree, curtree->root, false);
kitsch.c:      printree(curtree->root, treeprint, true);
kitsch.c:  funcs->node_new = kitsch_node_new;
kitsch.c:  funcs->tree_new = kitsch_tree_new;
kitsch.c:  if (!strcmp(Method, "FM")) // Fitch-Margoliash
kitsch.c:{  /* Fitch-Margoliash criterion with contemporary tips */
kitsch.c:  funcs->node_new = kitsch_node_new;
kitsch.c:  funcs->tree_new = kitsch_tree_new;
kitsch.c:}  /* Fitch-Margoliash criterion with contemporary tips */
macface.c:/* Version 4.0 Copyright 1997-2013 by the University of Washington.
macface.c: * and needs to be used in conjunction with the customized LAMARC-library
matrixd.c:/* Version 4.0. (c) Copyright 2012-2013 by the University of Washington.
matrixd.c:  mda->dimx       = dimx;
matrixd.c:  mda->dimy       = dimy;
matrixd.c:  mda->nalloc     = 0;
matrixd.c:  mda->free_list  = Slist_new();
matrixd.c:  mda->alloc_list = Slist_new();
matrixd.c:    Slist_push(mda->free_list, md);
matrixd.c:    Slist_push(mda->alloc_list, md);
matrixd.c:    mda->nalloc++;
matrixd.c:  if ( mda->nalloc - Slist_get_length(mda->free_list) != 0 ) {
matrixd.c:  while ( !Slist_isempty(mda->free_list) ) {
matrixd.c:    md = (Matrix_double)Slist_pop(mda->free_list);
matrixd.c:  Slist_delete(mda->free_list);
matrixd.c:  if ( !Slist_isempty(mda->free_list) ) {
matrixd.c:    return (Matrix_double)Slist_pop(mda->free_list);
matrixd.c:    md = Matrix_double_new(mda->dimx, mda->dimy);
matrixd.c:    Slist_push(mda->alloc_list, md);
matrixd.c:  Slist_push(mda->free_list, md);
mix.c:/* Version 4.0. (c) Copyright 1993-2013 by the University of Washington.
mix.c:      printf("  %s\n", (allwagner ? "Wagner" : "Camin-Sokal"));
mix.c:    bestrees[i - 1] = (long *)Malloc(spp * sizeof(long));
mix.c:        wagner[i] = (1L << (bits + 1)) - (1L << 1);
mix.c:        wagner[i] = (1L << (bits + 1)) - (1L << 1);
mix.c:  count(r->fulstte1, zeroanc, numszero, numsone);
mix.c:  count(r->empstte0, zeroanc, numszero, numsone);
mix.c:      fsteps[which - 1][i] = term;
mix.c:    nsteps[which - 1] = sum;
mix.c:  like = -sum;
mix.c:  if (outgroup->back->index == root->index)
mix.c:  p = root->next;
mix.c:  q = root->next->next;
mix.c:  p->back->back = q->back;
mix.c:  q->back->back = p->back;
mix.c:  p->back = outgroup;
mix.c:  q->back = outgroup->back;
mix.c:  outgroup->back->back = q;
mix.c:  outgroup->back = p;
mix.c:  p->bottom = true;
mix.c:  if (p->tip)
mix.c:  p->next->bottom = false;
mix.c:  savetraverse(p->next->back);
mix.c:  p->next->next->bottom = false;
mix.c:  savetraverse(p->next->next->back);
mix.c:    reroot(treenode[outgrno - 1]);
mix.c:  place[root->index - 1] = 1;
mix.c:    p = treenode[i - 1];
mix.c:    while (place[p->index - 1] == 0)
mix.c:      place[p->index - 1] = i;
mix.c:      while (!p->bottom)
mix.c:        p = p->next;
mix.c:      p = p->back;
mix.c:      place[i - 1] = place[p->index - 1];
mix.c:      j = place[p->index - 1];
mix.c:        place[p->index - 1] = spp + i - 1;
mix.c:        while (!p->bottom)
mix.c:          p = p->next;
mix.c:        p = p->back;
mix.c:          done = (place[p->index - 1] != j);
mix.c:  for (i =nextree - 1; i >= (*pos); i--)
mix.c:    memcpy(bestrees[i], bestrees[i - 1], spp * sizeof(long));
mix.c:    bestrees[(*pos) - 1][i] = place[i];
mix.c:  upper = nextree - 1;
mix.c:        done = (place[i - 1] != bestrees[(*pos) - 1][i - 1]);
mix.c:    below = (place[i - 1] <  bestrees[(*pos )- 1][i - 1]);
mix.c:      upper = (*pos) - 1;
mix.c:      rute = root->next->back;
mix.c:  if (!p->tip) {
mix.c:    addpreorder(p->next->back, item, nufork);
mix.c:    addpreorder(p->next->next->back, item, nufork);
mix.c:  if (p->back == NULL)
mix.c:  forknode = treenode[p->back->index - 1];
mix.c:  if (forknode->back == NULL)
mix.c:  if (p->back->next->next == forknode)
mix.c:    frombelow = forknode->next->next->back;
mix.c:    frombelow = forknode->next->back;
mix.c:  whereto = treenode[forknode->back->index - 1];
mix.c:  if (!p->tip) {
mix.c:    repreorder(p->next->back, r, success);
mix.c:    repreorder(p->next->next->back, r, success);
mix.c:  /* recursive procedure adds nodes to user-defined tree */
mix.c:      exxit(-1);
mix.c:    q = treenode[(*nextnode) - 1];
mix.c:    mix_addelement(&q->next->back, nextnode, lparens, names);
mix.c:    q->next->back->back = q->next;
mix.c:    mix_addelement(&q->next->next->back, nextnode, lparens, names);
mix.c:    q->next->next->back->back = q->next->next;
mix.c:    str[n - 1] =ch;
mix.c:      found = (found && ((str[i] == nayme[n - 1][i]) ||
mix.c:                         ((nayme[n - 1][i] == '_') && (str[i] == ' '))));
mix.c:      if (names[n - 1] == false) {
mix.c:        *p = treenode[n - 1];
mix.c:        names[n - 1] = true;
mix.c:          putchar(nayme[n - 1][i]);
mix.c:        exxit(-1);
mix.c:  /* read in user-defined tree and set it up */
mix.c:  root->back = NULL;
mix.c:     encounter an open-paren */
mix.c:    fprintf(outfile, "\nrequires a total of %10.3f\n", -like);
mix.c:  if (p->tip) {
mix.c:    p->visited = false;
mix.c:    clearallnodes(p->next->back);
mix.c:    clearallnodes(p->next->next->back);
mix.c:    p->next->visited = false;
mix.c:    p->next->next->visited = false;
mix.c:    p->visited = false;
mix.c:  fullset = (1L << (bits + 1)) - (1L << 1);
mix.c:      enterorder[i - 1] = i;
mix.c:    root = treenode[enterorder[0] - 1];
mix.c:    add3(treenode[enterorder[0] - 1], treenode[enterorder[1] - 1],
mix.c:      bestyet = -350.0 * spp * chars;
mix.c:      item = treenode[enterorder[i - 1] - 1];
mix.c:      nufork = treenode[spp + i - 2];
mix.c:        writename(i - 1, 1, enterorder);
mix.c:              sprintf(progbuf, "-");
mix.c:            bestyet = -350.0  * spp * chars;
mix.c:    for (i = spp - 1; i >= 1; i--)
mix.c:          fprintf(outfile, "%6ld trees in all found\n", nextree - 1);
mix.c:      for (i = 0; i <= (nextree - 2); i++) {
mix.c:          add3(treenode[bestrees[i][j - 1] - 1], treenode[j - 1], treenode[spp + j - 2], &root, treenode);
mix.c:          reroot(treenode[outgrno - 1]);
mix.c:    /* Open in binary: ftell() is broken for UNIX line-endings under WIN32 */
mix.c:      fprintf(outfile, "User-defined tree");
mix.c:        reroot(treenode[outgrno - 1]);
mix.c:        fprintf(outfile, "Camin-Sokal parsimony method\n\n");
mix.c:        fprintf(outfile, "Mixture of Wagner and Camin-Sokal parsimony methods\n\n");
mix.c:  bits = 8 * sizeof(long) - 1;
mix.c:  bits = 8 * sizeof(long) - 1;
ml.c:/* Version 4.0. (c) Copyright 1993-2013 by the University of Washington.
ml.c:const double MIN_ROOT_TYME = -10;
ml.c:  t->smoothall = ml_tree_smoothall;
ml.c:  t->insert_ = (tree_insert_t)ml_tree_insert_;
ml.c:  t->re_move = ml_tree_re_move;
ml.c:  t->try_insert_ = (tree_try_insert_t)ml_tree_try_insert_;
ml.c:  t->do_branchl_on_insert_f = ml_tree_do_branchl_on_insert;
ml.c:  t->do_branchl_on_re_move_f = ml_tree_do_branchl_on_re_move;
ml.c:  dest->categs = src->categs;
ml.c:  dest->endsite = src->endsite;
ml.c:  set_tyme((node*)dest, src->node.tyme);
ml.c:  if(dest->underflows)                  // RSGbugfix
ml.c:    memcpy(dest->underflows, src->underflows, src->endsite * sizeof(double));
ml.c:    assert(src->underflows == NULL);    // RSGdebug
ml.c:  long oldendsite = dest->ml_node.endsite;
ml.c:  if ( oldendsite != 0 && oldendsite != src->ml_node.endsite )
ml.c:    ((ml_node*)dest)->freex((ml_node*)dest);
ml.c:    ((ml_node*)dest)->allocx(((ml_node*)dest), ((ml_node*)src)->endsite, ((ml_node*)src)->categs);
ml.c:  for (i = 0; i < src->ml_node.endsite; i++)
ml.c:    for (j = 0; j < src->ml_node.categs; j++)
ml.c:      memcpy(dest->codonx[i][j], src->codonx[i][j], sizeof(csitelike));
ml.c:  long oldendsite = dest->ml_node.endsite;
ml.c:  if ( oldendsite != 0 && oldendsite != src->ml_node.endsite )
ml.c:    ((ml_node*)dest)->freex((ml_node*)dest);
ml.c:    ((ml_node*)dest)->allocx(((ml_node*)dest), ((ml_node*)src)->endsite, ((ml_node*)src)->categs);
ml.c:  for (i = 0; i < src->ml_node.endsite; i++)
ml.c:    for (j = 0; j < src->ml_node.categs; j++)
ml.c:      memcpy(dest->x[i][j], src->x[i][j], sizeof(psitelike));
ml.c:  long oldendsite = dest->ml_node.endsite;
ml.c:  if ( oldendsite != 0 && oldendsite != src->ml_node.endsite )
ml.c:    dest->ml_node.freex((ml_node*)dest);
ml.c:    dest->ml_node.endsite = 0;
ml.c:    ((ml_node*)dest)->allocx(((ml_node*)dest), ((ml_node*)src)->endsite, ((ml_node*)src)->categs);
ml.c:  for (i = 0; i < ((ml_node*)src)->endsite; i++)
ml.c:    for (j = 0; j < ((ml_node*)src)->categs; j++)
ml.c:      memcpy(((dna_node*)dest)->x[i][j], ((dna_node*)src)->x[i][j], sizeof(sitelike));
ml.c:  ((ml_node*)p)->underflows[site] += log(maxx);
ml.c:    for ( j = 0 ; j < ((long)T - (long)A + 1) ; j++)
ml.c:      p->x[site][i][j] /= maxx;
ml.c:  ((ml_node*)p)->underflows[site] += log(maxx);
ml.c:      p->x[site][i][m] /= maxx;
ml.c:  n->ml_node.allocx = dna_node_allocx;
ml.c:  n->ml_node.node.copy = dna_node_copy;
ml.c:  n->ml_node.node.init = dna_node_init;
ml.c:  n->ml_node.freex = dna_node_freex;
ml.c:  n->x = NULL;
ml.c:    n->ml_node.allocx((ml_node*)n, endsite, rcategs);
ml.c:  pn->ml_node.allocx = prot_node_allocx;
ml.c:  pn->ml_node.node.copy = prot_node_copy;
ml.c:  pn->ml_node.node.init = prot_node_init;
ml.c:  pn->ml_node.freex = prot_node_freex;
ml.c:  pn->x = NULL;
ml.c:    pn->ml_node.allocx(&(pn->ml_node), endsite, rcategs);
ml.c:  pn->ml_node.allocx = codon_node_allocx;
ml.c:  pn->ml_node.node.copy = codon_node_copy;
ml.c:  pn->ml_node.node.init = codon_node_init;
ml.c:  pn->ml_node.freex = codon_node_freex;
ml.c:  pn->codonx = NULL;
ml.c:    pn->ml_node.allocx(&(pn->ml_node), endsite, rcategs);
ml.c:  n->freex(n);
ml.c:  n->copy = ml_node_copy;
ml.c:  n->init = ml_node_init;
ml.c:  n->free = ml_node_free;
ml.c:  n->reinit = ml_node_reinit;
ml.c:  n->node_print_f = ml_node_print;
ml.c:  mln->freex = NULL;                    /* x is only defined for dna_node and prot_node */
ml.c:  mln->node.tyme = 0;
ml.c:  mln->node.tyme = 0;
ml.c:  // BUG.970 -- does freex need refreshing ?
ml.c:  // BUG.970 -- leave for dna_node and prot_node ?
ml.c:  printf(" ml(endsite:%ld tyme:%lf)", mn->endsite, mn->node.tyme);
ml.c:    treenode[i]->allocx((ml_node*)treenode[i], endsite, param);
ml.c:      q->allocx(q, endsite, param);
ml.c:      q = (ml_node*)q->node.next;
ml.c:  for ( i = 0 ; i < n->endsite ; i++ )
ml.c:    free(dn->x[i]);
ml.c:  free(dn->x);
ml.c:  dn->x = NULL;
ml.c:  free(n->underflows);
ml.c:  n->underflows = NULL;
ml.c:  for ( i = 0 ; i < n->endsite ; i++ )
ml.c:    free(pn->x[i]);
ml.c:  free(pn->x);
ml.c:  pn->x = NULL;
ml.c:  free(n->underflows);
ml.c:  n->underflows = NULL;
ml.c:  for ( i = 0 ; i < n->endsite ; i++ )
ml.c:    free(pn->codonx[i]);
ml.c:  free(pn->codonx);
ml.c:  pn->codonx = NULL;
ml.c:  free(n->underflows);
ml.c:  n->underflows = NULL;
ml.c:  dn->x = (phenotype)Malloc(endsite * sizeof(ratelike));
ml.c:    dn->x[i] = (ratelike)Malloc(rcategs * sizeof(sitelike));
ml.c:  n->categs = rcategs;
ml.c:  n->endsite = endsite;
ml.c:  n->underflows = Malloc(endsite * sizeof(double));
ml.c:  n->ml_node.categs = rcategs;
ml.c:  n->ml_node.endsite = endsite;
ml.c:  n->x = (pphenotype)Malloc(endsite * sizeof(pratelike));
ml.c:    n->x[i] = (pratelike)Malloc(rcategs * sizeof(psitelike));
ml.c:  n->ml_node.underflows= Malloc(endsite * sizeof(double));
ml.c:  n->ml_node.categs = rcategs;
ml.c:  n->ml_node.endsite = endsite;
ml.c:  n->codonx = (cphenotype)Malloc(endsite * sizeof(cratelike));
ml.c:    n->codonx[i] = (cratelike)Malloc(rcategs * sizeof(csitelike));
ml.c:  n->ml_node.underflows= Malloc(endsite * sizeof(double));
ml.c:          ((dna_node*)nodep[i])->x[k][l][(long)b - (long)A] = 0.0;
ml.c:        switch (y[i][j - 1])
ml.c:            ((dna_node*)nodep[i])->x[k][l][0] = 1.0;
ml.c:            ((dna_node*)nodep[i])->x[k][l][(long)C - (long)A] = 1.0;
ml.c:            ((dna_node*)nodep[i])->x[k][l][(long)G - (long)A] = 1.0;
ml.c:            ((dna_node*)nodep[i])->x[k][l][(long)T - (long)A] = 1.0;
ml.c:            ((dna_node*)nodep[i])->x[k][l][(long)T - (long)A] = 1.0;
ml.c:            ((dna_node*)nodep[i])->x[k][l][0] = 1.0;
ml.c:            ((dna_node*)nodep[i])->x[k][l][(long)C - (long)A] = 1.0;
ml.c:            ((dna_node*)nodep[i])->x[k][l][0] = 1.0;
ml.c:            ((dna_node*)nodep[i])->x[k][l][(long)G - (long)A] = 1.0;
ml.c:            ((dna_node*)nodep[i])->x[k][l][0] = 1.0;
ml.c:            ((dna_node*)nodep[i])->x[k][l][(long)T - (long)A] = 1.0;
ml.c:            ((dna_node*)nodep[i])->x[k][l][(long)C - (long)A] = 1.0;
ml.c:            ((dna_node*)nodep[i])->x[k][l][(long)G - (long)A] = 1.0;
ml.c:            ((dna_node*)nodep[i])->x[k][l][(long)C - (long)A] = 1.0;
ml.c:            ((dna_node*)nodep[i])->x[k][l][(long)T - (long)A] = 1.0;
ml.c:            ((dna_node*)nodep[i])->x[k][l][(long)G - (long)A] = 1.0;
ml.c:            ((dna_node*)nodep[i])->x[k][l][(long)T - (long)A] = 1.0;
ml.c:            ((dna_node*)nodep[i])->x[k][l][(long)C - (long)A] = 1.0;
ml.c:            ((dna_node*)nodep[i])->x[k][l][(long)G - (long)A] = 1.0;
ml.c:            ((dna_node*)nodep[i])->x[k][l][(long)T - (long)A] = 1.0;
ml.c:            ((dna_node*)nodep[i])->x[k][l][0] = 1.0;
ml.c:            ((dna_node*)nodep[i])->x[k][l][(long)G - (long)A] = 1.0;
ml.c:            ((dna_node*)nodep[i])->x[k][l][(long)T - (long)A] = 1.0;
ml.c:            ((dna_node*)nodep[i])->x[k][l][0] = 1.0;
ml.c:            ((dna_node*)nodep[i])->x[k][l][(long)C - (long)A] = 1.0;
ml.c:            ((dna_node*)nodep[i])->x[k][l][(long)T - (long)A] = 1.0;
ml.c:            ((dna_node*)nodep[i])->x[k][l][0] = 1.0;
ml.c:            ((dna_node*)nodep[i])->x[k][l][(long)C - (long)A] = 1.0;
ml.c:            ((dna_node*)nodep[i])->x[k][l][(long)G - (long)A] = 1.0;
ml.c:              ((dna_node*)nodep[i])->x[k][l][(long)b - (long)A] = 1.0;
ml.c:              ((dna_node*)nodep[i])->x[k][l][(long)b - (long)A] = 1.0;
ml.c:              ((dna_node*)nodep[i])->x[k][l][(long)b - (long)A] = 1.0;
ml.c:              ((dna_node*)nodep[i])->x[k][l][(long)b - (long)A] = 1.0;
ml.c:          case '-':
ml.c:              ((dna_node*)nodep[i])->x[k][l][(long)b - (long)A] = 1.0;
ml.c:        free(((prot_node*)p)->x[j]);
ml.c:        ((prot_node*)p)->x[j] = NULL;
ml.c:      free(((prot_node*)p)->x);
ml.c:      ((prot_node*)p)->x = NULL;
ml.c:      p = p->next;
ml.c:        free(((codon_node*)p)->codonx[j]);
ml.c:        ((codon_node*)p)->codonx[j] = NULL;
ml.c:      free(((codon_node*)p)->codonx);
ml.c:      ((codon_node*)p)->codonx = NULL;
ml.c:      p = p->next;
ml.c:        free(((dna_node*)p)->x[j]);
ml.c:      free(((dna_node*)p)->x);
ml.c:      p = p->next;
ml.c:      free(((dna_node*)treenode[i])->x[j]);
ml.c:    free(((dna_node*)treenode[i])->x);
ml.c:          free(((dna_node*)p)->x[j]);
ml.c:        free(((dna_node*)p)->x);
ml.c:        p = p->next;
ml.c:{ /* calls nuview to (one-way recursively) make views at both ends
ml.c:  if (!p->tip && !p->initialized) {
ml.c:  if ( p->back && !p->back->tip && !p->back->initialized) {
ml.c:    generic_tree_nuview((tree*)t, p->back);     /* recurse from the other */
ml.c:  t->makenewv (t, p);
ml.c:  if ( p->tip )
ml.c:  for ( sib_ptr = p->next ; sib_ptr != p ; sib_ptr = sib_ptr->next )
ml.c:    if ( sib_ptr->back )
ml.c:      smooth(t, sib_ptr->back);
ml.c:      sib_ptr->initialized = false;
ml.c:  /* go through the tree multiple times re-estimating branch lengths
ml.c:  if ( p->tip ) p = p->back;
ml.c:    smooth(t, p->back);
ml.c:    if ( p->tip )
ml.c:    for ( q = p->next ; q != p ; q = q->next)
ml.c:      smooth(t, q->back);
ml.c:{ /* split original  q->v  branch length evenly beween forknode->next and forknode->next->next */
ml.c:  newv = q->v * 0.5;
ml.c:  forknode->v = initialv; 
ml.c:  forknode->back->v = initialv;
ml.c:  /* forknode->next for both directions */
ml.c:  forknode->next->v = newv ;
ml.c:  forknode->next->back->v = newv ;
ml.c:  /* forknode->next->next for both directions */
ml.c:  forknode->next->next->v = newv;
ml.c:  forknode->next->next->back->v = newv;
ml.c:  /* BUG.970 -- might consider invalidating views here or in generic */
ml.c:  /* debug:  do values of ->v get set earlier anyway?  */
ml.c:  inittrav(t, forknode->back);
ml.c:  inittrav(t, forknode->next);
ml.c:  inittrav(t, forknode->next->back);
ml.c:  inittrav(t, forknode->next->next);
ml.c:  inittrav(t, forknode->next->next->back);
ml.c:    ml_update(t, p->next);
ml.c:    ml_update(t, p->next->next);
ml.c:      smooth(t, p->back);
ml.c:      for ( r = p->next ; r != p ; r = r->next )
ml.c:   * BUG.970 -- add this when moved into re_move
ml.c:   * assert(q->next->next->next == q);
ml.c:  double combinedEdgeWeight = q->v + q->back->v;
ml.c:  q->v       = combinedEdgeWeight;
ml.c:  q->back->v = combinedEdgeWeight;
ml.c:        smooth(t, (*q)->back);
ml.c:    if (!(*q)->tip)
ml.c:    if (!(*q)->back->tip)
ml.c:      ml_update(t, (*q)->back);
ml.c:  t->save_traverses(t, p, q);
ml.c:  t->insert_(t, p, q, false);
ml.c:  like = t->evaluate(t, p, false);
ml.c:    t->copy(t, bestree);
ml.c:  t->re_move(t, p, &whereRemoved, false); /* BUG.970 -- check doinit value */
ml.c:/* debug:  probably redundant:   t->restore_traverses(t, p, q);  debug */
ml.c:  /* Update t->score */
ml.c:  like = t->evaluate(t, q, 0);
ml.c:  below = t->nodep[below->index - 1];
ml.c:  newfork = t->nodep[newtip->back->index - 1];
ml.c:  newtip = t->nodep[newtip->index-1];
ml.c:  if (((ml_node*)newtip)->node.tyme < ((ml_node*)below)->node.tyme)
ml.c:  set_tyme(newfork, ((ml_node*)p)->node.tyme);
ml.c:  if (newfork->back != NULL)
ml.c:    if (((ml_node*)p)->node.tyme > ((ml_node*)newfork->back)->node.tyme)
ml.c:      set_tyme(newfork, (((ml_node*)p)->node.tyme + ((ml_node*)newfork->back)->node.tyme) / 2.0);
ml.c:      set_tyme(newfork, ((ml_node*)p)->node.tyme - (epsilon/2));
ml.c:      p = t->nodep[p->back->index - 1];
ml.c:      done = (p == t->root);
ml.c:        done = (((ml_node*)t->nodep[p->back->index - 1])->node.tyme < ((ml_node*)p)->node.tyme);
ml.c:        set_tyme(p->back, ((ml_node*)p)->node.tyme - epsilon/2);
ml.c:    set_tyme(newfork, ((ml_node*)newfork)->node.tyme - initialv);
ml.c:    inittrav(t, newtip->back);
ml.c:      smooth(t, newfork->back);
ml.c:  return ((ml_node *)p)->node.tyme;
ml.c:  if ( p->next )
ml.c:      ((ml_node*)sib_ptr)->node.tyme = tyme;
ml.c:      ((ml_node*)sib_ptr)->node.initialized = false;
ml.c:      sib_ptr = sib_ptr->next;
ml.c:    ((ml_node*)p)->node.tyme = tyme;
ml.c:    inittrav(t, whereloc->back);
ml.c:      smooth(t, whereloc->back);
ml.c:  else smooth(t, whereloc->back);
ml.c:  for ( q = p->next; q != p; q = q->next )
ml.c:    if ( get_tyme(q->back) < min )
ml.c:      min = get_tyme(q->back);
ml.c:  if ( p->back )
ml.c:    return get_tyme(p->back);
ml.c:  p = t->nodep[p->index - 1];
ml.c:  if ( p->tip == true && tyme != 0.0 ) return false;
ml.c:  t->nuview(t, p);
ml.c:  return t->evaluate(t, p, false);
ml.c:  /* Improve a node tyme using Newton-Raphson
ml.c:   *   '/' ->   Positive curvature, positive slope, moved +
ml.c:   *   '\' ->   Positive curvature, negative slope, moved -
ml.c:   *   ')' ->   Negative curvature, moved +
ml.c:   *   '(' ->   Negative curvature, moved -
ml.c:   *   '<' ->   Retracting back by retract_factor
ml.c:   *   'X' ->   Retraction failed, keeping current point
ml.c:  const long max_iterations = 100;              /* Maximum iterations -
ml.c:  if ( p->tip )
ml.c:  node *s = t->nodep[p->index - 1];
ml.c:  double start_likelihood = t->score;
ml.c:  if (s == t->root)
ml.c:  max_tyme = min_child_tyme(s) - MIN_BRANCH_LENGTH;
ml.c:  current_likelihood = t->evaluate(t, s, false);
ml.c:  uphill_step = (max_tyme - min_tyme) * uphill_step_factor;
ml.c:    x[0] = current_tyme - tyme_delta;
ml.c:    s21 = (lnl[2] - lnl[1]) / (x[2] - x[1]);
ml.c:    s10 = (lnl[1] - lnl[0]) / (x[1] - x[0]);
ml.c:    curv = (s21 - s10) / ((x[2] - x[0]) / 2);
ml.c:      tdelta = -(slope / curv);
ml.c:      tdelta = new_tyme - current_tyme;
ml.c:      tdelta = new_tyme - current_tyme;
ml.c:    if ( new_likelihood - current_likelihood < likelihood_epsilon )
ml.c:    sib_ptr = sib_ptr->next;
ml.c:  fprintf(stdout, "\nmakenewv(): node %ld: %ld iterations (%f,%f) => (%f,%f)\n", p->index, iteration+1, start_tyme, start_likelihood, current_tyme, current_likelihood);
ml.c:  if ( p->tip )
ml.c:  s = t->nodep[p->index - 1];
ml.c:  oldx = ((ml_node*)s)->node.tyme;                   /* store old tyme */
ml.c:  lnlike = oldlike = t->evaluate(t, p, 0);           /* eval and store old likelihood */
ml.c:  if (s == t->root)
ml.c:    tlow = -10.0;                       /* default minimum tyme at root */
ml.c:    tlow = ((ml_node*)(s->back))->node.tyme; /* otherwise tyme >= parent tyme */
ml.c:  thigh = ((ml_node*)s->next->back)->node.tyme;
ml.c:  for ( sib_ptr = s->next ; sib_ptr != s ; sib_ptr = sib_ptr->next )
ml.c:    sib_back_ptr = sib_ptr->back;
ml.c:    if (((ml_node*)sib_back_ptr)->node.tyme < thigh)
ml.c:      thigh = ((ml_node*)sib_back_ptr)->node.tyme;
ml.c:  if (thigh - tlow < 4.0*epsilon) return;
ml.c:  if (s != t->root)
ml.c:    tdelta = (thigh - tlow) / 10.0;
ml.c:    tdelta = (thigh - ((ml_node*)s)->node.tyme) / 5.0;
ml.c:    s32 = (lnl[2] - lnl[1]) / (x[2] - x[1]);
ml.c:    s21 = (lnl[1] - lnl[0]) / (x[1] - x[0]);
ml.c:    if (fabs(x[2] - x[0]) > epsilon)
ml.c:      curv = (s32 - s21) / ((x[2] - x[0]) / 2);
ml.c:    slope = (s32 + s21) / 2 - curv * (x[2] - 2 * x[1] + x[0]) / 4;
ml.c:        tdelta = -fabs(tdelta);
ml.c:      tdelta = -(tfactor * slope / curv);
ml.c:      tdelta = tlow + epsilon - tt;
ml.c:    if (tt + tdelta >= thigh - epsilon)
ml.c:      tdelta = thigh - epsilon - tt;
ml.c:    done = (fabs(yold - tt) < epsilon || fabs(tdelta) < epsilon);
ml.c:    t->nuview(t, s);
ml.c:    lnlike = t->evaluate(t, s, false);
ml.c:      t->score = oldlike;
ml.c:      t->nuview(t, p);
ml.c:      for (sib_ptr = p->next ; sib_ptr != p ; sib_ptr = sib_ptr->next )
ml.c:        t->nuview(t, sib_ptr);
ml.c:  p->initialized = false;
ml.c:  for (sib_ptr = p->next ; sib_ptr != p ; sib_ptr = sib_ptr->next )
ml.c:    sib_ptr->initialized = false;
ml.c:  t->score = lnlike;
ml.c:  double tt = ((ml_node*)p)->node.tyme;
ml.c:  x[0] = tt - td;
ml.c:  if ( x[2] > thigh - epsilon )
ml.c:    x[2] = thigh - epsilon;
ml.c:    t->nuview(t, p);
ml.c:    lnl[i] = t->evaluate(t, p, 0);
ml.c:        sum = (*freqa) * ((dna_node*)treenode[i])->x[j][0][0];
ml.c:        sum += (*freqc) * ((dna_node*)treenode[i])->x[j][0][(long)C - (long)A];
ml.c:        sum += (*freqg) * ((dna_node*)treenode[i])->x[j][0][(long)G - (long)A];
ml.c:        sum += (*freqt) * ((dna_node*)treenode[i])->x[j][0][(long)T - (long)A];
ml.c:        suma += w * (*freqa) * ((dna_node*)treenode[i])->x[j][0][0] / sum;
ml.c:        sumc += w * (*freqc) * ((dna_node*)treenode[i])->x[j][0][(long)C - (long)A] / sum;
ml.c:        sumg += w * (*freqg) * ((dna_node*)treenode[i])->x[j][0][(long)G - (long)A] / sum;
ml.c:        sumt += w * (*freqt) * ((dna_node*)treenode[i])->x[j][0][(long)T - (long)A] / sum;
ml.c:    curtree->smoothall(curtree, curtree->root);
ml.c:      curtree->globrearrange(curtree, progress, smoothit);
ml.c:      curtree->locrearrange(curtree, curtree->root->back, smoothit, priortree, bestree);
ml.c:    curtree->smoothall(curtree, curtree->root);
ml.c:    inittravtree(curtree, curtree->root);
ml.c:    curtree->evaluate(curtree, curtree->root, 0);   /* debug:  why?  */
ml.c:    curtree->smoothall(curtree, curtree->root);
ml.c:  curtree->evaluate(curtree, curtree->root, true);
ml.c:  if ((!lngths) || p->iter)
ml.c:    p->v = initialv;
ml.c:    p->back->v = initialv;
ml.c:  if (!p->tip)
ml.c:    q = p->next;
ml.c:      ml_inittravtree(t, q->back);
ml.c:      q = q->next;
move.c:/* Version 4.0. (c) Copyright 1993-2013 by the University of Washington.
move.c:unsigned char che[(long)question - (long)horiz + 1];
move.c:boolean reversed[(long)question - (long)horiz + 1];
move.c:boolean graphic[(long)question - (long)horiz + 1];
move.c:           (!(allwagner || mixture)) ? "Camin-Sokal"  : "(methods in mixture)");
move.c:      wagner[i] = (1L << (bits + 1)) - (1L << 1);
move.c:    printf("Camin-Sokal parsimony method\n\n");
move.c:  alloctree(&curtree->nodep);
move.c:  setuptree(curtree->nodep);
move.c:  inputdata(curtree->nodep, true, false, stdout);
move.c:  /* configure to machine -- set up special characters */
move.c:  che[(long)overt] = '-';
move.c:    l0 = p->next->back->statezero[i];
move.c:    l1 = p->next->back->stateone[i];
move.c:    r0 = p->next->next->back->statezero[i];
move.c:    r1 = p->next->next->back->stateone[i];
move.c:    p->stateone[i] = (l1 | r1) & (~(st & (wa | za)));
move.c:    p->statezero[i] = (l0 | r0) & (~(st & (wa | oa)));
move.c:  if (p->tip)
move.c:  move_postorder(p->next->back);
move.c:  move_postorder(p->next->next->back);
move.c:  count(r->stateone, zeroanc, numszero, numsone);
move.c:  count(r->statezero, zeroanc, numszero, numsone);
move.c:  like = -sum;
move.c:  if (outgroup->back->index == curtree->root->index)
move.c:  newbottom = outgroup->back;
move.c:  p = curtree->nodep[newbottom->index - 1]->back;
move.c:  while (p->index != curtree->root->index)
move.c:    oldbottom = curtree->nodep[p->index - 1];
move.c:    curtree->nodep[p->index - 1] = p;
move.c:    p = oldbottom->back;
move.c:  onleft = (p == curtree->root->next);
move.c:      p = curtree->root->next->next;
move.c:      q = curtree->root->next;
move.c:      p = curtree->root->next;
move.c:      q = curtree->root->next->next;
move.c:      oldoutgrno = curtree->root->next->next->back->index;
move.c:      oldoutgrno = curtree->root->next->back->index;
move.c:    p = curtree->root->next;
move.c:    q = curtree->root->next->next;
move.c:  p->back->back = q->back;
move.c:  q->back->back = p->back;
move.c:  p->back = outgroup;
move.c:  q->back = outgroup->back;
move.c:      outgroup->back->back = curtree->root->next;
move.c:      outgroup->back = curtree->root->next->next;
move.c:      outgroup->back->back = curtree->root->next->next;
move.c:      outgroup->back = curtree->root->next;
move.c:    outgroup->back->back = curtree->root->next->next;
move.c:    outgroup->back = curtree->root->next;
move.c:  curtree->nodep[newbottom->index - 1] = newbottom;
move.c:  if (r->tip)
move.c:  move_filltrav(r->next->back);
move.c:  move_filltrav(r->next->next->back);
move.c:  bottom = (r->back == NULL);
move.c:    memcpy(zerobelow->bits_, zeroanc, words * sizeof(long));
move.c:    memcpy(onebelow->bits_, oneanc, words * sizeof(long));
move.c:    memcpy(zerobelow->bits_, curtree->nodep[r->back->index - 1]->statezero, words * sizeof(long));
move.c:    memcpy(onebelow->bits_, curtree->nodep[r->back->index - 1]->stateone, words * sizeof(long));
move.c:    s0 = r->statezero[i];
move.c:    s1 = r->stateone[i];
move.c:    a0 = zerobelow->bits_[i];
move.c:    a1 = onebelow->bits_[i];
move.c:    if (!r->tip)
move.c:      l0 = r->next->back->statezero[i];
move.c:      l1 = r->next->back->stateone[i];
move.c:      r0 = r->next->next->back->statezero[i];
move.c:      r1 = r->next->next->back->stateone[i];
move.c:      r->statezero[i] = s0;
move.c:      r->stateone[i] = s1;
move.c:  if (((1L << dispbit) & r->stateone[dispword - 1]) != 0)
move.c:    if (((1L << dispbit) & r->statezero[dispword - 1]) != 0)
move.c:      r->state = '?';
move.c:      r->state = '1';
move.c:    if (((1L << dispbit) & r->statezero[dispword - 1]) != 0)
move.c:      r->state = '0';
move.c:      r->state = '?';
move.c:  if (!r->tip)
move.c:    move_hyptrav(r->next->back);
move.c:    move_hyptrav(r->next->next->back);
move.c:      zeroanc[j - 1] = ((long)zeroanc[j - 1]) | (1L << k);
move.c:      oneanc[j - 1] = ((long)oneanc[j - 1]) | (1L << k);
move.c:  move_filltrav(curtree->root);
move.c:  move_hyptrav(curtree->root);
move.c:    if ((*pos) >= leftedge && (*pos) - leftedge + 1 < screenwidth)
move.c:  if (i == (long)p->ycoord && (p == curtree->root || subtree))
move.c:      switch (p->state)
move.c:    if (p->index >= 100)
move.c:      nnwrite(p->index, 3, &pos, leftedge, screenwidth);
move.c:    else if (p->index >= 10)
move.c:      nnwrite(p->index, 2, &pos, leftedge, screenwidth);
move.c:      nnwrite(p->index, 1, &pos, leftedge, screenwidth);
move.c:    if (!p->tip)
move.c:      r = p->next;
move.c:        if (i >= r->back->ymin && i <= r->back->ymax)
move.c:          q = r->back;
move.c:        r = r->next;
move.c:      first = p->next->back;
move.c:      r = p->next;
move.c:      while (r->next != p)
move.c:        r = r->next;
move.c:      last = r->back;
move.c:    n = (long)p->xcoord - (long)q->xcoord;
move.c:    if (n < 3 && !q->tip)
move.c:      n--;
move.c:    if ((long)q->ycoord == i && !done)
move.c:      if ((long)q->ycoord > (long)p->ycoord)
move.c:        switch (q->state)
move.c:        grwrite(c, n - 3, &pos);
move.c:      if (q->index >= 100)
move.c:        nnwrite(q->index, 3, &pos, leftedge, screenwidth);
move.c:      else if (q->index >= 10)
move.c:        nnwrite(q->index, 2, &pos, leftedge, screenwidth);
move.c:        nnwrite(q->index, 1, &pos, leftedge, screenwidth);
move.c:    else if (!q->tip)
move.c:      if ((long)last->ycoord > i && (long)first->ycoord < i
move.c:          && i != (long)p->ycoord)
move.c:        if (i < (long)p->ycoord)
move.c:          st = p->next->back->state;
move.c:          st = p->next->next->back->state;
move.c:        chwrite(' ', n - 1, &pos, leftedge, screenwidth);
move.c:  if ((long)p->ycoord == i && p->tip)
move.c:      if (nayme[p->index - 1][j - 1] != '\0')
move.c:      chwrite(nayme[p->index - 1][j], 1, &pos, leftedge, screenwidth);
move.c:    nuroot = curtree->root;
move.c:    evaluate(curtree->root);
move.c:    dow--;
move.c:    printf("%10.1f Steps", -like);
move.c:    if (-like < bestyet)
move.c:      bestyet = -like;
move.c:    else if (fabs(-like - bestyet) < 0.000001)
move.c:      if (-like < gotlike)
move.c:      else if (-like > gotlike)
move.c:  treelines = tipy - dow;
move.c:    printf("** %ld lines above screen **\n", topedge - 1);
move.c:  if ((treelines - topedge + 1) > (screenlines - vmargin))
move.c:    if (i >= topedge && i < topedge + screenlines - vmargin)
move.c:  if ((treelines - topedge + 1) > (screenlines - vmargin))
move.c:    printf("** %ld", treelines - (topedge - 1 + screenlines - vmargin));
move.c:  if (treelines - topedge + vmargin + 1 < screenlines)
move.c:  gotlike = -like;
move.c:  curtree->root = curtree->nodep[0];
move.c:  add2(curtree->nodep[0], curtree->nodep[1], curtree->nodep[spp], &curtree->root, restoring, wasleft, curtree->nodep);
move.c:    add2(curtree->nodep[spp+ i - 3], curtree->nodep[i - 1], curtree->nodep[spp + i - 2], &curtree->root, restoring, wasleft, curtree->nodep);
move.c:  curtree->root = curtree->nodep[0];
move.c:  add2(curtree->nodep[0], curtree->nodep[1], curtree->nodep[spp], &curtree->root, restoring, wasleft, curtree->nodep);
move.c:      putchar(nayme[i - 1][j]);
move.c:      ok = (ok && ((j >= 1 && j < i) || (j > spp && j < spp + i - 1)));
move.c:    add2(curtree->nodep[j - 1], curtree->nodep[i - 1], curtree->nodep[spp + i - 2], &curtree->root, restoring, wasleft, curtree->nodep);
move.c:      *p = treep->get_forknode(treep, nodei);
move.c:      treep->nodep[nodei - 1] = *p;
move.c:      *p = treep->get_forknode(treep, nodei);
move.c:      match_names_to_data (str, treep->nodep, p, spp);
move.c:  if (p->tip)
move.c:    names[p->index - 1] = true;
move.c:  q = p->next;
move.c:    initboolnames(q->back, names);
move.c:    q = q->next;
move.c:  /* Open in binary: ftell() is broken for UNIX line-endings under WIN32 */
move.c:  treeread(curtree, intree, &curtree->root, curtree->nodep, &goteof, &firsttree, &nextnode, &haslengths, initmovenode, false, nonodes);
move.c:    p = curtree->nodep[i];
move.c:      p->stateone = (bitptr)Malloc(words * sizeof(long));
move.c:      p->statezero = (bitptr)Malloc(words * sizeof(long));
move.c:      p = p->next;
move.c:  initboolnames(curtree->root, names);
move.c:    outgrno = curtree->root->next->back->index;
move.c:  if (outgropt && in_tree[outgrno - 1])
move.c:    reroot(curtree->nodep[outgrno - 1]);
move.c:  ok1 = (ok1 && i >= 1 && i < spp * 2 && i != curtree->root->index);
move.c:      ok2 = (curtree->nodep[j - 1] != curtree->nodep[curtree->nodep[i - 1]->back->index - 1]);
move.c:      p = curtree->nodep[j - 1];
move.c:      while (p != curtree->root)
move.c:        ok2 = (ok2 && p != curtree->nodep[i - 1]);
move.c:        p = curtree->nodep[p->back->index - 1];
move.c:        q = curtree->nodep[curtree->nodep[i - 1]->back->index - 1];
move.c:        if (q->next->back->index == i)
move.c:          fromwhere = q->next->next->back->index;
move.c:          fromwhere = q->next->back->index;
move.c:        re_move2(&curtree->nodep[i - 1], &q, &curtree->root, &wasleft, curtree->nodep);
move.c:        add2(curtree->nodep[j - 1], curtree->nodep[i - 1], q, &curtree->root, restoring, wasleft, curtree->nodep);
move.c:  add2(p, item, nufork, &curtree->root, restoring, wasleft, curtree->nodep);
move.c:  evaluate(curtree->root);
move.c:  place[p->index - 1] = -like;
move.c:  re_move2(&item, &nufork, &curtree->root, &wasleft, curtree->nodep);
move.c:  if (!p->tip)
move.c:    addpreorder(p->next->back, item, nufork, place);
move.c:    addpreorder(p->next->next->back, item, nufork, place);
move.c:  if (!(ok && i >= 1 && i <= nonodes && i != curtree->root->index))
move.c:    place[j] = -1.0;
move.c:  evaluate(curtree->root);
move.c:  current = -like;
move.c:  q = curtree->nodep[curtree->nodep[i - 1]->back->index - 1];
move.c:  if (q->next->back->index == i)
move.c:    fromwhere = q->next->next->back->index;
move.c:    fromwhere = q->next->back->index;
move.c:  rute = curtree->root;
move.c:  if (curtree->root->index == curtree->nodep[i - 1]->back->index)
move.c:    if (curtree->nodep[curtree->nodep[i - 1]->back->index - 1]->next->back == curtree->nodep[i - 1])
move.c:      rute = curtree->nodep[curtree->nodep[i - 1]->back->index - 1]->next->next->back;
move.c:      rute = curtree->nodep[curtree->nodep[i - 1]->back->index - 1]->next->back;
move.c:  re_move2(&curtree->nodep[i - 1], &dummy, &curtree->root, &wasleft, curtree->nodep);
move.c:  curtree->root = rute;
move.c:  addpreorder(curtree->root, curtree->nodep[i - 1], dummy, place);
move.c:  add2(curtree->nodep[fromwhere - 1], curtree->nodep[what - 1], dummy, &curtree->root, restoring, wasleft, curtree->nodep);
move.c:  like = -current;
move.c:    if (place[j - 1] < current && place[j - 1] >= 0.0)
move.c:      printf("%3ld:%6.2f", j, place[j - 1]);
move.c:    if (fabs(place[j - 1] - current) < 1.0e-6 && j != fromwhere)
move.c:      re_move2(&curtree->nodep[what - 1], &q, &curtree->root, &wasleft, curtree->nodep);
move.c:      add2(curtree->nodep[fromwhere - 1], curtree->nodep[what - 1], q, &curtree->root, restoring, wasleft, curtree->nodep);
move.c:      q = curtree->nodep[atwhat - 1]->next->back;
move.c:      curtree->nodep[atwhat - 1]->next->back = curtree->nodep[atwhat - 1]->next->next->back;
move.c:      curtree->nodep[atwhat - 1]->next->next->back = q;
move.c:      curtree->nodep[atwhat - 1]->next->back->back = curtree->nodep[atwhat - 1]->next;
move.c:      curtree->nodep[atwhat - 1]->next->next->back->back = curtree->nodep[atwhat - 1]->next->next;
move.c:      reroot(curtree->nodep[outgrno - 1]);
move.c:  treeout(curtree->root, 1, &col, curtree->root);
move.c:      nuroot = curtree->nodep[i - 1];
move.c:      nuroot = curtree->root;
move.c:  /* flip at a node left-right */
move.c:    p = curtree->nodep[i - 1]->next->back;
move.c:    curtree->nodep[i - 1]->next->back = curtree->nodep[i - 1]->next->next->back;
move.c:    curtree->nodep[i - 1]->next->next->back = p;
move.c:    curtree->nodep[i - 1]->next->back->back = curtree->nodep[i - 1]->next;
move.c:    curtree->nodep[i - 1]->next->next->back->back = curtree->nodep[i - 1]->next->next;
move.c:    ok = (ok && in_tree[i - 1] && i >= 1 && i <= nonodes && i != curtree->root->index);
move.c:  if (in_tree[outgrno - 1])
move.c:    reroot(curtree->nodep[outgrno - 1]);
move.c:    printf("\nNEXT? (Options: R # + - S . T U W O F H J K L C ? X Q) ");
move.c:    if (strchr("R#+-S.TUWOFHJKLC?XQ", ch) != NULL)
move.c:      case '-':
move.c:  fullset = (1L << (bits + 1)) - (1L << 1);
move.c:  bestyet = -like;
move.c:  gotlike = -like;
move.c:  bits = 8 * sizeof(long) - 1;
moves.c:/* Version 4.0. (c) Copyright 2012-2013 by the University of Washington.
moves.c:    if ((*pos) >= leftedge && (*pos) - leftedge + 1 < screenwidth)
moves.c:  leftx = leftedge - (*pos);
moves.c:  if ((*pos) >= leftedge && (*pos) - leftedge + num < screenwidth)
moves.c:    for(i=0;i<num-leftx;i++)
moves.c:  if ((*pos) >= leftedge && (*pos) - leftedge + 1 < screenwidth)
moves.c:  printf("-         ...     of the previous %s\n", letters);
moves.c:        *leftedge -= hscroll;
moves.c:      if (treelines - *topedge + 6 >= screenlines)
moves.c:        *topedge -= vscroll;
moves.c:  } while (!(numsteps[*dispchar - 1] >
moves.c:             weight[*dispchar - 1] ||
moves.c:  *dispword = (*dispchar - 1) / bits + 1;
moves.c:  *dispbit = (*dispchar - 1) % bits + 1;
moves.c:  *dispword = (*dispchar - 1) / bits + 1;
moves.c:  *dispbit = (*dispchar - 1) % bits + 1;
moves.c:  (*dispchar)--;
moves.c:  *dispword = (*dispchar - 1) / bits + 1;
moves.c:  *dispbit = (*dispchar - 1) % bits + 1;
moves.c:      *dispword = (i - 1) / bits + 1;
moves.c:      *dispbit = (i - 1) % bits + 1;
neighbor.c:/* Version 4.0. (c) Copyright 1993-2013 by the University of Washington.
neighbor.c:    printf("\nNeighbor-Joining/UPGMA method version %s\n\n", VERSION);
neighbor.c:    printf("  N       Neighbor-joining or UPGMA tree?  %s\n",
neighbor.c:           (njoin ? "Neighbor-joining" : "UPGMA"));
neighbor.c:    printf("  L         Lower-triangular data matrix?  %s\n",
neighbor.c:    printf("  R         Upper-triangular data matrix?  %s\n",
neighbor.c:  fprintf(outfile, "\nNeighbor-Joining/UPGMA method version %s\n\n", VERSION);
neighbor.c:  p = curtree.nodep[nonodes]->next;
neighbor.c:  curtree.nodep[nonodes]->next = curtree.nodep[nonodes];
neighbor.c:  free(p->next);
neighbor.c:    fprintf(outfile, " Neighbor-joining method\n");
neighbor.c:  q = p->back;
neighbor.c:    fprintf(outfile, "%4ld          ", q->index - spp);
neighbor.c:    fprintf(outfile, "%4ld     ", q->index - spp);
neighbor.c:  if (p->tip) {
neighbor.c:      putc(nayme[p->index - 1][i], outfile);
neighbor.c:      fprintf(outfile, "%4ld       ", p->index - spp);
neighbor.c:      fprintf(outfile, "%4ld       ", p->index - spp);
neighbor.c:    fprintf(outfile, "%12.5f\n", q->v);
neighbor.c:    fprintf(outfile, "%10.5f      %10.5f\n", q->v, q->v+height);
neighbor.c:  if (!p->tip) {
neighbor.c:    describe(p->next->back, height+q->v);
neighbor.c:    describe(p->next->next->back, height+q->v);
neighbor.c:    fprintf(outfile, "-------        ---            ------\n");
neighbor.c:    fprintf(outfile, "----     --            ------          ------\n");
neighbor.c:  describe(curtree.root->next->back, 0.0);
neighbor.c:  describe(curtree.root->next->next->back, 0.0);
neighbor.c:    describe(curtree.root->back, 0.0);
neighbor.c:  for (i = 0; i <= spp - 2; i++) {
neighbor.c:  fotu2 = spp - 2.0;
neighbor.c:    iter = spp - 3;
neighbor.c:    iter = spp - 1;
neighbor.c:      for (i = 0; i <= j - 2; i++)
neighbor.c:        x[j - 1][i] = x[i][j - 1];
neighbor.c:        jj = enterorder[ja - 1];
neighbor.c:        if (cluster[jj - 1] != NULL) {
neighbor.c:          for (ia = 0; ia <= ja - 2; ia++) {
neighbor.c:            if (cluster[ii - 1] != NULL) {
neighbor.c:              R[ii - 1] += x[ii - 1][jj - 1];
neighbor.c:              R[jj - 1] += x[ii - 1][jj - 1];
neighbor.c:      jj = enterorder[ja - 1];
neighbor.c:      if (cluster[jj - 1] != NULL) {
neighbor.c:        for (ia = 0; ia <= ja - 2; ia++) {
neighbor.c:          if (cluster[ii - 1] != NULL) {
neighbor.c:              total = fotu2 * x[ii - 1][jj - 1] - R[ii - 1] - R[jj - 1];
neighbor.c:              total = x[ii - 1][jj - 1];
neighbor.c:        dio += x[i][mini - 1];
neighbor.c:        djo += x[i][minj - 1];
neighbor.c:      dmin = x[mini - 1][minj - 1];
neighbor.c:      dio = (dio - dmin) / fotu2;
neighbor.c:      djo = (djo - dmin) / fotu2;
neighbor.c:      bi = (dmin + dio - djo) * 0.5;
neighbor.c:      bj = dmin - bi;
neighbor.c:      bi -= av[mini - 1];
neighbor.c:      bj -= av[minj - 1];
neighbor.c:      bi = x[mini - 1][minj - 1] / 2.0 - av[mini - 1];
neighbor.c:      bj = x[mini - 1][minj - 1] / 2.0 - av[minj - 1];
neighbor.c:      av[mini - 1] += bi;
neighbor.c:      sprintf(progbuf, "Cycle %3ld: ", iter - nc + 1);
neighbor.c:        nodelabel((boolean)(av[mini - 1] > 0.0));
neighbor.c:        nodelabel((boolean)(oc[mini - 1] > 1.0));
neighbor.c:        nodelabel((boolean)(av[minj - 1] > 0.0));
neighbor.c:        nodelabel((boolean)(oc[minj - 1] > 1.0));
neighbor.c:    hookup(curtree.nodep[nextnode - 1]->next, cluster[mini - 1]);
neighbor.c:    hookup(curtree.nodep[nextnode - 1]->next->next, cluster[minj - 1]);
neighbor.c:    cluster[mini - 1]->v = bi;
neighbor.c:    cluster[minj - 1]->v = bj;
neighbor.c:    cluster[mini - 1]->back->v = bi;
neighbor.c:    cluster[minj - 1]->back->v = bj;
neighbor.c:    cluster[mini - 1] = curtree.nodep[nextnode - 1];
neighbor.c:    cluster[minj - 1] = NULL;
neighbor.c:      av[mini - 1] = dmin * 0.5;
neighbor.c:    /* re-initialization */
neighbor.c:    fotu2 -= 1.0;
neighbor.c:          da = (x[mini - 1][j] + x[minj - 1][j]) * 0.5;
neighbor.c:          if (mini - j - 1 < 0)
neighbor.c:            x[mini - 1][j] = da;
neighbor.c:          if (mini - j - 1 > 0)
neighbor.c:            x[j][mini - 1] = da;
neighbor.c:          da = x[mini - 1][j] * oc[mini - 1] + x[minj - 1][j] * oc[minj - 1];
neighbor.c:          da /= oc[mini - 1] + oc[minj - 1];
neighbor.c:          x[mini - 1][j] = da;
neighbor.c:          x[j][mini - 1] = da;
neighbor.c:      x[minj - 1][j] = 0.0;
neighbor.c:      x[j][minj - 1] = 0.0;
neighbor.c:    oc[mini - 1] += oc[minj - 1];
neighbor.c:    if (cluster[i - 1] != NULL) {
neighbor.c:      el[nude - 1] = i;
neighbor.c:    curtree.root = cluster[el[0] - 1];
neighbor.c:    curtree.root->back = NULL;
neighbor.c:  bi = (x[el[0] - 1][el[1] - 1] + x[el[0] - 1][el[2] - 1] - x[el[1] - 1]
neighbor.c:        [el[2] - 1]) * 0.5;
neighbor.c:  bj = x[el[0] - 1][el[1] - 1] - bi;
neighbor.c:  bk = x[el[0] - 1][el[2] - 1] - bi;
neighbor.c:  bi -= av[el[0] - 1];
neighbor.c:  bj -= av[el[1] - 1];
neighbor.c:  bk -= av[el[2] - 1];
neighbor.c:    nodelabel((boolean)(av[el[0] - 1] > 0.0));
neighbor.c:    nodelabel((boolean)(av[el[1] - 1] > 0.0));
neighbor.c:    nodelabel((boolean)(av[el[2] - 1] > 0.0));
neighbor.c:  hookup(curtree.nodep[nextnode - 1], cluster[el[0] - 1]);
neighbor.c:  hookup(curtree.nodep[nextnode - 1]->next, cluster[el[1] - 1]);
neighbor.c:  hookup(curtree.nodep[nextnode - 1]->next->next, cluster[el[2] - 1]);
neighbor.c:  cluster[el[0] - 1]->v = bi;
neighbor.c:  cluster[el[1] - 1]->v = bj;
neighbor.c:  cluster[el[2] - 1]->v = bk;
neighbor.c:  cluster[el[0] - 1]->back->v = bi;
neighbor.c:  cluster[el[1] - 1]->back->v = bj;
neighbor.c:  cluster[el[2] - 1]->back->v = bk;
neighbor.c:  curtree.root = cluster[el[0] - 1]->back;
neighbor.c:    printf("\nERROR:  Neighbor-Joining runs must have at least 3 species.\n\n");
neighbor.c:    exxit(-1);
neighbor.c:    enterorder[i - 1] = i;
neighbor.c:    curtree.root = curtree.nodep[outgrno - 1]->back;
neighbor.c:  funcs->node_new = dist_node_new;
neighbor.c:  funcs->node_new = dist_node_new;
neighbor.c:  /* FIXME -- put in frees for funcs/initdata */
newmove.c:/* Version 3.7. (c) Copyright 1993-2013 by the University of Washington.
newmove.c:unsigned char che[(long)question - (long) horiz + 1];
newmove.c:boolean reversed[(long)question - (long) horiz + 1];
newmove.c:boolean graphic[(long)question - (long) horiz + 1];
newmove.c:    (*p)->index = index;
newmove.c:    (*p)->hasname = false;
newmove.c:    (*p)->haslength = false;
newmove.c:    (*p)->deleted=false;
newmove.c:    (*p)->deadend=false;
newmove.c:    (*p)->onebranch=false;
newmove.c:    (*p)->onebranchhaslength=false;
newmove.c:    if(!(*p)->statezero)
newmove.c:      (*p)->statezero = (bitptr)Malloc(words * sizeof(long));
newmove.c:    if(!(*p)->stateone)
newmove.c:      (*p)->stateone = (bitptr)Malloc(words * sizeof(long));
newmove.c:    if(!(*p)->zerosteps)
newmove.c:      (*p)->zerosteps = (bitptr)Malloc(words * sizeof(long));
newmove.c:    if(!(*p)->onesteps)
newmove.c:      (*p)->onesteps = (bitptr)Malloc(words * sizeof(long));
newmove.c:      (*p)->nayme[j] = '\0';
newmove.c:    (*p)->next = q;
newmove.c:  (*p)->next->next->next = *p;
newmove.c:  q = (*p)->next;
newmove.c:    (*p)->back = NULL;
newmove.c:    (*p)->tip = false;
newmove.c:    *p = (*p)->next;
newmove.c:  treenode[index - 1] = *p;
newmove.c:  printf("copynode: fromnode->numnuc = %ld, tonode->numnuc = %ld\n", fromnode->numnuc, tonode->numnuc);
newmove.c:  if (fromnode->statezero != NULL)
newmove.c:    memcpy(tonode->statezero, fromnode->statezero, words * sizeof(long));
newmove.c:  if (fromnode->stateone != NULL)
newmove.c:    memcpy(tonode->stateone, fromnode->stateone, words * sizeof(long));
newmove.c:  if (fromnode->zerosteps != NULL)
newmove.c:    memcpy(tonode->zerosteps, fromnode->zerosteps, words * sizeof(long));
newmove.c:  if (fromnode->onesteps != NULL)
newmove.c:    memcpy(tonode->onesteps, fromnode->onesteps, words * sizeof(long));
newmove.c:  tonode->state   = fromnode->state;
newmove.c:  tonode->index   = fromnode->index;
newmove.c:  tonode->tip     = fromnode->tip;
newmove.c:    tonode->nayme[i] = fromnode->nayme[i];
newmove.c:  if(!newnode->statezero)
newmove.c:    newnode->statezero = (bitptr)Malloc(words * sizeof(long));
newmove.c:  if(!newnode->stateone)
newmove.c:    newnode->stateone = (bitptr)Malloc(words * sizeof(long));
newmove.c:  if(!newnode->zerosteps)
newmove.c:    newnode->zerosteps = (bitptr)Malloc(words * sizeof(long));
newmove.c:  if(!newnode->onesteps)
newmove.c:    newnode->onesteps = (bitptr)Malloc(words * sizeof(long));
newmove.c:  if (treenode[p->index-1] == p)
newmove.c:    treesets[othertree].treenode[p->index-1] = newnode;
newmove.c:  if (p->tip)
newmove.c:  q = p->next;
newmove.c:  if(!newnextnode->statezero)
newmove.c:    newnextnode->statezero = (bitptr)Malloc(words * sizeof(long));
newmove.c:  if(!newnextnode->stateone)
newmove.c:    newnextnode->stateone = (bitptr)Malloc(words * sizeof(long));
newmove.c:  if(!newnextnode->zerosteps)
newmove.c:    newnextnode->zerosteps = (bitptr)Malloc(words * sizeof(long));
newmove.c:  if(!newnextnode->onesteps)
newmove.c:    newnextnode->onesteps = (bitptr)Malloc(words * sizeof(long));
newmove.c:  newnode->next = newnextnode;
newmove.c:    newnextnode->back = copytrav(q->back);
newmove.c:    newnextnode->back->back = newnextnode;
newmove.c:    q = q->next;
newmove.c:      newnextnode->next = newnode;
newmove.c:      if(!newnextnode->statezero)
newmove.c:        newnextnode->statezero = (bitptr)Malloc(words * sizeof(long));
newmove.c:      if(!newnextnode->stateone)
newmove.c:        newnextnode->stateone = (bitptr)Malloc(words * sizeof(long));
newmove.c:      if(!newnextnode->zerosteps)
newmove.c:        newnextnode->zerosteps = (bitptr)Malloc(words * sizeof(long));
newmove.c:      if(!newnextnode->onesteps)
newmove.c:        newnextnode->onesteps = (bitptr)Malloc(words * sizeof(long));
newmove.c:      temp->next = newnextnode;
newmove.c:  /* base case -- tip */
newmove.c:  if(p->tip)
newmove.c:  q = p->next;
newmove.c:    chucktree(q->back);
newmove.c:    q = q->next;
newmove.c:  /* now chuck all sub-nodes in the node ring */
newmove.c:    r = q->next;
newmove.c:           (!(allwagner || mixture)) ? "Camin-Sokal"  : "(methods in mixture)");
newmove.c:      wagner[i] = (1L << (bits + 1)) - (1L << 1);
newmove.c:    printf("Camin-Sokal parsimony method\n\n");
newmove.c:  /* configure to machine -- set up special characters */
newmove.c:  che[(long)overt] = '-';
newmove.c:  if (below != treenode[below->index - 1])
newmove.c:    below = treenode[below->index - 1];
newmove.c:  if (below->back != NULL) {
newmove.c:    below->back->back = newfork;
newmove.c:  newfork->back = below->back;
newmove.c:  rtdesc->back = newfork->next->next;
newmove.c:  newfork->next->next->back = rtdesc;
newmove.c:  newfork->next->back = leftdesc;
newmove.c:  leftdesc->back = newfork->next;
newmove.c:  root->back = NULL;
newmove.c:  if (atnode != treenode[atnode->index - 1])
newmove.c:    atnode = treenode[atnode->index - 1];
newmove.c:  q = treenode[newtip->index-1]->back;
newmove.c:    q = treenode[q->index-1];
newmove.c:    if (newtip == q->next->next->back) {
newmove.c:      q->next->back = newtip;
newmove.c:      newtip->back = q->next;
newmove.c:      q->next->next->back = NULL;
newmove.c:  if (newtip->back != NULL) {
newmove.c:    add_at(atnode, newtip, treenode[newtip->back->index-1]);
newmove.c:  if (parent != treenode[parent->index - 1])
newmove.c:    parent = treenode[parent->index - 1];
newmove.c:  newnode->tip = false;
newmove.c:  newnode->deleted=false;
newmove.c:  newnode->deadend=false;
newmove.c:  newnode->onebranch=false;
newmove.c:  newnode->onebranchhaslength=false;
newmove.c:    newnode->nayme[i] = '\0';
newmove.c:  newnode->index = parent->index;
newmove.c:  if(!newnode->statezero)
newmove.c:    newnode->statezero = (bitptr)Malloc(words * sizeof(long));
newmove.c:  if(!newnode->stateone)
newmove.c:    newnode->stateone = (bitptr)Malloc(words * sizeof(long));
newmove.c:  if(!newnode->zerosteps)
newmove.c:    newnode->zerosteps = (bitptr)Malloc(words * sizeof(long));
newmove.c:  if(!newnode->onesteps)
newmove.c:    newnode->onesteps = (bitptr)Malloc(words * sizeof(long));
newmove.c:    q = q->next;
newmove.c:  } while (q->next != parent);
newmove.c:  newnode->next = parent;
newmove.c:  q->next = newnode;
newmove.c:  newnode->back = newchild;
newmove.c:  newchild->back = newnode;
newmove.c:  if (newchild->haslength) {
newmove.c:    newnode->length = newchild->length;
newmove.c:    newnode->haslength = true;
newmove.c:    newnode->haslength = false;
newmove.c:  if (below != treenode[below->index - 1])
newmove.c:    below = treenode[below->index - 1];
newmove.c:  if (below->back != NULL)
newmove.c:    below->back->back = newfork;
newmove.c:  newfork->back = below->back;
newmove.c:  rtdesc->back = newfork->next->next;
newmove.c:  newfork->next->next->back = rtdesc;
newmove.c:  newfork->next->back = leftdesc;
newmove.c:  leftdesc->back = newfork->next;
newmove.c:  root->back = NULL;
newmove.c:  newfork->numdesc = 2;
newmove.c:  if ((*item)->back == NULL) {
newmove.c:  *fork = treenode[(*item)->back->index - 1];
newmove.c:  if ((*fork)->next->back == *item)
newmove.c:  q = (*fork)->next;
newmove.c:    if (q->next->back == *item)
newmove.c:    q = q->next;
newmove.c:    p->next = (*item)->back->next;
newmove.c:    chuck(&grbg, (*item)->back);
newmove.c:    (*item)->back = NULL;
newmove.c:    if (*item == (*fork)->next->back) {
newmove.c:        root = (*fork)->next->next->back;
newmove.c:        root = (*fork)->next->back;
newmove.c:    p = (*item)->back->next->back;
newmove.c:    q = (*item)->back->next->next->back;
newmove.c:      p->back = q;
newmove.c:      q->back = p;
newmove.c:        p->length += q->length;
newmove.c:        q->length = p->length;
newmove.c:        (*item)->length = (*fork)->next->length + (*fork)->next->next->length;
newmove.c:    (*fork)->back = NULL;
newmove.c:    p = (*fork)->next;
newmove.c:      p->back = NULL;
newmove.c:      p = p->next;
newmove.c:    (*item)->back = NULL;
newmove.c:    wa_2[i] = ((long)wagner[j - 1]) & (1L << k);
newmove.c:    za_2[i] = ((long)zeroanc[j - 1]) & (1L << k);
newmove.c:    oa_2[i] = ((long)oneanc[j - 1]) & (1L << k);
newmove.c:  q = p->next;
newmove.c:    q = q->next;
newmove.c:  printf("new_move_fillin: index = %d\n", p->index);
newmove.c:      //------------- wagner[i] if
newmove.c:      /*p->statezero[i] = 0;*/
newmove.c:      /*p->statezero[j] &= ~(1L << k);*/ /*xx*/
newmove.c:      /*p->stateone[i] = 0;*/
newmove.c:      /*p->stateone[j] &= ~(1L << k);*/
newmove.c:      q = p->next;
newmove.c:          for (ii=5; ii >= 0; ii--) {
newmove.c:            printf("%d", (q->back->statezero[j-1] & (1L << ii)) > 0);
newmove.c:          for (ii=5; ii >= 0; ii--) {
newmove.c:            printf("%d", (q->back->stateone[j-1] & (1L << ii)) > 0);
newmove.c:        if ((q->back->statezero[j-1]) & (1L << k)) {
newmove.c:        if ((q->back->stateone[j-1]) & (1L << k)) {
newmove.c:        q = q->next;
newmove.c:        p->stateone[j-1] |= (1L << k);
newmove.c:          p->statezero[j-1] |= (1L << k);
newmove.c:          /*p->statezero[j-1] |= (1L << k);
newmove.c:            p->stateone[j-1] |= (1L << k);*/
newmove.c:      if ((n - n1) <= (n - n0)) {
newmove.c:        /* printf("steps[%d] value = %d\n", i, n - n1);*/
newmove.c:        steps_a[i] = ((n - n1) > 1 ? 0 : (n - n1));
newmove.c:        /* printf("steps[%d] value = %d\n", i, n - n0);*/
newmove.c:        steps_a[i] = ((n - n0) > 1 ? 0 : (n - n0));
newmove.c:      //---------------- wagner[i] else
newmove.c:        p->zerosteps[i] = nzerosteps;
newmove.c:        p->onesteps[i] = nonesteps;
newmove.c:        p->zerosteps[i] = ((nzerosteps < nonesteps) ? nzerosteps : nonesteps);
newmove.c:        p->onesteps[i] = p->zerosteps[i];
newmove.c:    //-----------------
newmove.c:  for(ii=5;ii>=0;ii--) {
newmove.c:  for (ii=5; ii >= 0; ii--) {
newmove.c:    printf("%d", (steps[j-1] & (1L << k)) > 0);
newmove.c:  printf("p->statezero = ");
newmove.c:  for (ii=5; ii >= 0; ii--) {
newmove.c:    printf("%d", (p->statezero[j-1] & (1L << k)) > 0);
newmove.c:  printf("p->stateone  = ");
newmove.c:  for (ii=5; ii >= 0; ii--) {
newmove.c:    printf("%d", (p->stateone[j-1] & (1L << k)) > 0);
newmove.c:  puts("new_move_fillin ending ----");
newmove.c:  printf("debugnode: index = %d\n",p->index);
newmove.c:  for (ii=5; ii >= 0; ii--) {
newmove.c:    printf("%d", (steps[j-1] & (1L << k)) > 0);
newmove.c:  printf("p->statezero = ");
newmove.c:  for (ii=5; ii >= 0; ii--) {
newmove.c:    printf("%d", (p->statezero[j-1] & (1L << k)) > 0);
newmove.c:  printf("p->stateone  = ");
newmove.c:  for (ii=5; ii >= 0; ii--) {
newmove.c:    printf("%d", (p->stateone[j-1] & (1L << k)) > 0);
newmove.c:  for (ii=5; ii >= 0; ii--) {
newmove.c:    printf("%d", (p->next->back->statezero[j-1] & (1L << k)) > 0);
newmove.c:  for (ii=5; ii >= 0; ii--) {
newmove.c:    printf("%d", (p->next->back->stateone[j-1] & (1L << k)) > 0);
newmove.c:  for (ii=5; ii >= 0; ii--) {
newmove.c:    printf("%d", (p->next->next->back->statezero[j-1] & (1L << k)) > 0);
newmove.c:  for (ii=5; ii >= 0; ii--) {
newmove.c:    printf("%d", (p->next->next->back->stateone[j-1] & (1L << k)) > 0);
newmove.c:    l0 = p->next->back->statezero[i];
newmove.c:    l1 = p->next->back->stateone[i];
newmove.c:    r0 = p->next->next->back->statezero[i];
newmove.c:    r1 = p->next->next->back->stateone[i];
newmove.c:    p->stateone[i] = (l1 | r1) & (~(st & (wa | za)));
newmove.c:    p->statezero[i] = (l0 | r0) & (~(st & (wa | oa)));
newmove.c:    if (((1L << l) & stps[j - 1]) != 0) {
newmove.c:      if (((1L << l) & zeroanc[j - 1]) != 0)
newmove.c:      if (((1L << l) & zeroanc[j - 1]) != 0)
newmove.c:  if (p->tip)
newmove.c:  q = p->next;
newmove.c:    move_postorder(q->back);
newmove.c:    q = q->next;
newmove.c:  mycount(r->stateone, zeroanc, numszero, numsone);
newmove.c:  mycount(r->statezero, zeroanc, numszero, numsone);
newmove.c:  like = -sum;
newmove.c:  if(outgroup->back->index == root->index)
newmove.c:  q = root->next;
newmove.c:    q = p->next;
newmove.c:  p = outgroup->back;
newmove.c:  while (p->index != root->index) {
newmove.c:    q = treenode[p->index - 1]->back;
newmove.c:    treenode[p->index - 1] = p;
newmove.c:    treenode[p->index - 1] = p;
newmove.c:    r->next = root->next;
newmove.c:    root->next = NULL;
newmove.c:      /* root->haslength remains false, or else treeout() will generate
newmove.c:      root->next->haslength = true;
newmove.c:      root->next->next->haslength = true;
newmove.c:    q = root->next;
newmove.c:    q->back->back = r->back;
newmove.c:    r->back->back = q->back;
newmove.c:      r->back->length = r->back->length + q->back->length;
newmove.c:      q->back->length = r->back->length;
newmove.c:  root->next->back = outgroup;
newmove.c:  root->next->next->back = outgroup->back;
newmove.c:  outgroup->back->back = root->next->next;
newmove.c:  outgroup->back = root->next;
newmove.c:    templen = outgroup->length / 2.0;
newmove.c:    outgroup->length = templen;
newmove.c:    outgroup->back->length = templen;
newmove.c:    root->next->next->length = templen;
newmove.c:    root->next->next->back->length = templen;
newmove.c:  if (outgroup->back->index == root->index)
newmove.c:  newbottom = outgroup->back;
newmove.c:  p = treenode[newbottom->index - 1]->back;
newmove.c:  while (p->index != root->index) {
newmove.c:    oldbottom = treenode[p->index - 1];
newmove.c:    treenode[p->index - 1] = p;
newmove.c:    p = oldbottom->back;
newmove.c:  onleft = (p == root->next);
newmove.c:      p = root->next->next;
newmove.c:      q = root->next;
newmove.c:      p = root->next;
newmove.c:      q = root->next->next;
newmove.c:      oldoutgrno = root->next->next->back->index;
newmove.c:      oldoutgrno = root->next->back->index;
newmove.c:    p = root->next;
newmove.c:    q = root->next->next;
newmove.c:  p->back->back = q->back;
newmove.c:  q->back->back = p->back;
newmove.c:  p->back = outgroup;
newmove.c:  q->back = outgroup->back;
newmove.c:      outgroup->back->back = root->next;
newmove.c:      outgroup->back = root->next->next;
newmove.c:      outgroup->back->back = root->next->next;
newmove.c:      outgroup->back = root->next;
newmove.c:    outgroup->back->back = root->next->next;
newmove.c:    outgroup->back = root->next;
newmove.c:  treenode[newbottom->index - 1] = newbottom;
newmove.c:  if (r->tip)
newmove.c:  q = r->next;
newmove.c:    move_filltrav(q->back);
newmove.c:    q = q->next;
newmove.c:  bottom = (r->back == NULL);
newmove.c:    memcpy(zerobelow->bits_, zeroanc, words * sizeof(long));
newmove.c:    memcpy(onebelow->bits_, oneanc, words * sizeof(long));
newmove.c:    memcpy(zerobelow->bits_, treenode[r->back->index - 1]->statezero, words * sizeof(long));
newmove.c:    memcpy(onebelow->bits_, treenode[r->back->index - 1]->stateone, words * sizeof(long));
newmove.c:    s0 = r->statezero[i];
newmove.c:    s1 = r->stateone[i];
newmove.c:    a0 = zerobelow->bits_[i];
newmove.c:    a1 = onebelow->bits_[i];
newmove.c:    if (!r->tip) {
newmove.c:      l0 = r->next->back->statezero[i];
newmove.c:      l1 = r->next->back->stateone[i];
newmove.c:      r0 = r->next->next->back->statezero[i];
newmove.c:      r1 = r->next->next->back->stateone[i];
newmove.c:      r->statezero[i] = s0;
newmove.c:      r->stateone[i] = s1;
newmove.c:  if (((1L << dispbit) & r->stateone[dispword - 1]) != 0)
newmove.c:    if (((1L << dispbit) & r->statezero[dispword - 1]) != 0)
newmove.c:      r->state = '?';
newmove.c:      r->state = '1';
newmove.c:    if (((1L << dispbit) & r->statezero[dispword - 1]) != 0)
newmove.c:      r->state = '0';
newmove.c:      r->state = '?';
newmove.c:  if (!r->tip)
newmove.c:    move_hyptrav(r->next->back);
newmove.c:    move_hyptrav(r->next->next->back);
newmove.c:      zeroanc[j - 1] = ((long)zeroanc[j - 1]) | (1L << k);
newmove.c:      oneanc[j - 1] = ((long)oneanc[j - 1]) | (1L << k);
newmove.c:    if ((*pos) >= leftedge && (*pos) - leftedge + 1 < screenwidth)
newmove.c:  if (i == (long)p->ycoord && (p == root || subtree)) {
newmove.c:      switch (p->state)
newmove.c:    if (p->index >= 100)
newmove.c:      nnwrite(p->index, 3, &pos, leftedge, screenwidth);
newmove.c:    else if (p->index >= 10) {
newmove.c:      nnwrite(p->index, 2, &pos, leftedge, screenwidth);
newmove.c:      nnwrite(p->index, 1, &pos, leftedge, screenwidth);
newmove.c:    if (!p->tip) {
newmove.c:      r = p->next;
newmove.c:        if (i >= r->back->ymin && i <= r->back->ymax) {
newmove.c:          q = r->back;
newmove.c:        r = r->next;
newmove.c:      first = p->next->back;
newmove.c:      r = p->next;
newmove.c:      while (r->next != p)
newmove.c:        r = r->next;
newmove.c:      last = r->back;
newmove.c:    n = (long)p->xcoord - (long)q->xcoord;
newmove.c:    if (n < 3 && !q->tip)
newmove.c:      n--;
newmove.c:    if ((long)q->ycoord == i && !done) {
newmove.c:      else if ((long)q->ycoord == (long)p->ycoord)
newmove.c:        switch (q->state)
newmove.c:        grwrite(c, n - 3, &pos);
newmove.c:      if (q->index >= 100)
newmove.c:        nnwrite(q->index, 3, &pos, leftedge, screenwidth);
newmove.c:      else if (q->index >= 10) {
newmove.c:        nnwrite(q->index, 2, &pos, leftedge, screenwidth);
newmove.c:        nnwrite(q->index, 1, &pos, leftedge, screenwidth);
newmove.c:    } else if (!q->tip) {
newmove.c:      if ((long)last->ycoord > i && (long)first->ycoord < i
newmove.c:          && i != (long)p->ycoord) {
newmove.c:        if (i < (long)p->ycoord)
newmove.c:          st = p->next->back->state;
newmove.c:          st = p->next->next->back->state;
newmove.c:        chwrite(' ', n - 1, &pos, leftedge, screenwidth);
newmove.c:  if ((long)p->ycoord == i && p->tip) {
newmove.c:      if (nayme[p->index - 1][j - 1] != '\0')
newmove.c:      chwrite(nayme[p->index - 1][j], 1, &pos, leftedge, screenwidth);
newmove.c:    dow--;
newmove.c:    printf("%10.1f Steps", -like);
newmove.c:    if (-like < bestyet) {
newmove.c:      bestyet = -like;
newmove.c:    } else if (fabs(-like - bestyet) < 0.000001)
newmove.c:      if (-like < gotlike)
newmove.c:      else if (-like > gotlike)
newmove.c:  treelines = tipy - dow;
newmove.c:    printf("** %ld lines above screen **\n", topedge - 1);
newmove.c:  if ((treelines - topedge + 1) > (screenlines - vmargin))
newmove.c:    if (i >= topedge && i < topedge + screenlines - vmargin)
newmove.c:  if ((treelines - topedge + 1) > (screenlines - vmargin)) {
newmove.c:    printf("** %ld", treelines - (topedge - 1 + screenlines - vmargin));
newmove.c:  if (treelines - topedge + vmargin + 1 < screenlines)
newmove.c:  gotlike = -like;
newmove.c:    add2(treenode[spp+ i - 3], treenode[i - 1], treenode[spp + i - 2],
newmove.c:      putchar(nayme[i - 1][j]);
newmove.c:      ok = (ok && ((j >= 1 && j < i) || (j > spp && j < spp + i - 1)));
newmove.c:    if (j >= i) {   /* has user chosen a non-tip? if so, offer choice */
newmove.c:        if (!treenode[j - 1]->tip) {
newmove.c:          add_child(treenode[j - 1], treenode[i - 1]);
newmove.c:        printf("dnamove_add(below %ld, newtip %ld, newfork %ld)\n",j-1,i-1,spp+i-2);
newmove.c:        dnamove_add(treenode[j - 1], treenode[i - 1], treenode[spp + i - 2]);
newmove.c:      treenode[nodei - 1] = *p;
newmove.c:      /* Open in binary: ftell() is broken for UNIX line-endings under WIN32 */
newmove.c:          p->stateone = (bitptr)Malloc(words * sizeof(long));
newmove.c:          p->statezero = (bitptr)Malloc(words * sizeof(long));
newmove.c:          p->onesteps = (bitptr)Malloc(words * sizeof(long));
newmove.c:          p->zerosteps = (bitptr)Malloc(words * sizeof(long));
newmove.c:          p = p->next;
newmove.c:    outgrno = root->next->back->index;
newmove.c:  if (outgropt && in_tree[outgrno - 1])
newmove.c:    move_reroot(treenode[outgrno - 1]);
newmove.c:  start = treenode[index - 1];
newmove.c:  q = start->next;
newmove.c:    q = q->next;
newmove.c:    r = treenode[i - 1];
newmove.c:    if (!(r->tip))
newmove.c:      r->index--;
newmove.c:    if (!(r->tip)) {
newmove.c:      q = r->next;
newmove.c:        q->index--;
newmove.c:        q = q->next;
newmove.c:    treenode[i - 1] = treenode[i];
newmove.c:  nonodes--;
newmove.c:  ok1 = (ok1 && i >= 1 && i <= (spp * 2 - 1) && i != root->index);
newmove.c:    ok1 = !treenode[i - 1]->deleted;
newmove.c:    ok2 = (ok2 && j >= 1 && j <= (spp * 2 - 1));
newmove.c:      if (j != root->index)
newmove.c:        ok2 = !treenode[treenode[j - 1]->back->index - 1]->deleted;
newmove.c:      /*  ok2 = (nodep[j - 1] != nodep[nodep[i - 1]->back->index - 1]);*/
newmove.c:      p = treenode[j - 1];
newmove.c:        ok2 = (ok2 && p != treenode[i - 1]);
newmove.c:        p = treenode[p->back->index - 1];
newmove.c:            exxit(-1);
newmove.c:          if (!(treenode[j - 1]->deleted) && !treenode[j - 1]->tip) {
newmove.c:            move_re_move(&treenode[i - 1], &q);
newmove.c:            add_child(treenode[j - 1], treenode[i - 1]);
newmove.c:              consolidatetree(q->index);
newmove.c:          if (j != root->index) { /* can't insert at root */
newmove.c:            move_re_move(&treenode[i - 1], &q);
newmove.c:              treenode[q->index-1]->next->back = treenode[i-1];
newmove.c:              treenode[i-1]->back = treenode[q->index-1]->next;
newmove.c:            add_before(treenode[j - 1], treenode[i - 1]);
newmove.c:  ok1 = (ok1 && i >= 1 && i < spp * 2 && i != root->index);
newmove.c:      ok2 = (treenode[j - 1] != treenode[treenode[i - 1]->back->index - 1]);
newmove.c:      p = treenode[j - 1];
newmove.c:        ok2 = (ok2 && p != treenode[i - 1]);
newmove.c:        p = treenode[p->back->index - 1];
newmove.c:        q = treenode[treenode[i - 1]->back->index - 1];
newmove.c:        if (q->next->back->index == i)
newmove.c:          fromwhere = q->next->next->back->index;
newmove.c:          fromwhere = q->next->back->index;
newmove.c:        re_move2(&treenode[i - 1], &q, &root, &wasleft, treenode);
newmove.c:        add2(treenode[j - 1], treenode[i - 1], q, &root, restoring, wasleft, treenode);
newmove.c:  place[p->index - 1] = -like;
newmove.c:  if (!p->tip) {
newmove.c:    addpreorder(p->next->back, item, nufork, place);
newmove.c:    addpreorder(p->next->next->back, item, nufork, place);
newmove.c:  if (!(ok && i >= 1 && i <= nonodes && i != root->index)) {
newmove.c:    place[j] = -1.0;
newmove.c:  current = -like;
newmove.c:  q = treenode[treenode[i - 1]->back->index - 1];
newmove.c:  if (q->next->back->index == i)
newmove.c:    fromwhere = q->next->next->back->index;
newmove.c:    fromwhere = q->next->back->index;
newmove.c:  if (root->index == treenode[i - 1]->back->index) {
newmove.c:    if (treenode[treenode[i - 1]->back->index - 1]->next->back == treenode[i - 1])
newmove.c:      rute = treenode[treenode[i - 1]->back->index - 1]->next->next->back;
newmove.c:      rute = treenode[treenode[i - 1]->back->index - 1]->next->back;
newmove.c:  re_move2(&treenode[i - 1], &dummy, &root, &wasleft, treenode);
newmove.c:  addpreorder(root, treenode[i - 1], dummy, place);
newmove.c:  add2(treenode[fromwhere - 1], treenode[what - 1],dummy, &root,
newmove.c:  like = -current;
newmove.c:    if (place[j - 1] < current && place[j - 1] >= 0.0) {
newmove.c:      printf("%3ld:%6.2f", j, place[j - 1]);
newmove.c:    if (fabs(place[j - 1] - current) < 1.0e-6 && j != fromwhere) {
newmove.c:      re_move2(&treenode[what - 1], &q, &root, &wasleft, treenode);
newmove.c:      add2(treenode[fromwhere - 1], treenode[what - 1],q, &root,
newmove.c:      q = treenode[atwhat - 1]->next->back;
newmove.c:      treenode[atwhat - 1]->next->back =
newmove.c:        treenode[atwhat - 1]->next->next->back;
newmove.c:      treenode[atwhat - 1]->next->next->back = q;
newmove.c:      treenode[atwhat - 1]->next->back->back = treenode[atwhat - 1]->next;
newmove.c:      treenode[atwhat - 1]->next->next->back->back =
newmove.c:        treenode[atwhat - 1]->next->next;
newmove.c:      reroot(treenode[outgrno - 1]);
newmove.c:      nuroot = treenode[i - 1];
newmove.c:  /* flip at a node left-right */
newmove.c:    p = treenode[i - 1]->next->back;
newmove.c:    treenode[i - 1]->next->back = treenode[i - 1]->next->next->back;
newmove.c:    treenode[i - 1]->next->next->back = p;
newmove.c:    treenode[i - 1]->next->back->back = treenode[i - 1]->next;
newmove.c:    treenode[i - 1]->next->next->back->back = treenode[i - 1]->next->next;
newmove.c:  if (p->tip)
newmove.c:  q = p->next;
newmove.c:    if (q->next->next == p) {
newmove.c:      r = q->next;
newmove.c:    q = q->next;
newmove.c:    lprev->next = r;
newmove.c:    rprev->next = l;
newmove.c:    temp = r->next;
newmove.c:    r->next = l->next;
newmove.c:    l->next = temp;
newmove.c:    if (i < (loopcount - 1)) {
newmove.c:      q = p->next;
newmove.c:        if (q == lprev->next && !lprevflag) {
newmove.c:          l = q->next;
newmove.c:        if (q->next == rprev) {
newmove.c:          r = q->next;
newmove.c:        q = q->next;
newmove.c:    q = p->next;
newmove.c:      fliptrav(q->back, true);
newmove.c:      q = q->next;
newmove.c:  /* flip at a node left-right */
newmove.c:    fliptrav(treenode[i - 1], true);
newmove.c:    ok = (ok && in_tree[i - 1] && i >= 1 && i <= nonodes &&
newmove.c:          i != root->index);
newmove.c:  if (in_tree[outgrno - 1])
newmove.c:    move_reroot(treenode[outgrno - 1]);
newmove.c:    printf("\nNEXT? (Options: R # + - S . T U W O F H J K L C ? X Q) ");
newmove.c:    if (strchr("R#+-S.TUWOFHJKLC?XQ",ch) != NULL)
newmove.c:        case '-':
newmove.c:  fullset = (1L << (bits + 1)) - (1L << 1);
newmove.c:  bestyet = -like;
newmove.c:  gotlike = -like;
newmove.c:  bits = 8 * sizeof(long) - 1;
pars.c:/* Version 4.0 (c) Copyright 1993-2013 by the University of Washington.
pars.c:      printf("  .  Use dot-differencing to display them  %s\n",
pars.c:    alias[i - 1] = i;
pars.c:    oldweight[i - 1] = weight[i - 1];
pars.c:    ally[i - 1] = i;
pars.c:    if (ally[i - 1] == i)
pars.c:    location[alias[i - 1] - 1] = i;
pars.c:    fprintf(outfile, "\nrequires a total of %10.3f\n", -(curtree->score));
pars.c:    fprintf(outfile, "  -------      ---       ------\n");
pars.c:    printbranchlengths(curtree->root);
pars.c:    treeout3(curtree->root, nextree, &col, curtree->root);
pars.c:  if (p->tip)
pars.c:    p->xcoord = (long)(over * lengthsum + 0.5);
pars.c:    p->ycoord = (*tipy);
pars.c:    p->ymin = (*tipy);
pars.c:    p->ymax = (*tipy);
pars.c:  q = p->next;
pars.c:    xx = q->v;
pars.c:    pars_coordinates(q->back, lengthsum + xx, tipy, tipmax);
pars.c:    q = q->next;
pars.c:  first = p->next->back;
pars.c:  while (q->next != p)
pars.c:    q = q->next;
pars.c:  last = q->back;
pars.c:  p->xcoord = (long)(over * lengthsum + 0.5);
pars.c:  if ((p == curtree->root) || count_sibs(p) > 2)
pars.c:    p->ycoord = p->next->next->back->ycoord;
pars.c:    p->ycoord = (first->ycoord + last->ycoord) / 2;
pars.c:  p->ymin = first->ymin;
pars.c:  p->ymax = last->ymax;
pars.c:  pars_coordinates(curtree->root, 0.0, &tipy, &tipmax);
pars.c:  for (i = 1; i <= (tipy - down); i++)
pars.c:    drawline3(i, scale, curtree->root);
pars.c:          sprintf(progbuf, "-");
pars.c:      long missedCount = nextree - 1 - maxtrees;
pars.c:        curtree->evaluate(curtree, curtree->root, 0);
pars.c:        curtree->root = root_tree(curtree, curtree->root);
pars.c:        disc_treelength(curtree->root, chars, curtree->nodep);
pars.c:    /* Open in binary: ftell() is broken for UNIX line-endings under WIN32 */
pars.c:      exxit(-1);
pars.c:        fprintf(outfile, "User-defined tree");
pars.c:        fsteps[j - 1] = (long *)Malloc(endsite * sizeof(long));
pars.c:      treeread(curtree, intree, &curtree->root, curtree->nodep, &goteof, &firsttree, &nextnode, &haslengths, initparsnode, false, nonodes);
pars.c:      reroot_tree(curtree, curtree->root);                // RSGbugfix: Name change.
pars.c:      curtree->evaluate(curtree, curtree->root, false);
pars.c:        rebestyet = curtree->score;
pars.c:        curtree->root = root_tree(curtree, curtree->root);
pars.c:          reroot(curtree->nodep[outgrno - 1], curtree->root);
pars.c:        disc_treelength(curtree->root, chars, curtree->nodep);
pars.c:      for (i = 0; i <= (nextree - 2); i++)
pars.c:        curtree->evaluate(curtree, curtree->root, 0);
pars.c:        curtree->root = root_tree(curtree, curtree->root);
pars.c:        disc_treelength(curtree->root, chars, curtree->nodep);
pars.c:        free(fsteps[j - 1]);
pars.c:  funcs->node_new = discretepars_node_new;
pars.c:  funcs->tree_new = discretepars_tree_new;
pars.c:  funcs->node_new = discretepars_node_new;
pars.c:  funcs->tree_new = discretepars_tree_new;
parsimony.c:/* Version 4.0. (c) Copyright 1993-2013 by the University of Washington.
parsimony.c:  nuroot = t->get_forknode(t, here->index);
parsimony.c:  nuroot->next = here->next;
parsimony.c:  here->next = nuroot;
parsimony.c:    for (p = fakeroot ; p->next != fakeroot ; p = p->next);
parsimony.c:    p->next = fakeroot->next;
parsimony.c:    if ( t->nodep[fakeroot->index - 1 ] == fakeroot)
parsimony.c:      t->nodep[fakeroot->index - 1 ] = p;
parsimony.c:    if ( t->root == fakeroot)           // RSGbugfix: Reroot before sending FORKNODE to freelist.
parsimony.c:      t->root = t->nodep[outgrno - 1]->back;
parsimony.c:    t->release_forknode(t, fakeroot);
parsimony.c:    hookup(fakeroot->next->back, fakeroot->next->next->back);
parsimony.c:    if ( t->root == fakeroot)           // RSGbugfix: Reroot before sending FORKRING to freelist.
parsimony.c:      t->root = t->nodep[outgrno - 1]->back;
parsimony.c:    t->release_fork(t, fakeroot);
parsimony.c:  t->save_traverses(t, item, p);
parsimony.c:  t->insert_(t, item, p, true, false);
parsimony.c:  like = t->evaluate(t, p, false);
parsimony.c:  t->re_move(t, item, &dummy, true);
parsimony.c:  t->restore_traverses(t, item, p);
parsimony.c:  t->evaluate(t, p, 0);   // as in dnaml, but may not be needed
parsimony.c:  if ( p->tip == false )
parsimony.c:    t->insert_(t, item, p, true, true);
parsimony.c:    like = t->evaluate(t, p, false);
parsimony.c:    t->re_move(t, item, &dummy, true);
parsimony.c:  t->globrearrange = pars_globrearrange;
parsimony.c:  t->try_insert_ = pars_tree_try_insert_;
parsimony.c:  t->evaluate = pars_tree_evaluate;
parsimony.c:  p->copy = pars_node_copy;
parsimony.c:  p->init = pars_node_init;
parsimony.c:  p->reinit = pars_node_reinit;
parsimony.c:  p->free = pars_node_free;
parsimony.c:  p->node_print_f = pars_node_print;
parsimony.c:  if (pn->numsteps)
parsimony.c:    free(pn->numsteps);
parsimony.c:  pn->numsteps = Malloc(endsite * sizeof(long));
parsimony.c:  if (pn->numsteps)
parsimony.c:    free(pn->numsteps);
parsimony.c:  pn->numsteps = Malloc(endsite * sizeof(long));
parsimony.c:  if(pn->numsteps == NULL) printf(" numsteps:<empty>");
parsimony.c:      printf(" %ld", pn->numsteps[i]);
parsimony.c:  free(pn->numsteps);
parsimony.c:  if (dst->numsteps == NULL )
parsimony.c:    dst->numsteps = Malloc(endsite * sizeof(long));
parsimony.c:  memcpy(dst->numsteps, src->numsteps, endsite * sizeof(long));
parsimony.c:  long treeLimit = nextree - 1 < maxtrees ? nextree - 1 : maxtrees;
parsimony.c:    while ( treecollapsible(t, t->nodep[0]))
parsimony.c:      collapsetree(t, t->nodep[0]);
parsimony.c:    for(j = k ; j < (treeLimit - 1) ; j++)
parsimony.c:    treeLimit--;
parsimony.c:  if ( p->tip )
parsimony.c:  if ( root->index == p->index && root != p)
parsimony.c:    return count_sibs(p) - 1;
parsimony.c:  if ( (p != root && p->back == NULL) ||
parsimony.c:       (p->next->back == NULL && p->next != root))
parsimony.c:  if (outgroup->back->index == root->index)
parsimony.c:  p = root->next;
parsimony.c:  q = root->next->next;
parsimony.c:  p->back->back = q->back;
parsimony.c:  q->back->back = p->back;
parsimony.c:  p->back = outgroup;
parsimony.c:  q->back = outgroup->back;
parsimony.c:  outgroup->back->back = q;
parsimony.c:  outgroup->back = p;
parsimony.c:  p = outgroup->back->next;
parsimony.c:  while (p->next != outgroup->back)
parsimony.c:    p = p->next;
parsimony.c:  root->next = outgroup->back;
parsimony.c:  p->next = root;
parsimony.c:  p = root->next;
parsimony.c:  while (p->next != root)
parsimony.c:    p = p->next;
parsimony.c:  t->release_forknode(t, root);
parsimony.c:  p->next = outgroup->back;
parsimony.c:  root2->next = lastdesc->next;
parsimony.c:  lastdesc->next = root2;
parsimony.c:  outgrnode = t->nodep[outgrno - 1];
parsimony.c:  p = outgrnode->back;
parsimony.c:  oldroot = t->root;
parsimony.c:  t->root = root_tree(t, p);
parsimony.c:  reroot_tree(t, t->root);              // RSGbugfix: Name change.
parsimony.c:  t->root = oldroot;
parsimony.c:  outgrnode = t->nodep[outgrno - 1];
parsimony.c:  if (get_numdesc(t->root, t->root) == 2)
parsimony.c:    bintomulti(t, &t->root, &binroot);
parsimony.c:  if (outgrin(t->root, outgrnode))
parsimony.c:    if (outgrnode != t->root->next->back)
parsimony.c:      moveleft(t->root, outgrnode, &flipback);
parsimony.c:    root2 = t->root;
parsimony.c:    lastdesc = t->root->next;
parsimony.c:    while (lastdesc->next != t->root)
parsimony.c:      lastdesc = lastdesc->next;
parsimony.c:    lastdesc->next = t->root->next;
parsimony.c:    t->root = t->get_forknode(t, outgrnode->back->index);
parsimony.c:    reroot2(outgrnode, t->root);
parsimony.c:  savetraverse(t->root);
parsimony.c:    if (get_numdesc(t->root, t->nodep[i - 1]) == 0)
parsimony.c:      flipindexes(i, t->nodep);
parsimony.c:  place[t->root->index - 1] = 1;
parsimony.c:    p = t->nodep[i - 1];
parsimony.c:    while (place[p->index - 1] == 0)
parsimony.c:      place[p->index - 1] = i;
parsimony.c:      while (!p->bottom)
parsimony.c:        p = p->next;
parsimony.c:      p = p->back;
parsimony.c:      q = t->nodep[i - 1];
parsimony.c:        if (parentinmulti(r, t->root))
parsimony.c:            place[i - 1] = place[p->index - 1];
parsimony.c:            place[i - 1] = smallest(r, place);
parsimony.c:            place[i - 1] = -smallest(r, place);
parsimony.c:          place[i - 1] = place[p->index - 1];
parsimony.c:        place[i - 1] = place[p->index - 1];
parsimony.c:        place[i - 1] = -smallest(q, place);
parsimony.c:        j = place[p->index - 1];
parsimony.c:          place[p->index - 1] = nextnode;
parsimony.c:          while (!p->bottom)
parsimony.c:            p = p->next;
parsimony.c:          p = p->back;
parsimony.c:            done = (place[p->index - 1] != j);
parsimony.c:    flipnodes(outgrnode, flipback->back);
parsimony.c:      reroot3(t, outgrnode, t->root, root2, lastdesc);
parsimony.c:      t->root = root2;
parsimony.c:    backtobinary(t, &t->root, binroot);
parsimony.c:  backa = nodea->back;
parsimony.c:  backb = nodeb->back;
parsimony.c:  backa->back = nodeb;
parsimony.c:  backb->back = nodea;
parsimony.c:  nodea->back = backb;
parsimony.c:  nodeb->back = backa;
parsimony.c:  p = root->next;
parsimony.c:    if (p->back == outgrnode)
parsimony.c:      flipnodes(root->next->back, p->back);
parsimony.c:    p = p->next;
parsimony.c:  if (p->tip)
parsimony.c:  q = p->next;
parsimony.c:    fprintf(outfile, "%6ld      ", q->index - spp);
parsimony.c:    if (q->back->tip)
parsimony.c:        putc(nayme[q->back->index - 1][i], outfile);
parsimony.c:      fprintf(outfile, "%6ld    ", q->back->index - spp);
parsimony.c:    fprintf(outfile, "   %f\n", q->v);
parsimony.c:    if (q->back)
parsimony.c:      printbranchlengths(q->back);
parsimony.c:    q = q->next;
parsimony.c:  p->v = 0.0;
parsimony.c:  if (p->back)
parsimony.c:    p->back->v = 0.0;
parsimony.c:  if (p->tip)
parsimony.c:  q = p->next;
parsimony.c:    initbranchlen(q->back);
parsimony.c:    q = q->next;
parsimony.c:  q = p->next;
parsimony.c:    q->v = 0.0;
parsimony.c:    q = q->next;
parsimony.c:  q = forknode->next;
parsimony.c:    if (q->back && q->back != p && !q->back->tip)
parsimony.c:    q = q->next;
parsimony.c:  while (treenode[last - 1]->back == NULL)
parsimony.c:    last--;
parsimony.c:    temp = treenode[nextnode - 1];
parsimony.c:    treenode[nextnode - 1] = treenode[last - 1];
parsimony.c:    treenode[last - 1] = temp;
parsimony.c:    newindex(nextnode, treenode[nextnode - 1]);
parsimony.c:    newindex(last, treenode[last - 1]);
parsimony.c:  while (!anode->bottom) anode = anode->next;
parsimony.c:  p = anode->back->next;
parsimony.c:    if (!p->bottom && place[p->back->index - 1] != 0)
parsimony.c:    p = p->next;
parsimony.c:  } while (p != anode->back);
parsimony.c:  while (!anode->bottom) anode = anode->next;
parsimony.c:  p = anode->back;
parsimony.c:  while (!p->bottom)
parsimony.c:    p = p->next;
parsimony.c:  while (!anode->bottom) anode = anode->next;
parsimony.c:  p = anode->back->next;
parsimony.c:  if (p->bottom) p = p->next;
parsimony.c:    if (p->back && place[p->back->index - 1] != 0)
parsimony.c:      if (p->back->index <= spp)
parsimony.c:        if (p->back->index < min)
parsimony.c:          min = p->back->index;
parsimony.c:        if (place[p->back->index - 1] < min)
parsimony.c:          min = place[p->back->index - 1];
parsimony.c:    p = p->next;
parsimony.c:    if (p->bottom) p = p->next;
parsimony.c:  } while (p != anode->back);
parsimony.c:  binroot->next->back = (*root)->next->back;
parsimony.c:  (*root)->next->back->back = binroot->next;
parsimony.c:  p = (*root)->next;
parsimony.c:  (*root)->next = p->next;
parsimony.c:  binroot->next->next->back = *root;
parsimony.c:  (*root)->back = binroot->next->next;
parsimony.c:  t->release_forknode(t, p);
parsimony.c:  while (p->index != i)
parsimony.c:    p->index = i;
parsimony.c:    p = p->next;
parsimony.c:/*  while ( !Slist_isempty(t->free_forkrings) ) t->get_forkring(t);   debug */
parsimony.c:  hookup(t->nodep[1], t->nodep[spp]->next);
parsimony.c:  hookup(t->nodep[0], t->nodep[spp]->next->next);
parsimony.c:    newtip = t->nodep[j-1];
parsimony.c:    if ( bestrees[treei].btree[j-1] > 0 )
parsimony.c:      below = (t->nodep[bestrees[treei].btree[j - 1] - 1]);
parsimony.c:      forknode = t->nodep[nextnode++ - 1]->next;
parsimony.c:      bback = below->back;
parsimony.c:      hookup(forknode->next, below);
parsimony.c:        hookup(forknode->next->next, bback);
parsimony.c:      below = t->nodep[t->nodep[-bestrees[treei].btree[j-1]-1]->back->index-1];
parsimony.c:      forknode = t->get_forknode(t, below->index);
parsimony.c:      forknode->next = below->next;
parsimony.c:      below->next = forknode;
parsimony.c:  nsibs = count_sibs(t->nodep[spp]);
parsimony.c:    for ( q = t->nodep[spp]->next ; q->next != t->nodep[spp] ; q = q->next);
parsimony.c:    q->next = t->nodep[spp]->next;
parsimony.c:    q = t->nodep[spp];
parsimony.c:    t->nodep[spp] = t->nodep[spp]->next;
parsimony.c:    t->release_forknode(t, q);
parsimony.c:    hookup(t->nodep[spp]->next->back, t->nodep[spp]->next->next->back);
parsimony.c:    t->release_fork(t, t->nodep[spp]); 
parsimony.c:  t->root = t->nodep[outgrno - 1]->back;
parsimony.c:  t->score = bestyet;
parsimony.c:  p->bottom = true;
parsimony.c:  if (p->tip)
parsimony.c:  q = p->next;
parsimony.c:    q->bottom = false;
parsimony.c:    savetraverse(q->back);
parsimony.c:    q = q->next;
parsimony.c:  right = (*root)->next->next->back;
parsimony.c:  left = (*root)->next->back;
parsimony.c:  if (right->tip)
parsimony.c:    (*root)->next = right->back;
parsimony.c:    (*root)->next->next = left->back;
parsimony.c:    right->back->next = *root;
parsimony.c:  newnode = t->get_forknode(t, right->index);
parsimony.c:  newnode->next = right->next;
parsimony.c:  newnode->back = left;
parsimony.c:  left->back = newnode;
parsimony.c:  right->next = newnode;
parsimony.c:  (*root)->next->back = (*root)->next->next->back = NULL;
parsimony.c:  (*root)->back = NULL;
parsimony.c:  p = root->next;
parsimony.c:    if (p->back == outgrnode)
parsimony.c:    p = p->next;
parsimony.c:  bestyet = oldbestyet = curtree->evaluate(curtree, curtree->root, 0);
parsimony.c:  for ( i = 0 ; i < curtree->nonodes ; i++ )
parsimony.c:    sib_ptr  = curtree->nodep[i];
parsimony.c:    if ( sib_ptr->tip )
parsimony.c:    if ( progress && ((i - spp) % (( curtree->nonodes / 72 ) + 1 ) == 0 ))
parsimony.c:      sib_ptr = curtree->nodep[i];
parsimony.c:        sib_ptr = sib_ptr->next;
parsimony.c:      if ( sib_ptr->back == NULL || sib_ptr->back->tip )
parsimony.c:      mulf = 2 != count_sibs(removed->back);
parsimony.c:      curtree->re_move(curtree, removed, &where, true);
parsimony.c:      if ( where->tip)
parsimony.c:        sib_ptr2 = where->back;
parsimony.c:        curtree->addtraverse(curtree, removed, sib_ptr2->back, true, &qwhere, &bestyet, NULL, NULL, 0, &multf);
parsimony.c:        sib_ptr2 = sib_ptr2->next;
parsimony.c:      curtree->insert_(curtree, removed, where, true, mulf);
parsimony.c:  if ( ((pars_tree*)t)->branchcollapsible(t, n) )
parsimony.c:  if ( n->back->tip == true )
parsimony.c:  for ( sib = n->back->next ; sib != n->back ; sib = sib->next )
parsimony.c:  m = n->back;
parsimony.c:  for ( sib = m->next ; sib != m ; sib = sib->next )
parsimony.c:    if ( sib == m->next )
parsimony.c:      newfork = t->get_forknode(t, n->index);
parsimony.c:      newfork->next = n->next;
parsimony.c:      n->next = newfork;
parsimony.c:    hookup(sib->back, newfork);
parsimony.c:  t->release_fork(t, m); 
parsimony.c:  inittrav(n->back);
parsimony.c:  n->initialized = false;
parsimony.c:  if ( ((pars_tree*)t)->branchcollapsible(t, n) )
parsimony.c:  if ( n->back->tip == true)
parsimony.c:  for ( sib = n->back->next ; sib != n->back ; sib = sib->next )
parsimony.c:  coordinates(t, t->root, 0.0, &tipy, &tipmax);
parsimony.c:  for (i = 1; i <= (tipy - down); i++)
parsimony.c:    drawline3(i, scale, t->root);
parsimony.c:  if (p->tip)
parsimony.c:    p->xcoord = (long)(over * lengthsum + 0.5);
parsimony.c:    p->ycoord = (*tipy);
parsimony.c:    p->ymin = (*tipy);
parsimony.c:    p->ymax = (*tipy);
parsimony.c:  q = p->next;
parsimony.c:    xx = q->v;
parsimony.c:    coordinates(t, q->back, lengthsum + xx, tipy, tipmax);
parsimony.c:    q = q->next;
parsimony.c:  first = p->next->back;
parsimony.c:  while (q->next != p)
parsimony.c:    q = q->next;
parsimony.c:  last = q->back;
parsimony.c:  p->xcoord = (long)(over * lengthsum + 0.5);
parsimony.c:  if ((p == t->root) || count_sibs(p) > 2)
parsimony.c:    p->ycoord = p->next->next->back->ycoord;
parsimony.c:    p->ycoord = (first->ycoord + last->ycoord) / 2;
parsimony.c:  p->ymin = first->ymin;
parsimony.c:  p->ymax = last->ymax;
parsimony.c:  if (i == (long)p->ycoord)
parsimony.c:    if (p->index - spp >= 10)
parsimony.c:      fprintf(outfile, " %2ld", p->index - spp);
parsimony.c:      fprintf(outfile, "  %ld", p->index - spp);
parsimony.c:    if (!p->tip)
parsimony.c:      r = p->next;
parsimony.c:        if (i >= r->back->ymin && i <= r->back->ymax)
parsimony.c:          q = r->back;
parsimony.c:        r = r->next;
parsimony.c:      first = p->next->back;
parsimony.c:      while (r->next != p)
parsimony.c:        r = r->next;
parsimony.c:      last = r->back;
parsimony.c:    done = (p->tip || p == q);
parsimony.c:    n = (long)(scale * (q->xcoord - p->xcoord) + 0.5);
parsimony.c:    if (n < 3 && !q->tip)
parsimony.c:      n--;
parsimony.c:    if ((long)q->ycoord == i && !done)
parsimony.c:      if ((long)p->ycoord != (long)q->ycoord)
parsimony.c:        putc('-', outfile);
parsimony.c:      if (!q->tip)
parsimony.c:        for (j = 1; j <= n - 2; j++)
parsimony.c:          putc('-', outfile);
parsimony.c:        if (q->index - spp >= 10)
parsimony.c:          fprintf(outfile, "%2ld", q->index - spp);
parsimony.c:          fprintf(outfile, "-%ld", q->index - spp);
parsimony.c:          putc('-', outfile);
parsimony.c:    else if (!p->tip)
parsimony.c:      if ((long)last->ycoord > i && (long)first->ycoord < i &&
parsimony.c:          (i != (long)p->ycoord || p == start))
parsimony.c:  if ((long)p->ycoord == i && p->tip)
parsimony.c:      putc(nayme[p->index-1][j], outfile);
parsimony.c:  if (t->root->initialized == false ) t->nuview(t, t->root);
parsimony.c:  fprintf(outfile, "\n     r------------------------------------");
parsimony.c:  fprintf(outfile, "-----\n");
parsimony.c:        l = location[ally[k - 1] - 1];
parsimony.c:        if (oldweight[k - 1] > 0)
parsimony.c:          fprintf(outfile, "%4ld", oldweight[k - 1] * (((pars_node*)t->root)->numsteps[l - 1] / weight[l - 1]));
parsimony.c:          fprintf(outfile, "%4ld", (((pars_node*)t->root)->numsteps[k - 1] ));
parsimony.c:      t->evaluate(t, t->root, 0);
parsimony.c:      t->globrearrange(t, progress, false);
parsimony.c:  /* used in dnapars -- writes branch lengths */
parsimony.c:  if (p->tip)
parsimony.c:      if (nayme[p->index - 1][i - 1] != ' ')
parsimony.c:      c = nayme[p->index - 1][i];
parsimony.c:    q = p->next;
parsimony.c:      treeout3(q->back, nextree, col, root);
parsimony.c:      q = q->next;
parsimony.c:  x = p->v;
parsimony.c:    w = (long)(0.43429448222 * log(-x)) + 1;
parsimony.c:    fprintf(outtree, "[%6.4f];\n", 1.0 / (nextree - 1));
parsimony.c:      *p = treep->get_forknode(treep, nodei);
parsimony.c:      treenode[nodei - 1] = *p;
parsimony.c:      *p = treep->get_forknode(treep, nodei);
parsimony.c:  if (p->back )
parsimony.c:    root = t->get_forknode(t, t->nonodes);
parsimony.c:    left = t->get_forknode(t, t->nonodes);
parsimony.c:    right = t->get_forknode(t, t->nonodes);
parsimony.c:    root->next = left;
parsimony.c:    left->next = right;
parsimony.c:    right->next = root;
parsimony.c:    left->back = p;
parsimony.c:    right->back = p->back;
parsimony.c:  t->nuview(t, root);
parsimony.c:    steps = ((pars_node*)root)->numsteps[i];
parsimony.c:    if (((pars_tree*)t)->supplement)
parsimony.c:      steps += ((pars_tree*)t)->supplement(t, i);
parsimony.c:    t->release_forknode(t, root);
parsimony.c:    t->release_forknode(t, left);
parsimony.c:    t->release_forknode(t, right);
parsimony.c:  t->score = -sum;
parsimony.c:  return -sum;
parsimony.c:    bestrees[i - 1].btree = (long *)Malloc(nonodes * sizeof(long));
penny.c:/* Version 4.0. (c) Copyright 1993-2013 by the University of Washington.
penny.c:    printf(" branch-and-bound to find all most parsimonious trees\n\n");
penny.c:           (!(allwagner || mixture)) ? "Camin-Sokal"  : "(methods in mixture)");
penny.c:    bestorders[i - 1] = (long *)Malloc(spp * sizeof(long));
penny.c:    bestrees[i - 1] = (long *)Malloc(spp * sizeof(long));
penny.c:  fprintf(outfile, " branch-and-bound to find all");
penny.c:        wagner[i] = (1L << (bits + 1)) - (1L << 1);
penny.c:        wagner[i] = (1L << (bits + 1)) - (1L << 1);
penny.c:        if (!ancone[k - 1])
penny.c:        if (!anczero[k - 1])
penny.c:      df1 = treenode[j]->empstte1[i] & (~treenode[j]->empstte0[i]);
penny.c:      df0 = treenode[j]->empstte0[i] & (~treenode[j]->empstte1[i]);
penny.c:  count(r->fulstte1, zeroanc, numszero, numsone);
penny.c:  count(r->empstte0, zeroanc, numszero, numsone);
penny.c:    bestyet = -1.0;
penny.c:  if ((*m) <= 2 || !(noroot && (a == root || a == root->next->back))) {
penny.c:          sprintf(progbuf, "         -        ");
penny.c:        sprintf(progbuf, "%17ld%20.2f\n", nextree - 1, fracdone * 100);
penny.c:    valyew[(*n) - 1] = like;
penny.c:    place[(*n) - 1] = a->index;
penny.c:  if (!a->tip) {
penny.c:    addtraverse(a->next->back, b, c, m, n, valyew, place);
penny.c:    addtraverse(a->next->next->back, b, c, m, n, valyew, place);
penny.c:    added[order[m - 1] - 1] = true;
penny.c:    addtraverse(root, treenode[order[m - 1] - 1], treenode[spp + m - 2], &m, &n, valyew, place);
penny.c:    besttoadd = order[m - 1];
penny.c:    bestsum = -1.0;
penny.c:      if (!added[i - 1])
penny.c:        added[i - 1] = true;
penny.c:        addtraverse(root, treenode[i - 1], treenode[spp + m - 2], &m, &n, valyew, place);
penny.c:        added[i - 1] = false;
penny.c:  order[m - 1] = besttoadd;
penny.c:      current[m - 1] = place[i];
penny.c:      add3(treenode[place[i] - 1], treenode[besttoadd - 1],
penny.c:           treenode[spp + m - 2], &root, treenode);
penny.c:      added[besttoadd - 1] = true;
penny.c:          memcpy(bestorders[nextree - 1], order, spp * sizeof(long));
penny.c:          memcpy(bestrees[nextree - 1], current, spp * sizeof(long));
penny.c:      re_move3(&treenode[besttoadd - 1], &treenode[spp + m - 2], &root, treenode);
penny.c:      added[besttoadd - 1] = false;
penny.c:  if (outgroup->back->index == root->index)
penny.c:  newbottom = outgroup->back;
penny.c:  p = treenode[newbottom->index - 1]->back;
penny.c:  while (p->index != root->index) {
penny.c:    oldbottom = treenode[p->index - 1];
penny.c:    treenode[p->index - 1] = p;
penny.c:    p = oldbottom->back;
penny.c:  p = root->next;
penny.c:  q = root->next->next;
penny.c:  p->back->back = q->back;
penny.c:  q->back->back = p->back;
penny.c:  p->back = outgroup;
penny.c:  q->back = outgroup->back;
penny.c:  outgroup->back->back = root->next->next;
penny.c:  outgroup->back = root->next;
penny.c:  treenode[newbottom->index - 1] = newbottom;
penny.c:  fullset = (1L << (bits + 1)) - (1L << 1);
penny.c:    sprintf(progbuf, "----------     ------------     ------------       ------------\n");
penny.c:  bestyet = -1.0;
penny.c:      fprintf(outfile, "%5ld trees in all found\n", nextree - 1);
penny.c:  for (i = 0; i <= (nextree - 2); i++)
penny.c:      add3(treenode[bestrees[i][j - 1] - 1],
penny.c:           treenode[bestorders[i][j - 1] - 1], treenode[spp + j - 2],
penny.c:      reroot(treenode[outgrno - 1]);
penny.c:    for (j = k - 1; j < spp; j++)
penny.c:      re_move3(&treenode[bestorders[i][j] - 1], &dummy, &root, treenode);
penny.c:        fprintf(outfile, "Camin-Sokal parsimony method\n\n");
penny.c:  bits = 8 * sizeof(long) - 1;
penny.c:{  /* Penny's branch-and-bound method */
penny.c:  bits = 8 * sizeof(long) - 1;
penny.c:}  /* Penny's branch-and-bound method */
phylip.c:/* Version 3.7. (c) Copyright 1993-2013 by the University of Washington.
phylip.c:    p = src->nodep[nsrc->index - 1];
phylip.c:    ret = dst->nodep[nsrc->index - 1];
phylip.c:      p = p->next;
phylip.c:      ret = ret->next;
phylip.c:  maxcircles = src->nonodes;
phylip.c:  if (dst->nonodes > src->nonodes) {
phylip.c:    maxcircles = dst->nonodes;
phylip.c:    src_sibs = count_sibs(src->nodep[i]);
phylip.c:    dst_sibs = count_sibs(dst->nodep[i]);
phylip.c:      p = dst->nodep[i]->next;
phylip.c:      dst->nodep[i]->next = dst->nodep[i]->next->next;
phylip.c:      dst->release_forknode(dst, p);    /* they go onto free_forknodes list */
phylip.c:      dst_sibs--;
phylip.c:    src_sibs = count_sibs(src->nodep[i]);
phylip.c:    dst_sibs = count_sibs(dst->nodep[i]);
phylip.c:      if (dst->nodep[i] == NULL) {
phylip.c:        p = dst->get_forknode(dst, i+1);   /* ... from free_fork_nodes list */
phylip.c:        dst->nodep[i] = p;
phylip.c:        p = dst->get_forknode(dst, i+1);   /* take another one off */
phylip.c:	p->next = dst->nodep[i];
phylip.c:	dst->nodep[i] = p;
phylip.c:      q->next = dst->nodep[i];        /* close the circle */
phylip.c:    src->nodep[i]->copy(src->nodep[i], dst->nodep[i]);
phylip.c:    if (src->nodep[i]->back != NULL) {
phylip.c:      dst->nodep[i]->back = where_in_dest(src, dst, src->nodep[i]->back);
phylip.c:  for (i = spp; i < src->nonodes; i++) { /* copy fork nodes and back links */
phylip.c:    p = src->nodep[i];
phylip.c:    q = dst->nodep[i];
phylip.c:          p->copy(p, q);
phylip.c:          q->back = where_in_dest(src, dst, p->back);
phylip.c:          p = p->next;
phylip.c:          q = q->next;
phylip.c:  dst->score = src->score;
phylip.c:  dst->root = where_in_dest(src, dst, src->root);
phylip.c:  dst->v = src->v;
phylip.c:  dst->xcoord = src->xcoord;
phylip.c:  dst->ycoord = src->ycoord;
phylip.c:  dst->ymin = src->ymin;
phylip.c:  dst->ymax = src->ymax;
phylip.c:  dst->iter = src->iter;
phylip.c:  dst->haslength = src->haslength;
phylip.c:  dst->initialized = src->initialized;
phylip.c:  dst->deltav = src->deltav;
phylip.c:      p->node_print_f(p);
phylip.c:      p = p->next;
phylip.c:  sprintf(progbuf, "%10p : %10p", (void *)n, (void *)n->back);
phylip.c:  if(n->back != NULL)
phylip.c:    sprintf(progbuf, " %3ld", n->back->index-1);
phylip.c:  sprintf(progbuf, " p->v : %lf", n->v);
phylip.c:  sprintf(progbuf, " p->iter : %d", n->iter);
phylip.c:  sprintf(progbuf, " init : %d", n->initialized);
phylip.c:    n->tip = true;
phylip.c:    n->tip = false;
phylip.c:    n->tip = true;
phylip.c:  n->index = index;
phylip.c:  n->v = initialv;
phylip.c:  n->iter = true;
phylip.c:  n->initialized = false;
phylip.c:  n->init = generic_node_init;
phylip.c:  n->free = generic_node_free;
phylip.c:  n->copy = generic_node_copy;
phylip.c:  n->reinit = generic_node_reinit;
phylip.c:  n->fork_print_f = generic_fork_print;
phylip.c:  n->node_print_f = generic_node_print;
phylip.c:  /*  re-initialize node */
phylip.c:  n->back = NULL;
phylip.c:  n->v = initialv;
phylip.c:  n->iter = true;
phylip.c:  n->initialized = false;
phylip.c:    don't change n->index !!!
phylip.c:  p->next = NULL;
phylip.c:  p->back = NULL;
phylip.c:  p->index = i;
phylip.c:  p->tip = false;
phylip.c:    if (p->tip) {
phylip.c:      exxit (-1);
phylip.c:    q = p->next;
phylip.c:        exxit (-1);
phylip.c:        q = q->next;
phylip.c:  invalidate_traverse(p->back);
phylip.c:{ /* Invalidates p's view and all views looking toward p from p->back
phylip.c:  if (p->tip)
phylip.c:  p->initialized = false;
phylip.c:  q = p->back;
phylip.c:  if ( q->tip ) return;
phylip.c:  /* Call ourselves on p->back's sibs */
phylip.c:  for ( q = q->next ; q != p->back ; q = q->next) {
phylip.c:   * problems. Not needed for regular program execution --
phylip.c:  /* For each fork node (spp..nonodes-1) */
phylip.c:  for ( index = spp; index < t->nonodes; index++ ) {
phylip.c:    p = t->nodep[index];
phylip.c:    p->initialized = false;
phylip.c:    for ( p = p->next; p != t->nodep[index]; p = p->next ) {
phylip.c:      p->initialized = false;
phylip.c:  p->initialized = false;
phylip.c:  p->back->initialized = false;
phylip.c:  if (p->tip)                            /* bail if at a tip */
phylip.c:  for (q = p->next; q != p; q = q->next) /* go to rest of fork circle */
phylip.c:    inittravall (t, q->back);            /* ... and on outwards from there */
phylip.c:{ /* traverse to set inward-looking booleans uninitialized on inserting
phylip.c:  if (p->tip)
phylip.c:  for ( sib_ptr  = p->next ; sib_ptr != p ; sib_ptr = sib_ptr->next) {
phylip.c:    sib_ptr->initialized = false;  /* set booleans looking back in */
phylip.c:    inittrav(t, sib_ptr->back);    /* further traverse from this circle */
phylip.c:  puts("\n\nERROR:  Unexpected End-of-File.\n");
phylip.c:  exxit(-1);
phylip.c:} /* EOF-error */
phylip.c:    if ( ini->node_new != NULL )
phylip.c:      functions.node_new = ini->node_new;
phylip.c:    if ( ini->tree_new != NULL )
phylip.c:      functions.tree_new = ini->tree_new;
phylip.c:          exxit(-1);
phylip.c:          exxit(-1);
phylip.c:   * considered read-only and not valid across calls to this function. */
phylip.c:    if ( fgets(b, size - (b - _fgetline_buffer), fp) == NULL )
phylip.c:    lastch = _fgetline_buffer + len - 1;
phylip.c:   * non-whitespace char, or '\0' if no such char exists. Aborts if EOF is
phylip.c:    exxit(-1);
phylip.c:{ /* random number generator -- slow but machine independent
phylip.c:     This is a multiplicative congruential 32-bit generator
phylip.c:     Coveyou-Macpherson and Lehmer tests, see Knuth ACP vol. 2
phylip.c:     We here implement it representing each integer in base-64
phylip.c:     notation -- i.e. as an array of 6 six-bit chunks   */
phylip.c:  mult[1] = 24;   /* -- they are its "digits" in a base-64    */
phylip.c:      sum += mult[j] * seed[i - j];
phylip.c:{ /* randomize input order of species -- randomly permute array enterorder */
phylip.c:    + randum(seed)+randum(seed)+randum(seed)+randum(seed)-6.0;
phylip.c:      printf("  Must be in range 1 - %ld.\n", spp);
phylip.c:    printf("Number of categories (1-%d)?\n", maxcategs);
phylip.c:      if ((scanned < 2 && i < (categs - 1)) ||
phylip.c:          (scanned < 1 && i == (categs - 1)))
phylip.c:      if ((scanned < 2 && i < (categs - 1)) ||
phylip.c:          (scanned < 1 && i == (categs - 1)))
phylip.c:    if (fabs(1.0 - (*probsum)) > 0.001) {
phylip.c:{ /* For use by initgammacat.  Get roots of m-th Generalized Laguerre
phylip.c:     polynomial, given roots of (m-1)-th, these are to be
phylip.c:          lower = lgroot[m-1][i-1];
phylip.c:        upper = lgroot[m-1][i];
phylip.c:        lower = lgroot[m-1][i-1];
phylip.c:        x = lgroot[m-1][m-1];
phylip.c:      while (upper-lower > 0.000000001) {
phylip.c:  double gln, glnm1, glnp1; /* L_n, L_(n-1), L_(n+1) */
phylip.c:      return 1.0 + b - x;
phylip.c:      gln = 1.0+b-x;
phylip.c:        glnp1 = ((2*(i-1)+b+1.0-x)*gln - (i-1+b)*glnm1)/i;
phylip.c:  alpha = alpha - 1.0;
phylip.c:    rate[i-1] = xi/(1.0+alpha);
phylip.c:    probcat[i-1] = x;
phylip.c:  /* seems to be unprecise for n>13 -> root finder does not converge*/
phylip.c:    xx = 2. * x * h2 - 2. * (i) * h1;
phylip.c:    hroot[start-1] = 0.0;
phylip.c:    hroot[ii] = halfroot(hermite, n, hroot[ii-1]+EPSILON, 1./n);
phylip.c:    hroot[start - z] = -hroot[ii];
phylip.c:     other-bound=startx+delta)
phylip.c:  gradient = (fl-fu)/(xl-xu);
phylip.c:      gradient = (fl-fu)/(xl-xu);
phylip.c:      xm = xl - fl / gradient;
phylip.c:      gradient = (fl-fu)/(xl-xu);
phylip.c:  numerator = exp(0.6931471805599 * ( n-1.) + logfac(n)) / (n*n);
phylip.c:    hr2 = hermite(n-1, hroot[i]);
phylip.c:        if (fabs(sum - 1.0) >= 1.0e-3)
phylip.c:  /* handle multi-data set option */
phylip.c:  /* handle multi-data set option by weights */
phylip.c:  if ((i - 1) % j != 0 || i <= 1)
phylip.c:    // initnode call with "bottom" --> first forknode of the group, normally goes in to nodep
phylip.c:      // initnode call with "nonbottom" --> remaining forknodes hooked up
phylip.c:      // initnode call with "hslength" --> no need to do anything here, typically just hooks it up
phylip.c:      exxit(-1);
phylip.c:      (*parens)--;         /* decrement count of open parentheses */
phylip.c:    // initnode call with "tip" --> typically copies str info above, but we just increase
phylip.c:  // initnode call with "iter" --> sets iter/initialv/initialized code -- nothing to do here
phylip.c:    // initnode call with "length" -> must read length using processlength
phylip.c:      // initnode call with "hsnolength" --> sets flag that not all items have length
phylip.c:    // initnode call with "treewt" --> can do something for cons.c things -- need to read
phylip.c:        exxit(-1);
phylip.c:        exxit(-1);
phylip.c:          exxit(-1);
phylip.c:      // initnode call with "unittrwt" --> can do something for cons.c things -- need to read
phylip.c:  /* read in user-defined tree to determine values of spp, maximum name length, nonodes */
phylip.c:       encounter an open-paren */
phylip.c:    exxit(-1);
phylip.c:  /* Re-set to where it pointed when the function was called */
phylip.c:   * (*spp * 2 - n)  in *nonodes */
phylip.c:    exxit(-1);
phylip.c:  *nonodes = *spp * 2 - n;
phylip.c:    exxit(-1);
phylip.c:  *nonodes = *spp * 2 - n;
phylip.c:    exxit(-1);
phylip.c:    exxit(-1);
phylip.c:    exxit(-1);
phylip.c:    exxit(-1);
phylip.c:      exxit(-1);
phylip.c:    exxit(-1);
phylip.c:  j = nmlngth + (chars + (chars - 1) / 10) / 2 - 5;
phylip.c:  if (j < nmlngth - 1)
phylip.c:    j = nmlngth - 1;
phylip.c:  fprintf(outfile, "----");
phylip.c:      sprintf(progbuf, "\n\nERROR:  End-of-Line or End-of-File");
phylip.c:      exxit(-1);
phylip.c:        exxit(-1);
phylip.c:    else {  /* once a tab character has been seen, blank-fill */
phylip.c:  for (i = 0; i < num_species-1; ++i)
phylip.c:        // RSGnote: This should print a name space-padded to 'nmlngth' chars,
phylip.c:        // with null chars following (to MAXNCH = 2 * nmlngth) to denote end-of-string.
phylip.c:    exxit(-1);
phylip.c:  /* input the character weights, 0-9 and A-Z for weights 0 - 35 */
phylip.c:      weight[i] = (long)ch - (long)('0');
phylip.c:      weight[i] = (long)ch - (long)'A' + 10;
phylip.c:      exxit(-1);
phylip.c:      weight[i] = ch - '0';
phylip.c:      sprintf(progbuf, "\n\nERROR:  Bad weight character: %c -- ", ch);
phylip.c:      exxit(-1);
phylip.c:      fprintf(filename, "%c", 'A'-10+(int)weight[i + inc]);
phylip.c:  /* input the categories, 1-9 */
phylip.c:      category[i] = ch - '0';
phylip.c:      sprintf(progbuf, " -- categories in %s are currently 1-%ld.\n", prog, categs);
phylip.c:      exxit(-1);
phylip.c:  for (i = 1; i <= nmlngth - 5; i++)
phylip.c:    putc(factor[i - 1], filename);
phylip.c:  upper = nextree - 1;
phylip.c:        done = (place[i - 1] != bestrees[(*pos) - 1].btree[i - 1]);
phylip.c:    below = (place[i - 1] <  bestrees[(*pos )- 1].btree[i - 1]);
phylip.c:      upper = (*pos) - 1;
phylip.c:  for (i = *nextree - 1; i >= pos; i--)
phylip.c:    memcpy(bestrees[i].btree, bestrees[i - 1].btree, spp * sizeof(long));
phylip.c:    bestrees[i].gloreange = bestrees[i - 1].gloreange;
phylip.c:    bestrees[i - 1].gloreange = false;
phylip.c:    bestrees[i].locreange = bestrees[i - 1].locreange;
phylip.c:    bestrees[i - 1].locreange = false;
phylip.c:    bestrees[i].collapse = bestrees[i - 1].collapse;
phylip.c:    bestrees[pos - 1].btree[i] = place[i];
phylip.c:  /*  bestrees[pos -1].gloreange = false; */
phylip.c:  bestrees[pos -1].collapse = false;
phylip.c:    for (i = 0; i < nextree - 1; i++)
phylip.c:    for (i = 0; i < nextree - 1; i++)
phylip.c:  return -1;
phylip.c:      j = i - gap;
phylip.c:        if (a[j - 1] > a[j + gap - 1]) {
phylip.c:          rtemp = a[j - 1];
phylip.c:          a[j - 1] = a[j + gap - 1];
phylip.c:          a[j + gap - 1] = rtemp;
phylip.c:          itemp = b[j - 1];
phylip.c:          b[j - 1] = b[j + gap - 1];
phylip.c:          b[j + gap - 1] = itemp;
phylip.c:        j -= gap;
phylip.c:    (*parens)--;
phylip.c:        exxit(-1);
phylip.c:        sprintf(progbuf, "unmatched parenthesis or non-bifurcated node.\n\n");
phylip.c:        exxit(-1);
phylip.c:        exxit(-1);
phylip.c:  exponentIsNegative = -1; // 3 states:  -1 = unassigned, 1 = true, 0 = false
phylip.c:  else if ('-' == *ch)
phylip.c:  digit = (long)(*ch - ordzero);
phylip.c:  while ( ((digit <= 9) && (digit >= 0)) || '.' == *ch || '-' == *ch
phylip.c:        exxit(-1);
phylip.c:      if (hasExponent && -1 == exponentIsNegative)
phylip.c:        exponentIsNegative = 0; // 3 states:  -1 = unassigned, 1 = true, 0 = false
phylip.c:        exxit(-1);
phylip.c:    else if ('-' == *ch)
phylip.c:      if (hasExponent && -1 == exponentIsNegative)
phylip.c:        exponentIsNegative = 1; // 3 states:  -1 = unassigned, 1 = true, 0 = false
phylip.c:        sprintf(progbuf, "\n\nERROR:  Branch length found with \'-\' in an unexpected place.\n\n");
phylip.c:        exxit(-1);
phylip.c:        exxit(-1);
phylip.c:    digit = (long)(*ch - ordzero);
phylip.c:    *valyew = -(*valyew);
phylip.c:      exxit(-1);
phylip.c:  (*bracket)--;
phylip.c:     to where it found it, not just re-winding it. */
phylip.c:  /* Re-set to where it pointed when the function was called */
phylip.c:  /* Then figure out if the first non-white character is a digit; if
phylip.c:      exxit(-1);
phylip.c:  exxit(-1);
phylip.c:  exxit(-1);
phylip.c:   * IMPORTANT -- does not change branch lengths. Other routines
phylip.c:  p->back = q;
phylip.c:  q->back = p;
phylip.c:    hookup(nodep[nodenum], nodep[local_nodenum]->next);
phylip.c:    hookup(nodep[nodenum], nodep[local_nodenum]->next->next);
phylip.c:    exxit(-1);
phylip.c:{ /* pre-compute space and allocate memory for nodep */
phylip.c:} /* allocate_nodep -plc */
phylip.c:     least MAXNCH bytes, but no effort is made to null-terminate
phylip.c:      found = (found && ((str[i] == nayme[n - 1][i]) ||
phylip.c:                         (((nayme[n - 1][i] == '_') && (str[i] == ' ')) ||
phylip.c:                          ((nayme[n - 1][i] == ' ') && (str[i] == '\0')))));
phylip.c:      *p = treenode[n - 1];
phylip.c:    exxit(-1);
phylip.c:  /* Recursive procedure adds nodes to user-defined tree
phylip.c:     This is the main (new) tree-reading procedure */
phylip.c:    if ( (maxnodes != -1) && (nodei > maxnodes)) {
phylip.c:      exxit(-1);
phylip.c:      (*initnode)(treep, &(*p)->next, len, nodei, ntips, parens, nonbottom, nodep, str, ch, treefile);
phylip.c:      r = (*p)->next;
phylip.c:      addelement(treep, &(*p)->next->back, (*p)->next, ch, parens, treefile,
phylip.c:      exxit(-1);
phylip.c:    (*p)->next = pfirst;
phylip.c:      (*parens)--;         /* decrement count of open parentheses */
phylip.c:  /* read in user-defined tree and set it up */
phylip.c:       encounter an open-paren */
phylip.c:    exxit(-1);
phylip.c:{ /* recursive procedure adds nodes to user-defined tree
phylip.c:     -- old-style bifurcating-only version used only by treeread2
phylip.c:    if ( maxnodes != -1 && current_loop_index > maxnodes) {
phylip.c:      exxit(-1);
phylip.c:      p = p->next;
phylip.c:      p->index = current_loop_index + 1;
phylip.c:      exxit(-1);
phylip.c:      (*parens)--;
phylip.c:    strncpy (p->nayme, str, len);
phylip.c:        exxit(-1);
phylip.c:        exxit(-1);
phylip.c:          exxit(-1);
phylip.c:    if (q->branchnum < pfirst->branchnum)
phylip.c:    pfirst->branchnum = q->branchnum;
phylip.c:    q->branchnum = pfirst->branchnum;
phylip.c:        q->oldlen = valyew / divisor;
phylip.c:        q->oldlen = initialv;
phylip.c:        q->v = valyew / divisor;
phylip.c:        q->back->v = q->v;
phylip.c:        q->iter = false;
phylip.c:        q->back->iter = false;
phylip.c:  /* read in user-defined tree and set it up
phylip.c:     -- old-style bifurcating-only version used only in Fitch, Kitsch,
phylip.c:       encounter an open-paren */
phylip.c:  (*root)->oldlen = 0.0;
phylip.c:    exxit(-1);
phylip.c:  if (t->root->back == NULL) {
phylip.c:    if (t->root->next->back->tip)
phylip.c:      t->root = t->root->next->next->back;
phylip.c:    else  t->root = t->root->next->back;
phylip.c:  if (t->root->next->back == NULL) {
phylip.c:    if (t->root->back->tip)
phylip.c:      t->root = t->root->next->next->back;
phylip.c:    else t->root = t->root->back;
phylip.c:  if (t->root->next->next->back == NULL) {
phylip.c:    if (t->root->back->tip)
phylip.c:      t->root = t->root->next->back;
phylip.c:    else t->root = t->root->back;
phylip.c:  unroot_r(t->root, t->nodep, nonodes);
phylip.c:  unroot_r(t->root->back, t->nodep, nonodes);
phylip.c:  newl = root->next->oldlen + root->next->next->oldlen;
phylip.c:  root->next->back->oldlen = newl;
phylip.c:  root->next->next->back->oldlen = newl;
phylip.c:  newl = root->next->v + root->next->next->v;
phylip.c:  root->next->back->v = newl;
phylip.c:  root->next->next->back->v = newl;
phylip.c:  root->next->back->back = root->next->next->back;
phylip.c:  root->next->next->back->back = root->next->back;
phylip.c:  while ( root->index != nonodes ) {
phylip.c:    tmpnode = nodep[ root->index ];
phylip.c:    nodep[root->index] = root;
phylip.c:    root->index++;
phylip.c:    root->next->index++;
phylip.c:    root->next->next->index++;
phylip.c:    nodep[root->index - 2] = tmpnode;
phylip.c:    tmpnode->index--;
phylip.c:    tmpnode->next->index--;
phylip.c:    tmpnode->next->next->index--;
phylip.c:  if ( p->tip) return;
phylip.c:  q = p->next;
phylip.c:    if (q->back == NULL)
phylip.c:    else unroot_r(q->back, nodep, nonodes);
phylip.c:    q = q->next;
phylip.c:  while ( !Slist_isempty(t->free_forks) )
phylip.c:    t->get_fork(t, 0); /* debug: effect is to discard fork; probably leaks */
phylip.c:  for ( j = t->spp; j < t->nonodes ; j++ ) {
phylip.c:    if (t->nodep[j] != NULL) {
phylip.c:      p = t->nodep[j];
phylip.c:      p->back = NULL;
phylip.c:         p->initialized = false;
phylip.c:      for ( nsibs = count_sibs(p); nsibs > 2; nsibs-- ) {
phylip.c:        q = p->next->next;
phylip.c:        t->release_forknode(t, p->next);
phylip.c:        p->next = q;
phylip.c:      p->initialized = false;
phylip.c:      p->next->initialized = false;
phylip.c:      p->next->next->initialized = false;
phylip.c:      p->back = NULL;
phylip.c:      p->next->back = NULL;
phylip.c:      p->next->next->back = NULL;
phylip.c:      t->release_fork(t, p);
phylip.c:  t->globrearrange = rooted_globrearrange;
phylip.c:  t->insert_ = (tree_insert_t)rooted_tree_insert_;
phylip.c:  t->re_move = rooted_tree_re_move;
phylip.c:  t->locrearrange = rooted_locrearrange;
phylip.c:  t->save_lr_nodes = rooted_tree_save_lr_nodes;
phylip.c:  t->restore_lr_nodes = rooted_tree_restore_lr_nodes;
phylip.c:  while ( !Slist_isempty(t->free_forks) )
phylip.c:    Slist_pop(t->free_forks);
phylip.c:  Slist_delete(t->free_forks);
phylip.c:  while ( !Slist_isempty(t->free_fork_nodes) )
phylip.c:    Slist_pop(t->free_fork_nodes);
phylip.c:  Slist_delete(t->free_fork_nodes);
phylip.c:    t->lrsaves[i]->free(&(t->lrsaves[i]));
phylip.c:  free(t->lrsaves);
phylip.c:  t->temp_p->free(&(t->temp_p));
phylip.c:  t->temp_q->free(&(t->temp_q));
phylip.c:  for ( i = 0 ; i < t->nonodes ; i++ ) {
phylip.c:    p = t->nodep[i];
phylip.c:      q = p->next;
phylip.c:        r = q->next;
phylip.c:        q->free(&q);
phylip.c:    p->free(&t->nodep[i]);
phylip.c:  free(t->nodep);
phylip.c:  if ( t->release_fork == NULL )
phylip.c:    t->release_fork = generic_tree_release_fork;
phylip.c:  if ( t->get_fork == NULL )
phylip.c:    t->get_fork = (tree_get_fork_t)generic_tree_get_fork;
phylip.c:  if ( t->release_forknode == NULL )
phylip.c:    t->release_forknode = generic_tree_release_forknode;
phylip.c:  t->spp = spp;
phylip.c:  t->nonodes = nonodes;
phylip.c:  t->nodep = Malloc(nonodes * sizeof(node *));
phylip.c:    t->nodep[i] = functions.node_new(true, i+1);
phylip.c:      p->next = q;
phylip.c:    p->next->next->next = p;
phylip.c:    t->nodep[i] = p;
phylip.c:  t->free_forks = Slist_new();      /* debug:  Now unnecessary? */
phylip.c:  t->free_fork_nodes = Slist_new();
phylip.c:  for ( i = nonodes - 1 ; i >= spp ; i-- ) {
phylip.c:    t->release_fork(t, t->nodep[i]);
phylip.c:  t->lrsaves = Malloc(NLRSAVES * sizeof(node*));
phylip.c:    t->lrsaves[i] = functions.node_new(false,0);
phylip.c:  t->temp_p = functions.node_new(false,0);
phylip.c:  t->temp_q = functions.node_new(false,0);
phylip.c:  t->addtraverse = (tree_addtraverse_t)generic_tree_addtraverse;
phylip.c:  t->addtraverse_1way = (tree_addtraverse_1way_t)generic_tree_addtraverse_1way;
phylip.c:  t->globrearrange = generic_globrearrange;
phylip.c:  t->free = generic_tree_free;
phylip.c:  t->copy = generic_tree_copy;
phylip.c:  t->smoothall = (tree_smoothall_t)no_op;
phylip.c:  t->root = t->nodep[0];
phylip.c:  t->root = NULL;
phylip.c:  t->score = UNDEFINED;
phylip.c:  t->locrearrange = generic_unrooted_locrearrange;
phylip.c:  t->save_lr_nodes = unrooted_tree_save_lr_nodes;
phylip.c:  t->restore_lr_nodes = unrooted_tree_restore_lr_nodes;
phylip.c:  t->save_traverses = generic_tree_save_traverses;
phylip.c:  t->restore_traverses = generic_tree_restore_traverses;
phylip.c:  t->nuview = generic_tree_nuview;
phylip.c:  t->evaluate = generic_tree_evaluate;
phylip.c:  t->insert_ = (tree_insert_t)generic_tree_insert_;
phylip.c:  t->get_forknode = generic_tree_get_forknode;
phylip.c:  t->re_move = generic_tree_re_move;
phylip.c:  t->try_insert_ = generic_tree_try_insert_;
phylip.c:  t->tree_print_f = generic_tree_print;
phylip.c:  t->do_branchl_on_insert_f = generic_do_branchl_on_insert;
phylip.c:  t->do_branchl_on_re_move_f = generic_do_branchl_on_re_move;
phylip.c:  t->tree_good_f = generic_tree_good;
phylip.c:  t->node_good_f = generic_node_good;
phylip.c:  t->fork_good_f = generic_fork_good;
phylip.c:  sprintf(progbuf, "-----------------------------------------------\n");
phylip.c:  sprintf(progbuf, "tree %p spp = %ld ; nonodes = %ld root = %p\n", (void *)t, t->spp, t->nonodes, (void *)t->root);
phylip.c:  for(nodeIndex=0;nodeIndex<t->nonodes;nodeIndex++)
phylip.c:    node * p = t->nodep[nodeIndex];
phylip.c:    sprintf(progbuf, "---\nnodep[%ld]: %p", nodeIndex, (void *)p);
phylip.c:    if(p->tip) {
phylip.c:    if(p == t->root) {
phylip.c:      p->fork_print_f(p);
phylip.c:  for(nodeIndex = 0; nodeIndex < t->nonodes; nodeIndex++)
phylip.c:    node * n = t->nodep[nodeIndex];
phylip.c:    if( n->tip )
phylip.c:      boolean thisNodeGood = t->node_good_f(t,n);
phylip.c:      boolean thisNodeGood = t->fork_good_f(t,n);
phylip.c:      if (p->back == NULL)
phylip.c:      boolean nodeGood = t->node_good_f(t,p);
phylip.c:      p = p->next;
phylip.c:  if ( n->back != NULL)
phylip.c:    boolean edgesEqual = (n->back->v == n->v);
phylip.c:  bestree = functions.tree_new(curtree->nonodes, curtree->spp);
phylip.c:  globtree = functions.tree_new(curtree->nonodes, curtree->spp);
phylip.c:  priortree = functions.tree_new(curtree->nonodes, curtree->spp);
phylip.c:  oldtree = functions.tree_new(curtree->nonodes, curtree->spp);
phylip.c:    bestyet = oldbestyet = curtree->score;
phylip.c:    curtree->copy(curtree, globtree);
phylip.c:    curtree->copy(curtree, oldtree);
phylip.c:    for ( i = 0 ; i < curtree->nonodes ; i++ ) {
phylip.c:      bestyet = curtree->score;
phylip.c:      sib_ptr  = curtree->nodep[i];
phylip.c:        if ((i - spp) % (( curtree->nonodes / 72 ) + 1 ) == 0 )
phylip.c:      if (sib_ptr->index == curtree->root->index)
phylip.c:      if ( sib_ptr->back == NULL )   /* this implies unused node */
phylip.c:      curtree->re_move(curtree, sib_ptr, &where, true);
phylip.c:      curtree->copy(curtree, priortree);
phylip.c:      succeeded = curtree->addtraverse(curtree, sib_ptr, curtree->root, true,
phylip.c:/* debug:  in above call --  "thorough"? "contin"? */
phylip.c:        if ( where != qwhere && bestyet > globtree->score)
phylip.c:          bestree->copy(bestree, globtree);
phylip.c:          curtree->insert_(curtree, sib_ptr, qwhere, true);
phylip.c:          curtree->smoothall(curtree, where);
phylip.c:          curtree->copy(curtree, globtree);
phylip.c:      oldtree->copy(oldtree, curtree);
phylip.c:      oldtree->copy(oldtree, bestree);
phylip.c:    globtree->copy(globtree, curtree);
phylip.c:    globtree->copy(globtree, bestree);
phylip.c:    succeeded = success && globtree->score > oldbestyet;
phylip.c:  bestree->free(bestree);
phylip.c:  priortree->free(priortree);
phylip.c:  globtree->free(globtree);
phylip.c:  oldtree->free(oldtree);
phylip.c:    for ( i = 0 ; i < curtree->nonodes ; i++)
phylip.c:      sprintf(progbuf, "-");
phylip.c:  bestree = functions.tree_new(curtree->nonodes, curtree->spp);
phylip.c:  globtree = functions.tree_new(curtree->nonodes, curtree->spp);
phylip.c:  priortree = functions.tree_new(curtree->nonodes, curtree->spp);
phylip.c:  oldtree = functions.tree_new(curtree->nonodes, curtree->spp);
phylip.c:    curtree->smoothall(curtree, curtree->root);
phylip.c:    bestyet = oldbestyet = curtree->score;
phylip.c:    curtree->copy(curtree, globtree);
phylip.c:    curtree->copy(curtree, oldtree);
phylip.c:    for ( i = 0 ; i < curtree->nonodes ; i++ ) {
phylip.c:      sib_ptr  = curtree->nodep[i];
phylip.c:      if ( sib_ptr->tip )
phylip.c:        if((i - spp) % (( curtree->nonodes / 72 ) + 1 ) == 0 )
phylip.c:        sib_ptr = curtree->nodep[i];
phylip.c:          sib_ptr = sib_ptr->next;
phylip.c:        if ( sib_ptr->back == NULL || sib_ptr->back->tip )
phylip.c:        curtree->re_move(curtree, removed, &where, true);
phylip.c:        curtree->smoothall(curtree, where);
phylip.c:        curtree->copy(curtree, priortree);
phylip.c:        if ( where->tip) {
phylip.c:          sib_ptr2 = where->back;
phylip.c:          succeeded = curtree->addtraverse(curtree, removed, sib_ptr2->back,
phylip.c:          sib_ptr2 = sib_ptr2->next;
phylip.c:          if (succeeded && qwhere != where && qwhere != where->back && bestyet > oldbestyet)
phylip.c:            curtree->insert_(curtree, removed, qwhere, true);
phylip.c:            curtree->smoothall(curtree, where);
phylip.c:            curtree->copy(curtree, globtree);
phylip.c:            globtree->copy(globtree, curtree);
phylip.c:          if ( qwhere && where != qwhere && bestyet > globtree->score)
phylip.c:            bestree->copy(bestree, globtree);
phylip.c:          oldtree->copy(oldtree, curtree);
phylip.c:          oldtree->copy(oldtree, bestree);
phylip.c:    globtree->copy(globtree, curtree);
phylip.c:    globtree->copy(globtree, bestree);
phylip.c:    globtree->copy(globtree, oldtree);
phylip.c:    succeeded = success && globtree->score > oldbestyet;
phylip.c:  bestree->free(bestree);
phylip.c:  priortree->free(priortree);
phylip.c:  globtree->free(globtree);
phylip.c:  oldtree->free(oldtree);
phylip.c:  succeeded = t->try_insert_(t, p, q->back, qwherein, bestyet, bestree,
phylip.c:  if (!q->tip && contin) {
phylip.c:    for ( sib_ptr = q->next ; q != sib_ptr ; sib_ptr = sib_ptr->next)
phylip.c:      succeeded = generic_tree_addtraverse_1way(t, p, sib_ptr->back,
phylip.c:  if (contin && !q->back->tip) {
phylip.c:    for ( sib_ptr = q->back->next ; sib_ptr != q->back ; sib_ptr = sib_ptr->next)
phylip.c:      succeeded = generic_tree_addtraverse_1way(t, p, sib_ptr->back,
phylip.c:  succeeded = t->try_insert_(t, p, q->back, qwherein, bestyet, bestree,
phylip.c:  if (!q->tip && contin) {       /* go to all branches leading beyond fork */
phylip.c:    for ( sib_ptr = q->next ; q != sib_ptr ; sib_ptr = sib_ptr->next)
phylip.c:      succeeded = generic_tree_addtraverse_1way(t, p, sib_ptr->back,
phylip.c:  r->back->copy(r->back, t->lrsaves[0]);
phylip.c:  r->back->next->copy(r->back->next, t->lrsaves[1]);
phylip.c:  r->back->next->next->copy(r->back->next->next, t->lrsaves[2]);
phylip.c:  p->next->copy(p->next, t->lrsaves[3]);
phylip.c:  p->next->next->copy(p->next->next, t->lrsaves[4]);
phylip.c:  t->rb = r->back;
phylip.c:  t->rnb = r->back->next->back;
phylip.c:  t->rnnb = r->back->next->next->back;
phylip.c:  t->lrsaves[0]->copy(t->lrsaves[0], t->rb);
phylip.c:  t->lrsaves[1]->copy(t->lrsaves[1], t->rnb->back);
phylip.c:  t->lrsaves[2]->copy(t->lrsaves[2], t->rnnb->back);
phylip.c:  t->lrsaves[3]->copy(t->lrsaves[3], p->next);
phylip.c:  t->lrsaves[4]->copy(t->lrsaves[4], p->next->next);
phylip.c:  t->rb->back->v = t->rb->v;
phylip.c:  t->rnb->back->v = t->rnb->v;
phylip.c:  t->rnnb->back->v = t->rnnb->v;
phylip.c:  p->next->back->v = p->next->v;
phylip.c:  p->next->next->back->v = p->next->next->v;
phylip.c:  inittrav(t, t->rb);      /*  to make sure initialized booleans are OK */
phylip.c:  inittrav(t, t->rnb);
phylip.c:  inittrav(t, t->rnnb);
phylip.c:  inittrav(t, p->next);
phylip.c:  inittrav(t, p->next->next);
phylip.c:  bestyet = t->evaluate(t, start, 0);
phylip.c:    succeeded = unrooted_tree_locrearrange_recurs(t, start->back, &bestyet, thorough, priortree, bestree);
phylip.c:   * the moved subtree, at p->back->next->next.
phylip.c:  if ((!p->tip) && !p->back->tip)   /* is this an interior branch? */
phylip.c:    r = p->back->next->next;
phylip.c:      t->save_lr_nodes(t, p, r);
phylip.c:      t->copy(t, bestree);
phylip.c:    t->re_move(t, r, &q, false);
phylip.c:      t->copy(t, priortree);
phylip.c:    t->addtraverse(t, r, p->next, false, qwhere, bestyet, bestree,
phylip.c:      t->addtraverse(t, r, p->next->next, false, qwhere, bestyet, bestree,
phylip.c:      bestree->copy(bestree, t);
phylip.c:        t->insert_(t, r, qwhere, true);
phylip.c:        t->restore_lr_nodes(t, p, r);
phylip.c:        t->score = *bestyet;
phylip.c:        t->insert_(t, r, qwhere, true);
phylip.c:        t->smoothall(t, r->back);
phylip.c:        *bestyet = t->evaluate(t, p,0);
phylip.c:      if (!p->tip) {
phylip.c:       succeeded = unrooted_tree_locrearrange_recurs(t, p->next->back, bestyet,
phylip.c:          succeeded = unrooted_tree_locrearrange_recurs(t, p->next->next->back,
phylip.c:  p->copy(p,t->temp_p);
phylip.c:  q->copy(q,t->temp_q);
phylip.c:  t->temp_p->copy(t->temp_p,p);
phylip.c:  t->temp_q->copy(t->temp_q,q);
phylip.c:  if ( p->back )
phylip.c:    p->back->v = p->v;
phylip.c:    inittrav(t, p->back);
phylip.c:  if ( q->back )
phylip.c:    q->back->v = q->v;
phylip.c:    inittrav(t, q->back);
phylip.c:  /* BUG.970 -- might be more correct to do all inittravs after ->v updates */
phylip.c:  // p->node_print_f(p);
phylip.c:  // q->node_print_f(q);
phylip.c:  p = t->nodep[p->index - 1];
phylip.c:  if (p == t->root)
phylip.c:  forknode = t->nodep[p->back->index - 1];
phylip.c:  if (forknode == t->root)
phylip.c:  oldlike = t->score;
phylip.c:  whereto = t->nodep[forknode->back->index - 1];
phylip.c:  t->save_lr_nodes(t, p, whereto);
phylip.c:  t->re_move(t, p, &where, false);
phylip.c:  t->insert_(t, p, whereto, false);
phylip.c:  like = t->evaluate(t, p, false);
phylip.c:  if (like - oldlike < LIKE_EPSILON) {
phylip.c:    t->restore_lr_nodes(t, p, whereto);
phylip.c:    t->score = oldlike;
phylip.c:    t->smoothall(t, t->root);
phylip.c:  if (p->tip)
phylip.c:  for ( q = p->next ; q != p && !(*success) ; q = q->next )
phylip.c:    rooted_repreorder(t, q->back, success);
phylip.c:  t->evaluate(t, start, 0); /* need to start of with a valid t->score */
phylip.c:  node* forknode = t->nodep[p->back->index - 1];
phylip.c:  p->back->copy(p->back, t->lrsaves[0]);
phylip.c:  whereto->copy(whereto, t->lrsaves[1]);
phylip.c:  t->rnb = forknode->back;
phylip.c:  if ( p == forknode->next->back ) {
phylip.c:    t->onleft = false;
phylip.c:    t->rnnb = forknode->next->next->back;
phylip.c:    t->onleft = true;
phylip.c:    t->rnnb = forknode->next->back;
phylip.c:  whereto->initialized = false;
phylip.c:  p->back->initialized = false;
phylip.c:  node* forknode = t->nodep[p->back->index - 1];
phylip.c:  if ( p == forknode->next->back ) {
phylip.c:    if (forknode->back != NULL)
phylip.c:      hookup( forknode->back, forknode->next->next->back);
phylip.c:      forknode->next->next->back->back = NULL;
phylip.c:      t->root = forknode->next->next->back;
phylip.c:    if ( forknode->back != NULL)
phylip.c:      hookup( forknode->back, forknode->next->back);
phylip.c:      forknode->next->back->back = NULL;
phylip.c:      t->root = forknode->next->back;
phylip.c:  hookup(forknode, t->rnb);
phylip.c:  if ( t->onleft ) {
phylip.c:    hookup(forknode->next->next, p);
phylip.c:    hookup(forknode->next, t->rnnb);
phylip.c:    hookup(forknode->next, p);
phylip.c:    hookup(forknode->next->next, t->rnnb);
phylip.c:  t->lrsaves[0]->copy(t->lrsaves[0], p->back);
phylip.c:  t->lrsaves[1]->copy(t->lrsaves[1], whereto);
phylip.c:  retval = (*oldstack)->data;
phylip.c:  newstack = (*oldstack)->next;
phylip.c:  newstack->data = newdata;
phylip.c:  newstack->next = oldstack;
phylip.c:  retval->next = generic_tree_get_forknode(t, k+1);
phylip.c:  retval->next->next = generic_tree_get_forknode(t, k+1);
phylip.c:  retval->next->next->next = retval;
phylip.c:  retval->initialized = false;
phylip.c:  retval->next->initialized = false;
phylip.c:  retval->next->next->initialized = false;
phylip.c:  retval->index = k+1;   /* debug:   necessary?  retval node is already assigned this index */
phylip.c:  p = p->next;
phylip.c:    p->index = k+1;
phylip.c:    p = p->next;
phylip.c:  t->nodep[k] = retval;
phylip.c:  m = n->index - 1;
phylip.c:  n = t->nodep[n->index  - 1];    /* the node in the circle pointed to by nodep */
phylip.c:    p = n->next;
phylip.c:    n->next = n->next->next;
phylip.c:    t->release_forknode(t, p);
phylip.c:  t->nodep[m] = NULL;   /* circle is released so nodep entry set to NULL */
phylip.c:  /*  calls the current nongeneric t->nuview on this branch, first
phylip.c:  if (!p->tip) {         /* is this end of the branch a fork? */
phylip.c:    for ( sib_ptr = p->next ; sib_ptr != p ; sib_ptr = sib_ptr->next ) {
phylip.c:      if ( sib_ptr->back && !sib_ptr->back->tip && !sib_ptr->back->initialized)
phylip.c:        generic_tree_nuview (t, sib_ptr->back);
phylip.c:        sib_ptr->initialized = false;
phylip.c:    t->nuview((tree*)t, p);   /* this actually calculates the view */
phylip.c:    p->initialized = false;
phylip.c:   * Updates views for p and p->back in preparation for evaluation specific
phylip.c:  if ( p->initialized == false && p->tip == false )
phylip.c:    t->nuview((tree*)t, p);
phylip.c:   * this is currently a contentless do-nothing function
phylip.c:  if ( Slist_isempty(t->free_fork_nodes) )
phylip.c:    p = Slist_pop(t->free_fork_nodes);
phylip.c:    p->init(p, 0, i);
phylip.c:    assert(p->next->next->next == p);
phylip.c:    if (q->back != NULL) { /* unless  q  is the root and nothing below */
phylip.c:      r = q->back;
phylip.c:      hookup(p->next, q);
phylip.c:      hookup(p->next->next, r);
phylip.c:      hookup(p->next, q);
phylip.c:      p->next->next->back = NULL;
phylip.c:    t->do_branchl_on_insert_f(t, p, q);
phylip.c:    assert( ! p->initialized );
phylip.c:    assert( ! p->next->initialized );
phylip.c:    assert( ! p->next->next->initialized );
phylip.c:    newnode = t->get_forknode(t, q->index);  /* debug: this used? correct? */
phylip.c:    newnode->next = q->next;
phylip.c:    q->next = newnode;
phylip.c:    assert( ! newnode->initialized );
phylip.c:    inittrav(t, p->back);
phylip.c: * If t->root is NULL, below is ignored, no fork is added, and newtip becomes
phylip.c:  if ( t->root == NULL ) {
phylip.c:  below = t->nodep[below->index - 1];
phylip.c:  newtip = t->nodep[newtip->index-1];
phylip.c:    below = t->nodep[below->index - 1];
phylip.c:    newfork = t->nodep[t->get_fork(t, k)->index - 1];
phylip.c:    newtip = t->nodep[newtip->index-1];
phylip.c:    if (below->back != NULL)
phylip.c:      below->back->back = newfork;
phylip.c:    newfork->back = below->back;
phylip.c:    below->back = newfork->next->next;
phylip.c:    newfork->next->next->back = below;
phylip.c:    newfork->next->back = newtip;
phylip.c:    newtip->back = newfork->next;
phylip.c:    if (t->root == below)
phylip.c:      t->root = newfork;
phylip.c:    newfork = t->get_forknode(t, below->index);
phylip.c:    newfork->next = below->next;
phylip.c:    below->next = newfork;
phylip.c:  if ( fork->back->tip && fork->tip ) {  /* debuug: does this ever occur? */
phylip.c:    fork->back = NULL;
phylip.c:    fork->back = NULL;
phylip.c:    for ( q = fork ; q->next != fork ; q = q->next)
phylip.c:    q->next = fork->next;   /* heal up circle */
phylip.c:    fork->next = NULL;
phylip.c:    if ( t->root == fork )
phylip.c:      t->root = q;
phylip.c:      for ( p = q->next ; p != q ; p = p->next )
phylip.c:    if (fork->next->back != NULL)  /* set where to the place it was next to */
phylip.c:      (*where) = fork->next->back;
phylip.c:      (*where) = fork->next->next->back;
phylip.c:    if (fork->next->back != NULL)    /* connect remaining neighbors to each other */
phylip.c:      fork->next->back->back = fork->next->next->back;
phylip.c:    if (fork->next->next->back != NULL)
phylip.c:      fork->next->next->back->back = fork->next->back;
phylip.c:    if ((fork->next == t->root) || (fork->next->next == t->root))  /* set root */
phylip.c:      t->root = *where;
phylip.c:    fork->next->back = NULL;
phylip.c:    fork->next->next->back = NULL;
phylip.c:    if (t->root->tip ) t->root = t->root->back;
phylip.c:    t->do_branchl_on_re_move_f(t, fork, *where);  /* adds up branch lengths */
phylip.c:      inittrav(t, (*where)->back);
phylip.c:  n->reinit(n);
phylip.c:  n->next = NULL;   // node_reinit(n) sets n->back to NULL
phylip.c:  Slist_push(t->free_fork_nodes, n);
phylip.c:  for (k = t->spp; k < t->nonodes; k++) {   /* look for an empty slot in  t */
phylip.c:    if (t->nodep[k] == NULL)
phylip.c:  t->insert_(t, p, q, t->doinit);
phylip.c:      t->copy(t, bestree);
phylip.c:  t->re_move(t, p, &dummy, false);
phylip.c:  /* build a simple three-tip tree with interior fork, by hooking
phylip.c:  node* p = t->nodep[ enterorder[0] - 1];
phylip.c:  node* q = t->nodep[ enterorder[1] - 1];
phylip.c:  node* r = t->nodep[ enterorder[2] - 1];
phylip.c:  newnode = t->get_fork(t, k);
phylip.c:  t->insert_(t, newnode, q, false);  /* connect all of them */
phylip.c:  t->root = p;
phylip.c:  if (item == NULL || item->back == NULL) {
phylip.c:    /* or even set t->root to NULL if item->back == NULL? */
phylip.c:  if ( count_sibs(item->back) != 2 ) {
phylip.c:    /* removing a node from a multi-furcation is the same in the rooted and
phylip.c:    item = t->nodep[item->index-1];
phylip.c:    fork = t->nodep[item->back->index - 1];
phylip.c:    if (item == fork->next->back)
phylip.c:      sib = fork->next->next->back;
phylip.c:      sib = fork->next->back;
phylip.c:    if (t->root == fork)
phylip.c:      t->root = sib;
phylip.c:    p = item->back->next->back; /* assumes bifurcation */
phylip.c:    q = item->back->next->next->back;
phylip.c:      p->back = q;
phylip.c:      q->back = p;
phylip.c:    t->release_fork(t, fork);
phylip.c:    item->back = NULL;
phylip.c:      inittrav(t, whereloc->back);
phylip.c:    enterorder[i - 1] = i;
phylip.c:  curtree->root = curtree->nodep[enterorder[0] - 1]->back;
phylip.c:    item = curtree->nodep[enterorder[i - 1] - 1];
phylip.c:    curtree->root = curtree->nodep[enterorder[0] - 1]->back;
phylip.c:    there = curtree->root;
phylip.c:    p = curtree->nodep[enterorder[i-1]-1];
phylip.c:    item = curtree->get_fork(curtree, k);
phylip.c:    curtree->addtraverse(curtree, item, curtree->root, true, there, &bestyet,
phylip.c:    curtree->insert_(curtree, item, there, false);
phylip.c:    curtree->locrearrange(curtree, curtree->nodep[enterorder[0]-1], false,
phylip.c:      writename(i - 1, 1, enterorder);
phylip.c:  while( !Slist_isempty(t->free_forks) ) {
phylip.c:    p = t->get_fork(t, 0);             /* debug: why this?  JF */
phylip.c:    t->release_forknode(t, p->next->next);
phylip.c:    t->release_forknode(t, p->next);
phylip.c:    t->release_forknode(t, p);
phylip.c:  for ( i = spp ; i < t->nonodes ; i++ )
phylip.c:    t->nodep[i] = NULL;
phylip.c:  for ( i = spp ; i < t->nonodes ; i++ ) {
phylip.c:    if ( t->nodep[i] == NULL ) {
phylip.c:      t->nodep[i] = t->get_forknode(t, i+1);
phylip.c:      t->nodep[i]->next = t->get_forknode(t, i+1);
phylip.c:      t->nodep[i]->next->next = t->get_forknode(t, i+1);
phylip.c:      t->nodep[i]->next->next->next = t->nodep[i];
phylip.c:      t->release_fork(t, t->nodep[i]);
phylip.c:    else if ( t->nodep[i]->back == NULL && t->nodep[i]->index != t->root->index )
phylip.c:      t->release_fork(t, t->nodep[i]);
phylip.c:  for ( i = spp ; i < t->nonodes ; i++ ) {
phylip.c:    if ( count_sibs(t->nodep[i]) > 2 ) {
phylip.c:      item = t->nodep[i]->back;
phylip.c:      t->re_move(t, item, &where, false);
phylip.c:      t->insert_(t, item, where, false);  /* debug: need to correct last argument */
phylip.c:      i--; /* do it again, just in case it still multifurcs */
phylip.c:/* ---------------------------------------------------------------- */
phylip.c:/*  printing-out-of-tree functions for debugging */
phylip.c:      sprintf(progbuf, "%c", nayme[enterorder[i] - 1][j]);
phylip.c:  long int nonodes = t->nonodes;
phylip.c:    qq = t->nodep[i];
phylip.c:      if (qq->back == NULL)
phylip.c:               qq->index);
phylip.c:               (void *)qq, qq->index, (void *)qq->back, qq->back->index);
phylip.c:        printf(" node: %p index:%ld  connects to nodes:", (void *)qq, qq->index);
phylip.c:          if (qq->back == NULL)
phylip.c:            printf(" %p index:%ld", (void *)qq->back, qq->back->index);
phylip.c:          qq = qq->next;
phylip.c:          malformed = (qq->next == qq);
phylip.c:            printf(" (->next is %p: same node)", qq->next);
phylip.c:        } while ((qq != pp) && (qq->index == pp->index) && !malformed);
phylip.c:    if (qq->next == NULL)
phylip.c:      sprintf(progbuf, " node: %p index:%ld ->next: %p         ->back: %p\n",
phylip.c:              (void *)qq, qq->index, (void *)qq->next, (void *)qq->back);
phylip.c:    else if(qq->back == NULL)
phylip.c:      sprintf(progbuf, " node: %p index:%ld ->next: %p ->back: %p\n",
phylip.c:              (void *)qq, qq->index, (void *)qq->next, (void *)qq->back);
phylip.c:      sprintf(progbuf, "                       next->next: %p ->back: %p\n",
phylip.c:              (void *)qq->next->next, (void *)qq->next->next->back);
phylip.c:      sprintf(progbuf, "                 next->next->next: %p ->back: %p\n",
phylip.c:             (void *)qq->next->next->next, (void *)qq->next->next->next->back);
phylip.c:      sprintf(progbuf, "           next->next->next->next: %p ->back: %p\n",
phylip.c:              (void *)qq->next->next->next->next,
phylip.c:              (void *)qq->next->next->next->next->back);
phylip.c:      sprintf(progbuf, " node: %p index:%ld ->next: %p ->back: %p\n",
phylip.c:              (void *)qq, qq->index, (void *)qq->next, (void *)qq->back);
phylip.c:      pp = qq->next;
phylip.c:        sprintf(progbuf, " node: %p index:%ld ->next: %p ->back: %p\n",
phylip.c:                (void *)pp, pp->index, (void *)pp->next, (void *)pp->back);
phylip.c:        pp = pp->next;
pmatrix.c:/* Version 4.0. (c) Copyright 1993-2013 by the University of Washington.
pmatrix.c:/* These functions are temporarily used for translating the fixed-width
pmatrix.c: * space-padded nayme array to an array of null-terminated char *. */
pmatrix.c:    for ( ch = names[i] + MAXNCH - 1; *ch == ' ' || *ch == '\0'; ch-- )
pmatrix.c:   * be printed. Otherwise, they must be null-terminated arrays of pointers to
pmatrix.c:   * null-terminalted character arrays.
pmatrix.c:  unsigned     *colwidth;               /* [0..spp-1] min width of each column */
pmatrix.c:  /* Enforce minimum of  nmlngth  ch for machine-readable output */
pmatrix.c:    cols--;
pmatrix.c:        for ( i = 0; i < colwidth[col] - fw; i++ )
pmatrix.c:          putc('-', fp);
pmatrix.c:        /* right-justify for non-machine-readable */
pmatrix.c:        /* left-justify for machine-readable */
pool.c:/* PHYLIP Version 4.0. (c) Copyright 1993-2013 by the University of Washington.
pool.c: * Pool allocator. Rapid management of fixed-sized chunks of memory.
pool.c:  pool->size       = size;
pool.c:  pool->block_size = block_size;
pool.c:  pool->blocks     = Slist_new();
pool.c:  pool->free       = Slist_new();
pool.c:  assert( Slist_get_length(pool->blocks) * pool->block_size == Slist_get_length(pool->free) );
pool.c:  while( !Slist_isempty(pool->free) )
pool.c:    Slist_pop(pool->free);
pool.c:  Slist_delete(&(pool->free));
pool.c:  while( !Slist_isempty(pool->blocks) )
pool.c:    free( Slist_pop(pool->blocks) );
pool.c:  Slist_delete(&(pool->blocks));
pool.c:  block = malloc(pool->block_size * pool->size);
pool.c:  Slist_push(pool->blocks, block);
pool.c:  block_end = block + pool->block_size * pool->size;
pool.c:  for ( ; block < block_end ; block += pool->size )
pool.c:    Slist_push(pool->free, block);
pool.c:  blocks = pool->blocks;
pool.c:  for( node = blocks->first; node != NULL; node = node->next )
pool.c:    if ( chunk >= node->data && chunk < node->data + (pool->block_size * pool->size))
pool.c:  assert( Slist_get_length(pool->blocks) == 3 );
pool.c:  assert( Slist_get_length(pool->free) == 1 );
pool.c:  for ( i = 13; i >=0; i-- )
pool.c:  for ( i = 12; i >= 0; i -= 2 )
prom_common.c:/* Version 4.0. (c) Copyright 2012-2013 by the University of Washington.
prom_common.c:{+0.00000000000000, -1.81721720738768, -1.87965834528616, -1.61403121885431,
prom_common.c: -1.53896608443751, -1.40486966367848, -1.30995061286931, -1.24668414819041,
prom_common.c: -1.17179756521289, -0.31033320987464, -0.34602837857034, -1.06031718484613,
prom_common.c: -0.99900602987105, -0.45576774888948, -0.86014403434677, -0.54569432735296,
prom_common.c: -0.76866956571861, -0.60593589295327, -0.65119724379348, -0.70249806480753};
prom_common.c: {-0.04445795120462, -0.01557336502860, -0.09314817363516, +0.04411372100382,
prom_common.c:  -0.00511178725134, +0.00188472427522, -0.02176250428454, -0.01330231089224,
prom_common.c:  +0.01004072641973, +0.02707838224285, -0.00785039050721, +0.02238829876349,
prom_common.c:  +0.00257470703483, -0.00510311699563, -0.01727154263346, +0.20074235330882,
prom_common.c:  -0.07236268502973, -0.00012690116016, -0.00215974664431, -0.01059243778174},
prom_common.c: {+0.09480046389131, +0.00082658405814, +0.01530023104155, -0.00639909042723,
prom_common.c:  +0.00160605602061, +0.00035896642912, +0.00199161318384, -0.00220482855717,
prom_common.c:  -0.00112601328033, +0.14840201765438, -0.00344295714983, -0.00123976286718,
prom_common.c:  -0.00439399942758, +0.00032478785709, -0.00104270266394, -0.02596605592109,
prom_common.c:  -0.05645800566901, +0.00022319903170, -0.00022792271829, -0.16133258048606},
prom_common.c: {-0.06924141195400, -0.01816245289173, -0.08104005811201, +0.08985697111009,
prom_common.c:  +0.00279659017898, +0.01083740322821, -0.06449599336038, +0.01794514261221,
prom_common.c:  -0.01748667848380, +0.00161859106290, +0.00622486432503, -0.05854130195643,
prom_common.c:  +0.15083728660504, +0.00030733757661, -0.00143739522173, -0.05295810171941},
prom_common.c: {-0.14637948915627, +0.02029296323583, +0.02615316895036, -0.10311538564943,
prom_common.c:  -0.00183412744544, -0.02589124656591, +0.11073673851935, +0.00848581728407,
prom_common.c:  +0.00106057791901, +0.05530240732939, -0.00031533506946, -0.03124002869407,
prom_common.c:  -0.01533984125301, -0.00288717337278, +0.00272787410643, +0.06300929916280,
prom_common.c:  +0.07920438311152, -0.00041335282410, -0.00011648873397, -0.03944076085434},
prom_common.c: {-0.05558229086909, +0.08935293782491, +0.04869509588770, +0.04856877988810,
prom_common.c:  -0.00253836047720, +0.07651693957635, -0.06342453535092, -0.00777376246014,
prom_common.c:  -0.08570270266807, +0.01943016473512, -0.00599516526932, -0.09157595008575,
prom_common.c:  -0.00397735155663, -0.00440093863690, -0.00232998056918, +0.02979967701162,
prom_common.c:  -0.00477299485901, -0.00144011795333, +0.01795114942404, -0.00080059359232},
prom_common.c: {+0.05807741644682, +0.14654292420341, -0.06724975334073, +0.02159062346633,
prom_common.c:  -0.00339085518294, -0.06829036785575, +0.03520631903157, -0.02766062718318,
prom_common.c:  +0.03485632707432, -0.02436836692465, -0.00397566003573, -0.10095488644404,
prom_common.c:  +0.02456887654357, +0.00381764117077, -0.00906261340247, -0.01043058066362,
prom_common.c:  +0.01651199513994, -0.00210417220821, -0.00872508520963, -0.01495915462580},
prom_common.c: {+0.02564617106907, +0.02960554611436, -0.00052356748770, +0.00989267817318,
prom_common.c:  -0.00044034172141, -0.02279910634723, -0.00363768356471, -0.01086345665971,
prom_common.c:  +0.01229721799572, +0.02633650142592, +0.06282966783922, -0.00734486499924,
prom_common.c:  -0.13863936313277, -0.00993891943390, -0.00655309682350, -0.00245191788287,
prom_common.c:  -0.02431633805559, -0.00068554031525, -0.00121383858869, +0.06280025239509},
prom_common.c: {+0.11362428251792, -0.02080375718488, -0.08802750967213, -0.06531316372189,
prom_common.c:  -0.00166626058292, +0.06846081717224, +0.07007301248407, -0.01713112936632,
prom_common.c:  -0.05900588794853, -0.04497159138485, +0.04222484636983, +0.00129043178508,
prom_common.c:  -0.01550337251561, -0.01553102163852, -0.04363429852047, +0.01600063777880,
prom_common.c:  +0.05787328925647, -0.00008265841118, +0.02870014572813, -0.02657681214523},
prom_common.c:  -0.00923516894192, +0.01209943150832, +0.02906782189141, +0.01992384905334,
prom_common.c:  +0.00197323568330, +0.00017531415423, -0.01796698381949, +0.01887083962858,
prom_common.c:  -0.00063335886734, -0.02365277334702, +0.01209445088200, +0.01308086447947,
prom_common.c:  +0.01286727242301, -0.11420358975688, -0.01886991700613, +0.00238338728588},
prom_common.c: {-0.01100105031759, -0.04250695864938, -0.02554356700969, -0.05473632078607,
prom_common.c:  +0.00725906469946, -0.03003724918191, -0.07051526125013, -0.06939439879112,
prom_common.c:  -0.00285883056088, +0.05334304124753, +0.12839241846919, -0.05883473754222,
prom_common.c:  +0.02424304967487, +0.09134510778469, -0.00226003347193, -0.01280041778462,
prom_common.c:  -0.00207988305627, -0.02957493909199, +0.05290385686789, +0.05465710875015},
prom_common.c: {-0.01421274522011, +0.02074863337778, -0.01006411985628, +0.03319995456446,
prom_common.c:  -0.00005371699269, -0.12266046460835, +0.02419847062899, -0.00441168706583,
prom_common.c:  -0.08299118738167, -0.00323230913482, +0.02954035119881, +0.09212856795583,
prom_common.c:  +0.00718635627257, -0.02706936115539, +0.04473173279913, -0.01274357634785,
prom_common.c:  -0.01395862740618, -0.00071538848681, +0.04767640012830, -0.00729728326990},
prom_common.c: {-0.03797680968123, +0.01280286509478, -0.08614616553187, -0.01781049963160,
prom_common.c:  -0.01529816709967, +0.06885987924922, -0.11719120476535, -0.00014333663810,
prom_common.c:  +0.00074336784254, +0.02893416406249, +0.07466151360134, -0.08182016471377,
prom_common.c:  -0.06581536577662, -0.00018195976501, +0.00167443595008, +0.09015415667825},
prom_common.c: {+0.03577726799591, -0.02139253448219, -0.01137813538175, -0.01954939202830,
prom_common.c:  -0.04028242801611, -0.01777500032351, -0.02106862264440, +0.00465199658293,
prom_common.c:  -0.02824805812709, +0.06618860061778, +0.08437791757537, -0.02533125946051,
prom_common.c:  +0.02806344654855, -0.06970805797879, +0.02328376968627, +0.00692992333282,
prom_common.c:  +0.02751392122018, +0.01148722812804, -0.11130404325078, +0.07776346000559},
prom_common.c: {-0.06014297925310, -0.00711674355952, -0.02424493472566, +0.00032464353156,
prom_common.c:  +0.03326534127710, -0.01558838623875, +0.13794237677194, -0.04292623056646,
prom_common.c:  +0.01375763233229, -0.11125153774789, +0.03510076081639, -0.04531670712549,
prom_common.c:  -0.06170413486351, -0.00182023682123, +0.05979891871679, -0.02551802851059},
prom_common.c: {-0.03515069991501, +0.02310847227710, +0.00474493548551, +0.02787717003457,
prom_common.c:  -0.12038329679812, +0.03178473522077, +0.04445111601130, -0.05334957493090,
prom_common.c:  +0.01290386678474, -0.00376064171612, +0.03996642737967, +0.04777677295520,
prom_common.c:  +0.00233689200639, +0.03917715404594, -0.01755598277531, -0.03389088626433,
prom_common.c:  -0.02180780263389, +0.00473402043911, +0.01964539477020, -0.01260807237680},
prom_common.c: {-0.04120428254254, +0.00062717164978, -0.01688703578637, +0.01685776910152,
prom_common.c:  -0.02073122710938, -0.06932247350110, +0.11696314241296, -0.00322523765776,
prom_common.c:  -0.01280515661402, +0.08717664266126, +0.06297225078802, -0.01290501780488,
prom_common.c:  -0.04693925076877, -0.00177653675449, -0.08407812137852, -0.08380714022487},
prom_common.c: {+0.03138655228534, -0.09052573757196, +0.00874202219428, +0.06060593729292,
prom_common.c:  -0.03426076652151, -0.04832468257386, +0.04735628794421, +0.14504653737383,
prom_common.c:  -0.01709111334001, -0.00278794215381, -0.03513813820550, -0.11690294831883,
prom_common.c:  -0.00836264902624, +0.03270980973180, -0.02587764129811, +0.01638786059073,
prom_common.c: {-0.04898722042023, -0.01460879656586, +0.00508708857036, +0.07730497806331,
prom_common.c:  +0.04252420017435, +0.00484232580349, +0.09861807969412, -0.05169447907187,
prom_common.c:  -0.00917820907880, +0.03679081047330, +0.04998537112655, +0.00769330211980,
prom_common.c:  +0.01805447683564, -0.00498723245027, -0.14148416183376, -0.05170281760262,
prom_common.c:  -0.03230723310784, -0.00032890672639, -0.02363523071957, +0.03801365471627},
prom_common.c: {-0.02047562162108, +0.06933781779590, -0.02101117884731, -0.06841945874842,
prom_common.c:  -0.00860967572716, -0.00886650271590, -0.07185241332269, +0.16703684361030,
prom_common.c:  -0.00635847581692, +0.00811478913823, +0.01847205842216, +0.06700967948643,
prom_common.c:  +0.00596607376199, +0.02318239240593, -0.10552958537847, -0.01980199747773,
prom_common.c:  -0.02003785382406, -0.00593392430159, -0.00965391033612, +0.00743094349652}};
prom_common.c:{0.0000001586972220, -1.8416770496147100, -1.6025046986139100, -1.5801012515121300,
prom_common.c: -1.4987794099715900, -1.3520794233801900, -1.3003469390479700, -1.2439503327631300,
prom_common.c: -1.1962574080244200, -1.1383730501367500, -1.1153278910708000, -0.4934843510654760,
prom_common.c: -0.5419014550215590, -0.9657997830826700, -0.6276075673757390, -0.6675927795018510,
prom_common.c: -0.6932641383465870, -0.8897872681859630, -0.8382698977371710, -0.8074694642446040};
prom_common.c: {0.0368263046116572, -0.0006728917107827, 0.0008590805287740, -0.0002764255356960,
prom_common.c:  -0.0004226254397134, 0.1805040629634510, -0.0272246813586204, 0.0005904606533477,
prom_common.c:  -0.0183743200073889, -0.0009194625608688, 0.0008173657533167, -0.0262629806302238,
prom_common.c:  0.0265738757209787, 0.0002176606241904, 0.0021315644838566, -0.1823229927207580},
prom_common.c: {-0.0194800075560895, 0.0012068088610652, -0.0008803318319596, -0.0016044273960017,
prom_common.c:  -0.0002938633803197, -0.0535796754602196, 0.0155163896648621, -0.0015006360762140,
prom_common.c:  0.0021601372013703, 0.0268513218744797, -0.1085292493742730, 0.0149753083138452,
prom_common.c:  0.1346457366717310, -0.0009371698759829, 0.0013501708044116, 0.0346352293103622,
prom_common.c:  -0.0276963770242276, 0.0003643142783940, 0.0002074817333067, -0.0174108903914110},
prom_common.c:  0.0002013267015151, -0.0227406863569852, 0.0098644845475047, 0.0064721276774396,
prom_common.c:  0.0001389408104210, -0.0473713878768274, -0.0086984445005797, 0.0026913674934634,
prom_common.c:  0.0283724052562196, 0.0001063665179457, 0.0027442574779383, -0.1875312134708470,
prom_common.c: {0.0037510125027265, 0.0107095920636885, 0.0147305410328404, -0.0112351252180332,
prom_common.c:  -0.0001500408626446, -0.1523450933729730, 0.0611532413339872, -0.0005496748939503,
prom_common.c:  0.0048714378736644, -0.0003826320053999, 0.0552010244407311, 0.0482555671001955,
prom_common.c:  -0.0461664995115847, -0.0021165008617978, -0.0004574454232187, 0.0233755883688949,
prom_common.c:  -0.0035484915422384, 0.0009090698422851, 0.0013840637687758, -0.0073895139302231},
prom_common.c: {-0.0111512564930024, 0.1025460064723080, 0.0396772456883791, -0.0298408501361294,
prom_common.c:  -0.0001656742634733, -0.0079876311843289, 0.0712644184507945, -0.0010780604625230,
prom_common.c:  -0.0035880882043592, 0.0021070399334252, 0.0016716329894279, -0.1810123023850110,
prom_common.c:  0.0015141703608724, -0.0032700852781804, 0.0035503782441679, 0.0118634302028026,
prom_common.c:  0.0044561606458028, -0.0001576678495964, 0.0023470722225751, -0.0027457045397157},
prom_common.c: {0.1474525743949170, -0.0054432538500293, 0.0853848892349828, -0.0137787746207348,
prom_common.c:  -0.0008274830358513, 0.0042248844582553, 0.0019556229305563, -0.0164191435175148,
prom_common.c:  -0.0024501858854849, 0.0120908948084233, -0.0381456105972653, 0.0101271614855119,
prom_common.c:  -0.0061945941321859, 0.0178841099895867, -0.0014577779202600, -0.0752120602555032,
prom_common.c:  -0.1426985695849920, 0.0002862275078983, -0.0081191734261838, 0.0313401149422531},
prom_common.c: {0.0542034611735289, -0.0078763926211829, 0.0060433542506096, 0.0033396210615510,
prom_common.c:  0.0013965072374079, 0.0067798903832256, -0.0135291136622509, -0.0089982442731848,
prom_common.c:  -0.0056744537593887, -0.0766524225176246, 0.1881210263933930, -0.0065875518675173,
prom_common.c:  0.0416627569300375, -0.0953804133524747, -0.0012559228448735, 0.0101622644292547,
prom_common.c:  -0.0304742453119050, 0.0011702318499737, 0.0454733434783982, -0.1119239362388150},
prom_common.c: {0.1069409037912470, 0.0805064400880297, -0.1127352030714600, 0.1001181253523260,
prom_common.c:  -0.0021480427488769, -0.0332884841459003, -0.0679837575848452, -0.0043812841356657,
prom_common.c:  0.0153418716846395, -0.0079441315103188, -0.0121766182046363, -0.0381127991037620,
prom_common.c:  -0.0036338726532673, 0.0195324059593791, -0.0020165963699984, -0.0061222685010268,
prom_common.c:  -0.0253761448771437, -0.0005246410999057, -0.0112205170502433, 0.0052248485517237},
prom_common.c: {-0.0325247648326262, 0.0238753651653669, 0.0203684886605797, 0.0295666232678825,
prom_common.c:  -0.0003946714764213, -0.0157242718469554, -0.0511737848084862, 0.0084725632040180,
prom_common.c:  -0.0167068828528921, 0.0686962159427527, -0.0659702890616198, -0.0014289912494271,
prom_common.c:  -0.0167000964093416, -0.1276689083678200, 0.0036575057830967, -0.0205958145531018,
prom_common.c: {-0.0463777468104402, 0.0394712148670596, 0.1118686750747160, 0.0440711686389031,
prom_common.c:  -0.0026076286506751, -0.0268454015202516, -0.1464943067133240, -0.0137514051835380,
prom_common.c:  -0.0094395514284145, -0.0144124844774228, 0.0249103379323744, -0.0071832157138676,
prom_common.c:  0.0316121324137152, -0.0011350177559026, -0.0349998884574440, -0.0302651879823361},
prom_common.c:  -0.0586974207121084, 0.0202001168873069, 0.0492204086749069, 0.1126593173463060,
prom_common.c:  0.0116620013776662, -0.0780333711712066, -0.1109786767320410, 0.0407775100936731,
prom_common.c:  -0.0205013161312652, -0.0653458585025237, 0.0347351829703865, 0.0304448983224773,
prom_common.c:  0.0068813748197884, -0.0189002309261882, -0.0334507528405279, -0.0668143558699485},
prom_common.c: {-0.0131548829657936, 0.0044244322828034, -0.0050639951827271, -0.0038668197633889,
prom_common.c:  -0.1536822386530220, 0.0026336969165336, 0.0021585651200470, -0.0459233839062969,
prom_common.c:  0.0117574347936383, 0.0373018612990383, 0.0024818527553328, -0.0133956606027299,
prom_common.c:  -0.0020457128424105, 0.0154178819990401, 0.0246524142683911, 0.0275363065682921},
prom_common.c: {-0.1542307272455030, 0.0364861558267547, -0.0090880407008181, 0.0531673937889863,
prom_common.c:  0.0099593861698250, -0.0013941794862563, 0.0294065511237513, -0.1151906949298290,
prom_common.c:  -0.0852991447389655, 0.0028699120202636, -0.0332087026659522, 0.0006811857297899},
prom_common.c: {0.0281300736924501, -0.0584072081898638, -0.0178386569847853, -0.0536470338171487,
prom_common.c:  -0.0186881656029960, -0.0240008730656106, -0.0541064820498883, 0.2217137098936020,
prom_common.c:  -0.0260500001542033, 0.0234505236798375, 0.0311127151218573, -0.0494139126682672,
prom_common.c:  0.0057093465049849, 0.0124937286655911, -0.0298322975915689, 0.0006520211333102,
prom_common.c:  -0.0061018680727128, -0.0007081999479528, -0.0060523759094034, 0.0215845995364623},
prom_common.c: {0.0295321046399105, -0.0088296411830544, -0.0065057049917325, -0.0053478115612781,
prom_common.c:  -0.0100646496794634, -0.0015473619084872, 0.0008539960632865, -0.0376381933046211,
prom_common.c:  -0.0328135588935604, 0.0672161874239480, 0.0667626853916552, -0.0026511651464901,
prom_common.c:  0.0140451514222062, -0.0544836996133137, 0.0427485157912094, 0.0097455780205802,
prom_common.c:  0.0177309072915667, -0.0828759701187452, -0.0729504795471370, 0.0670731961252313},
prom_common.c: {0.0082646581043963, -0.0319918630534466, -0.0188454445200422, -0.0374976353856606,
prom_common.c:  0.0037131290686848, -0.0132507796987883, -0.0306958830735725, -0.0044119395527308,
prom_common.c:  -0.0140786756619672, -0.0180512599925078, -0.0208243802903953, -0.0232202769398931,
prom_common.c:  -0.0063135878270273, 0.0110442171178168, 0.1824538048228460, -0.0006644614422758,
prom_common.c:  -0.0069909097436659, 0.0255407650654681, 0.0099119399501151, -0.0140911517070698},
prom_common.c: {0.0261344441524861, -0.0714454044548650, 0.0159436926233439, 0.0028462736216688,
prom_common.c:  -0.0044572637889080, -0.0089474834434532, -0.0177570282144517, -0.0153693244094452,
prom_common.c:  0.1160919467206400, 0.0304911481385036, 0.0047047513411774, -0.0456535116423972,
prom_common.c:  0.0004491494948617, -0.0767108879444462, -0.0012688533741441, 0.0192445965934123,
prom_common.c:  0.0202321954782039, 0.0281039933233607, -0.0590403018490048, 0.0364080426546883},
prom_common.c: {0.0115826306265004, 0.1340228176509380, -0.0236200652949049, -0.1284484655137340,
prom_common.c:  -0.0004742338006503, 0.0127617346949511, -0.0428560878860394, 0.0060030732454125,
prom_common.c:  0.0029940462557054, -0.0483434904493132, -0.0071713680727884, -0.0036840391887209,
prom_common.c:  0.0031454003250096, 0.0246243550241551, -0.0449551277644180, 0.0111449232769393},
prom_common.c: {0.0140356721886765, -0.0196518236826680, 0.0030517022326582, 0.0582672093364850,
prom_common.c:  -0.0000973895685457, 0.0021704767224292, 0.0341806268602705, -0.0152035987563018,
prom_common.c:  -0.0903198657739177, 0.0259623214586925, 0.0155832497882743, -0.0040543568451651,
prom_common.c:  0.0036477631918247, -0.0532892744763217, -0.0142569373662724, 0.0104500681408622,
prom_common.c:  0.0103483945857315, 0.0679534422398752, -0.0768068882938636, 0.0280289727046158}}
prom_common.c:/* dcmut version of PAM model from http://www.ebi.ac.uk/goldman-srv/dayhoff/ */
prom_common.c:{0, -1.93321786301018, -2.20904642493621, -1.74835983874903,
prom_common.c: -1.64854548332072, -1.54505559488222, -1.33859384676989, -1.29786201193594,
prom_common.c: -0.235548517495575, -0.266951066089808, -0.28965813670665, -1.10505826965282,
prom_common.c: -1.04323310568532, -0.430423720979904, -0.541719761016713, -0.879636093986914,
prom_common.c: -0.711249353378695, -0.725050487280602, -0.776855937389452, -0.808735559461343};
prom_common.c:   0.004895492884, 0.03815829405, -0.1087562465, 0.008691167141,
prom_common.c:   -0.0140554828, 0.001306404001, -0.001888411299, -0.006921303342,
prom_common.c:   0.0007655604228, 0.001583298443, 0.006879590446, -0.171806883,
prom_common.c:   0.04890917949, 0.0006700432804, 0.0002276237277, -0.01350591875},
prom_common.c:  {-0.01641514483, -0.007233933239, -0.1377830621, 0.1163201333,
prom_common.c:   -0.002305138017, 0.01557250366, -0.07455879489, -0.003225343503,
prom_common.c:   -0.001348402973, -0.001085733262, -0.003880514478, 0.0851493313,
prom_common.c:   -0.01163526615, -0.0001197903399, 0.002056153393, 0.0001536095643},
prom_common.c:  {0.009669278686, -0.006905863869, 0.101083544, 0.01179903104,
prom_common.c:   -0.003780967591, 0.05845105878, -0.09138357299, -0.02850503638,
prom_common.c:   -0.03233951408, 0.008708065876, -0.004700705411, -0.02053221579,
prom_common.c:   0.001165851398, -0.001366585849, -0.01317695074, 0.1199985703,
prom_common.c:   -0.1146346193, -0.0005953021314, -0.0004297615194, 0.007475695618},
prom_common.c:  {0.1722243502, -0.003737582995, -0.02964873222, -0.02050116381,
prom_common.c:   -0.0004530478465, -0.02460043205, 0.02280768412, -0.02127364909,
prom_common.c:   0.01570095258, 0.1027744285, -0.005330539586, 0.0179697651,
prom_common.c:   -0.002904077286, -0.007068126663, -0.0142869583, -0.01444241844,
prom_common.c:   -0.08218861544, 0.0002069181629, 0.001099671379, -0.1063484263},
prom_common.c:  {-0.1553433627, -0.001169168032, 0.02134785337, 0.0007602305436,
prom_common.c:   0.0001395330122, 0.03194992019, -0.01290252206, 0.03281720789,
prom_common.c:   -0.01311103735, 0.1177254769, -0.008008783885, -0.02375317548,
prom_common.c:   -0.002817809762, -0.008196682776, 0.01731267617, 0.01853526375,
prom_common.c:   0.08249908546, -2.788771776e-05, 0.001266182191, -0.09902299976},
prom_common.c:  {-0.03671080341, 0.0274168035, 0.04625877597, 0.07520706414,
prom_common.c:   -0.0001833803619, -0.1207833161, -0.006415807779, -0.005465629648,
prom_common.c:   0.02778273972, 0.007589688485, -0.02945266034, -0.03797542064,
prom_common.c:   0.07044042052, -0.002018573865, 0.01845277071, 0.006901513991,
prom_common.c:   -0.02430934639, -0.0005919635873, -0.001266962331, -0.01487591261},
prom_common.c:  {-0.03060317816, 0.01182361623, 0.04200270053, 0.05406235279,
prom_common.c:   -0.0003920498815, -0.09159709348, -0.009602690652, -0.00382944418,
prom_common.c:   -0.09308930025, -0.00102622863, 0.01477637127, 0.0009314065393,
prom_common.c:   -0.01860959472, -0.0005964703968, -0.002694284083, 0.02079767439},
prom_common.c:  {0.0195976494, -0.005104484936, 0.007406728707, 0.01236244954,
prom_common.c:   0.002764624354, 0.001273314658, -0.01335316035, 0.01105658671,
prom_common.c:   2.148773499e-05, -0.02692205639, 0.0118684991, 0.01212624708,
prom_common.c:   0.01127770094, -0.09842754796, -0.01942336432, 0.007105703151},
prom_common.c:  {-0.01819461888, -0.01509348507, -0.01297636935, -0.01996453439,
prom_common.c:   0.1715705905, -0.01601550692, -0.02122706144, -0.02854628494,
prom_common.c:   -0.009351082371, -0.001527995472, -0.010198224, -0.03609537551,
prom_common.c:   -0.003153182095, 0.02395980501, -0.01378664626, -0.005992611421,
prom_common.c:   -0.01176810875, 0.003132361603, 0.03018439539, -0.004956065656},
prom_common.c:  {-0.02733614784, -0.02258066705, -0.0153112506, -0.02475728664,
prom_common.c:   -0.04480525045, -0.01526640341, -0.02438517425, -0.04836914601,
prom_common.c:   -0.00635964824, 0.02263169831, 0.09794101931, -0.04004304158,
prom_common.c:   0.008464393478, 0.1185443142, -0.02239294163, -0.0281550321,
prom_common.c:   -0.01453581604, -0.0246742804, 0.0879619849, 0.02342867605},
prom_common.c:  {0.06483718238, 0.1260012082, -0.006496013283, 0.009914915531,
prom_common.c:   -0.004181603532, 0.0003493226286, 0.01408035752, -0.04881663016,
prom_common.c:   -0.03431167356, -0.01768005602, 0.02362447761, -0.1482364784,
prom_common.c:   -0.01289035619, -0.001778893279, -0.05240099752, 0.05536174567,
prom_common.c:   0.06782165352, -0.003548568717, 0.001125301173, -0.03277489363},
prom_common.c:  {0.06520296909, -0.0754802543, 0.03139281903, -0.03266449554,
prom_common.c:   -0.004485188002, -0.03389072036, -0.06163274338, -0.06484769882,
prom_common.c:   0.05722658289, -0.02824079619, 0.01544837349, 0.03909752708,
prom_common.c:   0.002029218884, 0.003151939572, -0.05471208363, 0.07962008342,
prom_common.c:   0.125916047, 0.0008696184937, -0.01086027514, -0.05314092355},
prom_common.c:   -0.01199617967, 0.01426278655, 0.02472521255, 0.03864795501,
prom_common.c:   0.02166224804, -0.04754243479, -0.1921545477, 0.03621321546,
prom_common.c:   -0.02120627881, 0.04928097895, 0.009396088815, 0.01748042052,
prom_common.c:   -6.173742851e-05, -0.003168033098, 0.07723565812, -0.08255529309},
prom_common.c:  {0.06710378668, -0.09441410284, -0.004801776989, 0.008830272165,
prom_common.c:   -0.01021645042, -0.02764365608, 0.004250361851, 0.1648777542,
prom_common.c:   -0.037446109, 0.004541057635, -0.0296980702, -0.1532325189,
prom_common.c:   -0.008940580901, 0.006998050812, 0.02338809379, 0.03175059182,
prom_common.c:  {0.01915943021, -0.05432967274, 0.01249342683, 0.06836622457,
prom_common.c:   0.002054462161, -0.01233535859, 0.07087282652, -0.08948637051,
prom_common.c:   -0.1245896013, -0.02204522882, 0.03791481736, 0.06557467874,
prom_common.c:   0.005529294156, -0.006296644235, 0.02144530752, 0.01664230081,
prom_common.c:   0.02647078439, 0.001737725271, 0.01414149877, -0.05331990116},
prom_common.c:  {0.0266659303, 0.0564142853, -0.0263767738, -0.08029726006,
prom_common.c:   -0.006059357163, -0.06317558457, -0.0911894019, 0.05401487057,
prom_common.c:   -0.08178072458, 0.01580699778, -0.05370550396, 0.09798653264,
prom_common.c:   0.03201877081, -0.00206161759, -0.005101423308, 0.03113033802},
prom_common.c:  {0.02980360751, -0.009513246268, -0.009543527165, -0.02190644172,
prom_common.c:   -0.006146440672, 0.01207009085, -0.0126989156, -0.1378266418,
prom_common.c:   0.0275235217, 0.00551720592, -0.03104791544, -0.07111701247,
prom_common.c:   -0.006081754489, -0.01337494521, 0.1783961085, 0.01453225059,
prom_common.c:  {-0.01433508581, 0.01258858175, -0.004294252236, -0.007146532854,
prom_common.c:   0.009541628809, 0.008040155729, -0.006857781832, 0.05584120066,
prom_common.c:   0.007749418365, -0.05867835844, 0.08008131283, -0.004877854222,
prom_common.c:   -0.0007128540743, 0.09489058424, 0.06421121962, 0.00271493526,
prom_common.c:   -0.03229944773, -0.001732026038, -0.08053448316, -0.1241903609},
prom_common.c:  {-0.009854113227, 0.01294129929, -0.00593064392, -0.03016833115,
prom_common.c:   -0.002018439732, -0.00792418722, -0.03372768732, 0.07828561288,
prom_common.c:   0.007722254639, -0.05067377561, 0.1191848621, 0.005059475202,
prom_common.c:   0.004762387166, -0.1029870175, 0.03537190114, 0.001089956203,
prom_common.c:   -0.02139157573, -0.001015245062, 0.08400521847, -0.08273195059}};
prom_common.c:  //  bestree2->free(bestree2);
prom_common.c:      free(((prot_node*)treenode[i])->x[j]);
prom_common.c:    free(((prot_node*)treenode[i])->x);
prom_common.c:          free(((prot_node*)p)->x[k]);
prom_common.c:        free(((prot_node*)p)->x);
prom_common.c:        p = p->next;
prom_common.c:     location[i-1] ends up as the position in the lexicographic order
prom_common.c:     others that are tied with it.  Otherwise location[i-1] is 0
prom_common.c:    alias[i - 1] = i;
prom_common.c:    ally[i - 1] = i;
prom_common.c:    aliasweight[i - 1] = weight[i - 1];
prom_common.c:    location[i - 1] = 0;
prom_common.c:    if (ally[i - 1] == i)
prom_common.c:    location[alias[i - 1] - 1] = i;
proml.c:/* Version 4.0. (c) Copyright 1993-2013 by the University of Washington.
proml.c:char aachar[26]="ARNDCQEGHILKMFPSTWYVBZX?*-";
proml.c:  t->evaluate = proml_tree_evaluate;
proml.c:  t->nuview = proml_tree_nuview;
proml.c:  ((ml_tree*)t)->makenewv = proml_tree_makenewv;
proml.c:    printf("  P    JTT, PMB or PAM probability model?  %s\n", usejtt ? "Jones-Taylor-Thornton" : usepmb ? "Henikoff/Tillier PMB" : "Dayhoff PAM");
proml.c:          printf("  user-defined HMM of rates\n");
proml.c:            printf("\nSitewise user-assigned categories:\n\n");
proml.c:        initgammacat(rcategs-1, alpha, rrate, probcat);
proml.c:        for (i = 0; i < rcategs-1; i++)
proml.c:          probcat[i] = probcat[i]*(1.0-invarfrac);
proml.c:        probcat[rcategs-1] = invarfrac;
proml.c:        rrate[rcategs-1] = 0.0;
proml.c:          (usejtt ? "Jones-Taylor-Thornton" :
proml.c:    headings(chars, "Sequences", "---------");
proml.c:    /* eat white space -- if the separator line has spaces on it*/
proml.c:        initname(i - 1);
proml.c:          if ((strchr("ABCDEFGHIKLMNPQRSTVWXYZ*?-", charstate)) == NULL)
proml.c:              printf("        The correct gap character is (-).\n");
proml.c:            exxit(-1);
proml.c:          inputSequences[i - 1][j - 1] = charstate;
proml.c:        exxit(-1);
proml.c:  for (i = 1; i <= ((chars - 1) / 60 + 1); i++)
proml.c:        putc(nayme[j - 1][k], outfile);
proml.c:      for (k = (i - 1) * 60 + 1; k <= l; k++)
proml.c:        if (j > 1 && inputSequences[j - 1][k - 1] == inputSequences[0][k - 1])
proml.c:          charstate = inputSequences[j - 1][k - 1];
proml.c:        memset(((prot_node*)treenode[i])->x[k][l], 0, sizeof(double)*20);
proml.c:        switch (y[i][j - 1])
proml.c:            ((prot_node*)treenode[i])->x[k][l][0] = 1.0;
proml.c:            ((prot_node*)treenode[i])->x[k][l][(long)arginine   - (long)alanine] = 1.0;
proml.c:            ((prot_node*)treenode[i])->x[k][l][(long)asparagine - (long)alanine] = 1.0;
proml.c:            ((prot_node*)treenode[i])->x[k][l][(long)aspartic   - (long)alanine] = 1.0;
proml.c:            ((prot_node*)treenode[i])->x[k][l][(long)cysteine   - (long)alanine] = 1.0;
proml.c:            ((prot_node*)treenode[i])->x[k][l][(long)glutamine  - (long)alanine] = 1.0;
proml.c:            ((prot_node*)treenode[i])->x[k][l][(long)glutamic   - (long)alanine] = 1.0;
proml.c:            ((prot_node*)treenode[i])->x[k][l][(long)glycine    - (long)alanine] = 1.0;
proml.c:            ((prot_node*)treenode[i])->x[k][l][(long)histidine  - (long)alanine] = 1.0;
proml.c:            ((prot_node*)treenode[i])->x[k][l][(long)isoleucine - (long)alanine] = 1.0;
proml.c:            ((prot_node*)treenode[i])->x[k][l][(long)leucine    - (long)alanine] = 1.0;
proml.c:            ((prot_node*)treenode[i])->x[k][l][(long)lysine     - (long)alanine] = 1.0;
proml.c:            ((prot_node*)treenode[i])->x[k][l][(long)methionine - (long)alanine] = 1.0;
proml.c:            ((prot_node*)treenode[i])->x[k][l][(long)phenylalanine - (long)alanine] = 1.0;
proml.c:            ((prot_node*)treenode[i])->x[k][l][(long)proline    - (long)alanine] = 1.0;
proml.c:            ((prot_node*)treenode[i])->x[k][l][(long)serine     - (long)alanine] = 1.0;
proml.c:            ((prot_node*)treenode[i])->x[k][l][(long)threonine  - (long)alanine] = 1.0;
proml.c:            ((prot_node*)treenode[i])->x[k][l][(long)tryptophan - (long)alanine] = 1.0;
proml.c:            ((prot_node*)treenode[i])->x[k][l][(long)tyrosine   - (long)alanine] = 1.0;
proml.c:            ((prot_node*)treenode[i])->x[k][l][(long)valine     - (long)alanine] = 1.0;
proml.c:            ((prot_node*)treenode[i])->x[k][l][(long)asparagine - (long)alanine] = 1.0;
proml.c:            ((prot_node*)treenode[i])->x[k][l][(long)aspartic   - (long)alanine] = 1.0;
proml.c:            ((prot_node*)treenode[i])->x[k][l][(long)glutamine  - (long)alanine] = 1.0;
proml.c:            ((prot_node*)treenode[i])->x[k][l][(long)glutamic   - (long)alanine] = 1.0;
proml.c:              ((prot_node*)treenode[i])->x[k][l][b] = 1.0;
proml.c:              ((prot_node*)treenode[i])->x[k][l][b] = 1.0;
proml.c:              ((prot_node*)treenode[i])->x[k][l][b] = 1.0;
proml.c:          case '-':                /* deletion event-absent data or aa */
proml.c:              ((prot_node*)treenode[i])->x[k][l][b] = 1.0;
proml.c:  prot_makevalues(rcategs, curtree->nodep, endsite, spp, inputSequences, alias);
proml.c:        * tbl[j][category[alias[i] - 1] - 1];
proml.c:    sib_ptr      = sib_ptr->next;
proml.c:    sib_back_ptr = sib_ptr->back;
proml.c:    lw = sib_back_ptr->v;
proml.c:    k = category[alias[i]-1] - 1;
proml.c:        sib_ptr      = sib_ptr->next;
proml.c:        sib_back_ptr = sib_ptr->back;
proml.c:          correction += ((ml_node*)sib_back_ptr)->underflows[i];
proml.c:        memcpy(x2, ((prot_node*)sib_back_ptr)->x[i][j], sizeof(psitelike));
proml.c:          if ( prot_xx[m] > maxx && sib_index == (num_sibs - 1))
proml.c:      memcpy(((prot_node*)p)->x[i][j], prot_xx, sizeof(psitelike));
proml.c:    ((ml_node*)p)->underflows[i] = 0;
proml.c:    ((ml_node*)p)->underflows[i] += correction;
proml.c:  p->initialized = true;
proml.c:  double prod4m, prod5m, prod6m;        /* elements of prod4-5 for */
proml.c:  q = p->back;
proml.c:    k = category[alias[i]-1] - 1;
proml.c:      memcpy(x1, ((prot_node*)p)->x[i][j], sizeof(psitelike));
proml.c:      memcpy(x2, ((prot_node*)q)->x[i][j], sizeof(psitelike));
proml.c:    lterm = log(sumterm) + ((ml_node*)p)->underflows[i] +
proml.c:      ((ml_node*)q)->underflows[i];
proml.c:    if ((ally[i] > 0) && (location[ally[i]-1] > 0))
proml.c:      lai = location[ally[i] - 1];
proml.c:      memcpy(clai, term[lai - 1], rcategs * sizeof(double));
proml.c:      memcpy(cslai, slopeterm[lai - 1], rcategs * sizeof(double));
proml.c:      memcpy(cclai, curveterm[lai - 1], rcategs * sizeof(double));
proml.c:        nulike[j]  = ((1.0 - lambda) * thelike[j]  + sumc) *  clai[j];
proml.c:        nuslope[j] = ((1.0 - lambda) * theslope[j] + sumcs) * clai[j]
proml.c:                   + ((1.0 - lambda) * thelike[j]  + sumc) *  cslai[j];
proml.c:        nucurve[j] = ((1.0 - lambda) * thecurve[j] + sumcc) * clai[j]
proml.c:             + 2.0 * ((1.0 - lambda) * theslope[j] + sumcs) * cslai[j]
proml.c:                   + ((1.0 - lambda) * thelike[j]  + sumc) *  cclai[j];
proml.c:        nulike[j]  = ((1.0 - lambda) * thelike[j]  + sumc);
proml.c:        nuslope[j] = ((1.0 - lambda) * theslope[j] + sumcs);
proml.c:        nucurve[j] = ((1.0 - lambda) * thecurve[j] + sumcc);
proml.c:  (*curve) = curve2 / sum2 - *slope * *slope;
proml.c:  /* Newton-Raphson algorithm improvement of a branch length */
proml.c:  q = p->back;
proml.c:  y = p->v;
proml.c:      y = y + slope/fabs(curve);        /* Newton-Raphson, forced uphill-wards */
proml.c:      if (fabs(y - yold) < epsilon)
proml.c:    done = fabs(y-yold) < 0.1*epsilon;
proml.c:  smoothed = (fabs(yold-yorig) < epsilon) && (yorig > 1000.0*epsilon);
proml.c:  p->v = yold;                          /* the last one that had better likelihood */
proml.c:  q->v = yold;
proml.c:  ((tree*)t)->score = oldlike;
proml.c:  q = p->back;
proml.c:  y = p->v;
proml.c:    k = category[alias[i]-1] - 1;
proml.c:      memcpy(x1, ((prot_node*)p)->x[i][j], sizeof(psitelike));
proml.c:      memcpy(x2, ((prot_node*)q)->x[i][j], sizeof(psitelike));
proml.c:    lterm = log(sumterm) + ((ml_node*)p)->underflows[i] +
proml.c:      ((ml_node*)q)->underflows[i];
proml.c:      l0gf[which - 1][i] = lterm;
proml.c:    if ((ally[i] > 0) && (location[ally[i]-1] > 0))
proml.c:      lai = location[ally[i] - 1];
proml.c:      memcpy(clai, contribution[lai - 1], rcategs * sizeof(double));
proml.c:        nulike[j] = ((1.0 - lambda) * like[j] + sumc) * clai[j];
proml.c:        nulike[j] = ((1.0 - lambda) * like[j] + sumc);
proml.c:  curtree->score = sum;
proml.c:    l0gl[which - 1] = sum;
proml.c:  if (p->tip)
proml.c:    p->xcoord = (long)(over * lengthsum + 0.5);
proml.c:    p->ycoord = (*tipy);
proml.c:    p->ymin = (*tipy);
proml.c:    p->ymax = (*tipy);
proml.c:  q = p->next;
proml.c:    xx = q->v;
proml.c:    proml_coordinates(q->back, lengthsum + xx, tipy, tipmax);
proml.c:    q = q->next;
proml.c:  } while ((p == curtree->root || p != q) && (p != curtree->root || p->next != q));
proml.c:  first = p->next->back;
proml.c:  while (q->next != p)
proml.c:    q = q->next;
proml.c:  last = q->back;
proml.c:  p->xcoord = (long)(over * lengthsum + 0.5);
proml.c:  if (p == curtree->root)
proml.c:    p->ycoord = p->next->next->back->ycoord;
proml.c:    p->ycoord = (first->ycoord + last->ycoord) / 2;
proml.c:  p->ymin = first->ymin;
proml.c:  p->ymax = last->ymax;
proml.c:  proml_coordinates(curtree->root, 0.0, &tipy, &tipmax);
proml.c:  for (i = 1; i <= (tipy - down); i++)
proml.c:  prot_slopecurv(p, p->v, &like, &slope, &curv);
proml.c:  tt = p->v;
proml.c:  p->v = epsilon;
proml.c:  p->back->v = epsilon;
proml.c:  aa = curtree->evaluate(curtree, p, false);
proml.c:  p->v = tt;
proml.c:  p->back->v = tt;
proml.c:  (*sumlr) = curtree->evaluate(curtree, p, false) - aa;
proml.c:  if (curv < -epsilon)
proml.c:    (*s1) = p->v + (-slope - sqrt(slope * slope -  3.841 * curv)) / curv;
proml.c:    (*s2) = p->v + (-slope + sqrt(slope * slope -  3.841 * curv)) / curv;
proml.c:    (*s1) = -1.0;
proml.c:    (*s2) = -1.0;
proml.c:  if (!p->tip && !p->initialized)
proml.c:    curtree->nuview(curtree, p);
proml.c:  if (!p->back->tip && !p->back->initialized)
proml.c:    curtree->nuview(curtree, p->back);
proml.c:  q = p->back;
proml.c:  if (q->tip)
proml.c:      putc(nayme[q->index-1][i], outfile);
proml.c:    fprintf(outfile, "  %4ld          ", q->index - spp);
proml.c:  if (p->tip)
proml.c:      putc(nayme[p->index-1][i], outfile);
proml.c:    fprintf(outfile, "%4ld      ", p->index - spp);
proml.c:  fprintf(outfile, "%15.5f", q->v);
proml.c:  if (!usertree || (usertree && !lngths) || p->iter || reusertree)
proml.c:  if (!p->tip)
proml.c:      sib_ptr = sib_ptr->next;
proml.c:      describe(sib_ptr->back);
proml.c:  if (p->tip)
proml.c:    putc(inputSequences[p->index-1][n], outfile);
proml.c:    if ((ally[n] == 0) || (location[ally[n]-1] == 0))
proml.c:      j = location[ally[n]-1] - 1;
proml.c:        f = ((prot_node*)p)->x[j][mx-1][i];
proml.c:        if (!p->tip)
proml.c:            q = q->next;
proml.c:            f *= ((prot_node*)q)->x[j][mx-1][i];
proml.c:          f = exp(log(f)/(num_sibs-1.0));
proml.c:        mx = mp[n][mx - 1];
proml.c:  if (p->tip)
proml.c:      putc(nayme[p->index-1][i], outfile);
proml.c:    fprintf(outfile, "%4ld      ", p->index - spp);
proml.c:  if (!p->tip)
proml.c:    for (q = p->next; q != p; q = q->next)
proml.c:      rectrav(q->back, m, n);
proml.c:  fprintf(outfile, "Ln Likelihood = %11.5f\n", curtree->score);
proml.c:  fprintf(outfile, " -------        ---            ------");
proml.c:    fprintf(outfile, "      ------- ---------- ------");
proml.c:    if (curtree->nodep[i])
proml.c:      num_sibs = count_sibs (curtree->nodep[i]);
proml.c:      sib_ptr  = curtree->nodep[i];
proml.c:        sib_ptr->initialized = false;
proml.c:        sib_ptr              = sib_ptr->next;
proml.c:  describe(curtree->root->back);
proml.c:  num_sibs = count_sibs(curtree->root);
proml.c:  sib_ptr  = curtree->root;
proml.c:    sib_ptr = sib_ptr->next;
proml.c:    describe(sib_ptr->back);
proml.c:  curtree->evaluate(curtree, curtree->root, false);
proml.c:    for (i = sites - 1; i >= 0; i--)
proml.c:        nulike[j] = (1.0 - lambda + lambda * probcat[j]) * like[j];
proml.c:            if (lambda * probcat[k - 1] * like[k - 1] > nulike[j])
proml.c:              nulike[j] = lambda * probcat[k - 1] * like[k - 1];
proml.c:        if ((ally[i] > 0) && (location[ally[i]-1] > 0))
proml.c:          nulike[j] *= contribution[location[ally[i] - 1] - 1][j];
proml.c:      if (probcat[i - 1] * like[i - 1] > mode)
proml.c:        mode = probcat[i - 1] * like[i - 1];
proml.c:      mx = mp[i - 1][mx - 1];
proml.c:    for (i = sites - 1; i >= 0; i--)
proml.c:        nulike[j] = (1.0 - lambda + lambda * probcat[j]) * like[j];
proml.c:            nulike[j] += lambda * probcat[k - 1] * like[k - 1];
proml.c:        if ((ally[i] > 0) && (location[ally[i]-1] > 0))
proml.c:          nulike[j] *= contribution[location[ally[i] - 1] - 1][j];
proml.c:        nulike[j] = (1.0 - lambda + lambda * probcat[j]) * like[j];
proml.c:            nulike[j] += lambda * probcat[k - 1] * like[k - 1];
proml.c:    for (i = 0; (i < 13) && (i < ((sites + (sites-1)/10 - 39) / 2)); i++)
proml.c:        k = sites - 1;
proml.c:      rectrav(curtree->root, i, k);
proml.c:      rectrav(curtree->root->back, i, k);
proml.c:      *p = treep->get_forknode(treep, nodei);
proml.c:      (*p)->index = nodei;
proml.c:      (*p)->tip = false;
proml.c:      ((ml_node*)*p)->allocx((ml_node*)*p, endsite, rcategs);
proml.c:      treep->nodep[(*p)->index - 1] = (*p);
proml.c:      *p = treep->get_forknode(treep, nodei);
proml.c:      ((ml_node*)*p)->allocx((ml_node*)*p, endsite, rcategs);
proml.c:      (*p)->index = nodei;
proml.c:      match_names_to_data(str, treep->nodep, p, spp);
proml.c:      (*p)->initialized = false;
proml.c:      (*p)->v = initialv;
proml.c:      (*p)->iter = true;
proml.c:      if ((*p)->back != NULL)
proml.c:        (*p)->back->iter = true;
proml.c:        (*p)->back->v = initialv;
proml.c:        (*p)->back->initialized = false;
proml.c:      (*p)->v = valyew / divisor;
proml.c:      (*p)->iter = false;
proml.c:      if ((*p)->back != NULL)
proml.c:        (*p)->back->v = (*p)->v;
proml.c:        (*p)->back->iter = false;
proml.c:  if (p->tip)
proml.c:      if (nayme[p->index-1][i - 1] != ' ')
proml.c:      c = nayme[p->index-1][i];
proml.c:    q = p->next;
proml.c:      dnaml_treeout(q->back);
proml.c:      q = q->next;
proml.c:    } while ((p == curtree->root || p != q) && (p != curtree->root || p->next != q));
proml.c:  x = p->v;
proml.c:    w = (long)(0.43429448222 * log(-x)) + 1;
proml.c:  if (p == curtree->root)
proml.c:  node *r = t->root;
proml.c:    while ( q->next != r )
proml.c:      q = q->next;
proml.c:    q->next = r->next;
proml.c:    t->release_forknode(t, r);
proml.c:    t->nodep[spp] = q;
proml.c:    assert(r->back == NULL);       // RSGnote: This assumes the FORKRING being
proml.c:    newl = r->next->oldlen + r->next->next->oldlen;
proml.c:    r->next->back->oldlen = newl;
proml.c:    r->next->next->back->oldlen = newl;
proml.c:    newl = r->next->v + r->next->next->v;
proml.c:    r->next->back->v = newl;
proml.c:    r->next->next->back->v = newl;
proml.c:    r->next->back->back = r->next->next->back;
proml.c:    r->next->next->back->back = r->next->back;
proml.c:    t->release_fork(t, r);
proml.c:  t->root = t->nodep[0]->back;          // Reset ROOT; moved from line just after call to PROML_REROOT.
proml.c:    /* Open in binary: ftell() is broken for UNIX line-endings under WIN32 */
proml.c:      fprintf(outfile, "User-defined tree");
proml.c:    /* This taken out of tree read, used to be [spp-1], but referring
proml.c:       to [0] produces output identical to what the pre-modified dnaml
proml.c:         since multiple trees require re-initialization */
proml.c:      treeread(curtree, intree, &curtree->root, dummy_treenode, &goteof, &dummy_first, &nextnode, &haslengths, initpromlnode, false, nonodes2);
proml.c:        printf ("\tNumber of trees actually in file:\t%ld.\n\n", which - 1);
proml.c:        exxit (-1);
proml.c:        curtree->root = curtree->nodep[outgrno - 1]->back;
proml.c:      if ( reusertree && ( which == 1 || curtree->score > bestree2->score ))
proml.c:        curtree->copy(curtree, bestree2);
proml.c:        bestree2->copy(bestree2, curtree);
proml.c:        curtree->root = curtree->nodep[0]->back;
proml.c:          curtree->root = curtree->nodep[outgrno - 1]->back;
proml.c:        dnaml_treeout(curtree->root);
proml.c:        prot_freex_notip(nextnode, curtree->nodep);
proml.c:      standev2(numtrees, maxwhich, 0, endsite-1, maxlogl, l0gl, l0gf, aliasweight, seed);
proml.c:      enterorder[i - 1] = i;
proml.c:    curtree->root = curtree->nodep[enterorder[0] - 1]->back;
proml.c:        curtree->copy(curtree, priortree);
proml.c:      curtree->addtraverse(curtree, curtree->nodep[enterorder[nextsp - 1] - 1], curtree->root, true, &qwhere, &bestyet, bestree, priortree, smoothit, NULL);
proml.c:        bestree->copy(bestree, curtree);
proml.c:        curtree->insert_(curtree, curtree->nodep[enterorder[nextsp - 1] - 1], qwhere, true, false);
proml.c:        curtree->copy(curtree, bestree);
proml.c:        bestyet = curtree->score;
proml.c:        writename(nextsp - 1, 1, enterorder);
proml.c:        curtree->globrearrange(curtree, progress, smoothit);
proml.c:        curtree->locrearrange(curtree, curtree->nodep[enterorder[0] - 1], smoothit, priortree, bestree) ;
proml.c:        curtree->smoothall(curtree, curtree->root);
proml.c:        bestyet = curtree->score;
proml.c:    curtree->copy(curtree, bestree);
proml.c:        bestree->copy(bestree, bestree2);
proml.c:        if (bestree2->score < bestree->score)
proml.c:          bestree->copy(bestree, bestree2);
proml.c:        bestree2->copy(bestree2, curtree);
proml.c:      curtree->root = curtree->nodep[outgrno - 1]->back;
proml.c:        dnaml_treeout(curtree->root);
proml.c:  prom_free_all_x(nonodes2, curtree->nodep);
proml.c:    prom_free_all_x(nonodes2, bestree->nodep);
proml.c:    prom_free_all_x(nonodes2, priortree->nodep);
proml.c:      prom_free_all_x(nonodes2, bestree2->nodep);
proml.c:    // User-defined HMM of rates
proml.c:      initgammacat(rcategs-1, alpha, rrate, probcat);
proml.c:      for (i = 0; i < rcategs-1; i++)
proml.c:        probcat[i] = probcat[i]*(1.0-invarfrac);
proml.c:      probcat[rcategs-1] = invarfrac;
proml.c:      rrate[rcategs-1] = 0.0;
promlk.c:/* Version 4.0. (c) Copyright 1986-2013 by the University of Washington
promlk.c:  numtrees = number of user-defined trees */
promlk.c:char aachar[26]="ARNDCQEGHILKMFPSTWYVBZX?*-";
promlk.c:  t->insert_  = mlk_tree_insert_;
promlk.c:  t->try_insert_ = ml_tree_try_insert_;
promlk.c:  t->re_move = mlk_tree_re_move;
promlk.c:  t->evaluate = promlk_tree_evaluate;
promlk.c:  t->globrearrange = rooted_globrearrange;
promlk.c:  t->locrearrange = rooted_locrearrange;
promlk.c:  ((ml_tree*)t)->makenewv = mlk_tree_makenewv;
promlk.c:  t->nuview = promlk_tree_nuview;
promlk.c:  t->save_lr_nodes = rooted_tree_save_lr_nodes;
promlk.c:  t->restore_lr_nodes = rooted_tree_restore_lr_nodes;
promlk.c:           usejtt ? "Jones-Taylor-Thornton" :
promlk.c:          printf("  user-defined HMM of rates\n");
promlk.c:            printf("\nSitewise user-assigned categories:\n\n");
promlk.c:        initgammacat(rcategs-1, alpha, rrate, probcat);
promlk.c:        for (i = 0; i < rcategs-1; i++)
promlk.c:          probcat[i] = probcat[i]*(1.0-invarfrac);
promlk.c:        probcat[rcategs-1] = invarfrac;
promlk.c:        rrate[rcategs-1] = 0.0;
promlk.c:          (usejtt ? "Jones-Taylor-Thornton" :
promlk.c:    headings(chars, "Sequences", "---------");
promlk.c:    /* eat white space -- if the separator line has spaces on it*/
promlk.c:        initname(i - 1);
promlk.c:          if ((strchr("ABCDEFGHIKLMNPQRSTVWXYZ*?-", charstate)) == NULL)
promlk.c:              printf("        The correct gap character is (-).\n");
promlk.c:            exxit(-1);
promlk.c:          inputSequences[i - 1][j - 1] = charstate;
promlk.c:        exxit(-1);
promlk.c:  for (i = 1; i <= ((chars - 1) / 60 + 1); i++)
promlk.c:        putc(nayme[j - 1][k], outfile);
promlk.c:      for (k = (i - 1) * 60 + 1; k <= l; k++)
promlk.c:        if (j > 1 && inputSequences[j - 1][k - 1] == inputSequences[0][k - 1])
promlk.c:          charstate = inputSequences[j - 1][k - 1];
promlk.c:        memset(((prot_node*)treenode[i])->x[k][l], 0, sizeof(double)*20);
promlk.c:        switch (y[i][j - 1])
promlk.c:          ((prot_node*)treenode[i])->x[k][l][0] = 1.0;
promlk.c:          ((prot_node*)treenode[i])->x[k][l][(long)arginine   - (long)alanine] = 1.0;
promlk.c:          ((prot_node*)treenode[i])->x[k][l][(long)asparagine - (long)alanine] = 1.0;
promlk.c:          ((prot_node*)treenode[i])->x[k][l][(long)aspartic   - (long)alanine] = 1.0;
promlk.c:          ((prot_node*)treenode[i])->x[k][l][(long)cysteine   - (long)alanine] = 1.0;
promlk.c:          ((prot_node*)treenode[i])->x[k][l][(long)glutamine  - (long)alanine] = 1.0;
promlk.c:          ((prot_node*)treenode[i])->x[k][l][(long)glutamic   - (long)alanine] = 1.0;
promlk.c:          ((prot_node*)treenode[i])->x[k][l][(long)glycine    - (long)alanine] = 1.0;
promlk.c:          ((prot_node*)treenode[i])->x[k][l][(long)histidine  - (long)alanine] = 1.0;
promlk.c:          ((prot_node*)treenode[i])->x[k][l][(long)isoleucine - (long)alanine] = 1.0;
promlk.c:          ((prot_node*)treenode[i])->x[k][l][(long)leucine    - (long)alanine] = 1.0;
promlk.c:          ((prot_node*)treenode[i])->x[k][l][(long)lysine     - (long)alanine] = 1.0;
promlk.c:          ((prot_node*)treenode[i])->x[k][l][(long)methionine - (long)alanine] = 1.0;
promlk.c:          ((prot_node*)treenode[i])->x[k][l][(long)phenylalanine - (long)alanine] = 1.0;
promlk.c:          ((prot_node*)treenode[i])->x[k][l][(long)proline    - (long)alanine] = 1.0;
promlk.c:          ((prot_node*)treenode[i])->x[k][l][(long)serine     - (long)alanine] = 1.0;
promlk.c:          ((prot_node*)treenode[i])->x[k][l][(long)threonine  - (long)alanine] = 1.0;
promlk.c:          ((prot_node*)treenode[i])->x[k][l][(long)tryptophan - (long)alanine] = 1.0;
promlk.c:          ((prot_node*)treenode[i])->x[k][l][(long)tyrosine   - (long)alanine] = 1.0;
promlk.c:          ((prot_node*)treenode[i])->x[k][l][(long)valine     - (long)alanine] = 1.0;
promlk.c:          ((prot_node*)treenode[i])->x[k][l][(long)asparagine - (long)alanine] = 1.0;
promlk.c:          ((prot_node*)treenode[i])->x[k][l][(long)aspartic   - (long)alanine] = 1.0;
promlk.c:          ((prot_node*)treenode[i])->x[k][l][(long)glutamine  - (long)alanine] = 1.0;
promlk.c:          ((prot_node*)treenode[i])->x[k][l][(long)glutamic   - (long)alanine] = 1.0;
promlk.c:            ((prot_node*)treenode[i])->x[k][l][b] = 1.0;
promlk.c:            ((prot_node*)treenode[i])->x[k][l][b] = 1.0;
promlk.c:            ((prot_node*)treenode[i])->x[k][l][b] = 1.0;
promlk.c:        case '-':               /* deletion event-absent data or aa */
promlk.c:            ((prot_node*)treenode[i])->x[k][l][b] = 1.0;
promlk.c:  prot_makevalues(rcategs, curtree->nodep, endsite, spp, inputSequences, alias);
promlk.c:        * tbl[j][category[alias[i] - 1] - 1];
promlk.c:    sib_ptr      = sib_ptr->next;
promlk.c:    sib_back_ptr = sib_ptr->back;
promlk.c:      if (!sib_back_ptr->tip && !sib_back_ptr->initialized)
promlk.c:        t->nuview(t, sib_back_ptr);
promlk.c:    sib_ptr      = sib_ptr->next;
promlk.c:    sib_back_ptr = sib_ptr->back;
promlk.c:      lw =  fabs( get_tyme(p) - get_tyme(sib_back_ptr) );
promlk.c:    k = category[alias[i]-1] - 1;
promlk.c:        sib_ptr      = sib_ptr->next;
promlk.c:        sib_back_ptr = sib_ptr->back;
promlk.c:          memcpy(x2, ((prot_node*)sib_back_ptr)->x[i][j], sizeof(psitelike));
promlk.c:            correction += ((ml_node*)sib_back_ptr)->underflows[i];
promlk.c:          if ( prot_xx[m] > maxx && sib_index == (num_sibs - 1 ))
promlk.c:      memcpy(((prot_node*)p)->x[i][j], prot_xx, sizeof(psitelike));
promlk.c:    ((ml_node*)p)->underflows[i] = 0;
promlk.c:    ((ml_node*)p)->underflows[i] += correction;
promlk.c:  p->initialized = true;
promlk.c:  if (p == curtree->root && (count_sibs(p) == 2))
promlk.c:    r = p->next->back;
promlk.c:    q = p->next->next->back;
promlk.c:    y = get_tyme(r) + get_tyme(q) - 2 * get_tyme(p);
promlk.c:    if (!r->tip && !r->initialized) t->nuview(t, r);
promlk.c:    if (!q->tip && !q->initialized) t->nuview(t, q);
promlk.c:  else if (p == curtree->root)
promlk.c:    /* the next two lines copy tyme and x to p->next.  Normally they are
promlk.c:    set_tyme(p->next, get_tyme(p));
promlk.c:    t->nuview(t, p->next);
promlk.c:    r = p->next;
promlk.c:    q = p->next->back;
promlk.c:    y = fabs( get_tyme(p->next) - get_tyme(q) );
promlk.c:    q = p->back;
promlk.c:    if (!r->tip && !r->initialized) t->nuview(t, r);
promlk.c:    if (!q->tip && !q->initialized) t->nuview(t, q);
promlk.c:    y = fabs( get_tyme(r) - get_tyme(q) );
promlk.c:    k = category[alias[i]-1] - 1;
promlk.c:      memcpy(x1, ((prot_node*)r)->x[i][j], sizeof(psitelike));
promlk.c:      memcpy(x2, ((prot_node*)q)->x[i][j], sizeof(psitelike));
promlk.c:    lterm = log(sumterm) + ((ml_node*)p)->underflows[i] +
promlk.c:      ((ml_node*)q)->underflows[i];
promlk.c:      l0gf[which - 1][i] = lterm;
promlk.c:      if ((ally[i] > 0) && (location[ally[i]-1] > 0))
promlk.c:        lai = location[ally[i] - 1];
promlk.c:        memcpy(clai, contribution[lai - 1], rcategs * sizeof(double));
promlk.c:          nulike[j] = ((1.0 - lambda) * like[j] + sumc) * clai[j];
promlk.c:          nulike[j] = ((1.0 - lambda) * like[j] + sumc);
promlk.c:  t->score = sum;
promlk.c:    l0gl[which - 1] = sum;
promlk.c:  hookup(newfork, below->back);
promlk.c:  hookup(newfork->next, below);
promlk.c:  hookup(newtip, newfork->next->next);
promlk.c:  curtree->nodep[newfork->index-1] = newfork;
promlk.c:  set_tyme(newfork->next, prevtyme);
promlk.c:  set_tyme(newfork->next->next, prevtyme);
promlk.c:  lowertyme = get_tyme(p->next->back);
promlk.c:    sib_ptr      = sib_ptr->next;
promlk.c:    sib_back_ptr = sib_ptr->back;
promlk.c:  set_tyme(p, lowertyme - 0.1);
promlk.c:    sib_ptr = sib_ptr->next;
promlk.c:    sib_back_ptr = sib_ptr->back;
promlk.c:    sib_back_ptr->v = get_tyme(sib_back_ptr) - get_tyme(p);
promlk.c:    sib_ptr->v = sib_back_ptr->v;
promlk.c:  if (p->tip)
promlk.c:    sib_ptr      = sib_ptr->next;
promlk.c:    sib_back_ptr = sib_ptr->back;
promlk.c:  if (p->tip)
promlk.c:  if (p->initialized)
promlk.c:    sib_ptr      = sib_ptr->next;
promlk.c:    sib_back_ptr = sib_ptr->back;
promlk.c:  curtree->nuview(curtree, p);
promlk.c:  p->initialized = true;
promlk.c:  if (p == curtree->root)
promlk.c:  if (p->tip)
promlk.c:    travinit(p->back);
promlk.c:      sib_ptr      = sib_ptr->next;
promlk.c:      sib_back_ptr = sib_ptr->back;
promlk.c:    curtree->nodep[i]->initialized = false;
promlk.c:    sib_ptr = curtree->nodep[i];
promlk.c:    sib_ptr->initialized = false;
promlk.c:      sib_ptr      = sib_ptr->next;
promlk.c:      sib_ptr->initialized = false;
promlk.c:    initrav(curtree->root);
promlk.c:  travsp(curtree->root);
promlk.c:      curtree->smoothall(curtree, curtree->root); /* already is a loop within smoothall, we need more! */
promlk.c:    curtree->smoothall(curtree, curtree->root); /* we should already be close */
promlk.c:  curtree->evaluate(curtree, curtree->root, 0);
promlk.c:  if (p->tip)
promlk.c:    p->xcoord = 0;
promlk.c:    p->ycoord = (*tipy);
promlk.c:    p->ymin   = (*tipy);
promlk.c:    p->ymax   = (*tipy);
promlk.c:  q = p->next;
promlk.c:    promlk_coordinates(q->back, tipy);
promlk.c:    q = q->next;
promlk.c:  q = p->next;
promlk.c:  first  = q->back;
promlk.c:    if (i == p1) pp1 = q->back;
promlk.c:    if (i == p2) pp2 = q->back;
promlk.c:    last = q->back;
promlk.c:    q = q->next;
promlk.c:  p->xcoord = (long)(0.5 - over * get_tyme(p) );
promlk.c:  p->ycoord = (pp1->ycoord + pp2->ycoord) / 2;
promlk.c:  p->ymin = first->ymin;
promlk.c:  p->ymax = last->ymax;
promlk.c:  p = curtree->root;
promlk.c:  q = curtree->root;
promlk.c:  if ((long)(p->ycoord) == i)
promlk.c:    if (p->index - spp >= 10)
promlk.c:      fprintf(outfile, "-%2ld", p->index - spp);
promlk.c:      fprintf(outfile, "--%ld", p->index - spp);
promlk.c:    if (!p->tip)
promlk.c:      r = p->next;
promlk.c:        if (i >= r->back->ymin && i <= r->back->ymax)
promlk.c:          q = r->back;
promlk.c:        r = r->next;
promlk.c:      first = p->next->back;
promlk.c:      r = p->next;
promlk.c:      while (r->next != p)
promlk.c:        r = r->next;
promlk.c:      last = r->back;
promlk.c:    n = (long)(scale * ((long)(p->xcoord) - (long)(q->xcoord)) + 0.5);
promlk.c:    if (n < 3 && !q->tip)
promlk.c:      n--;
promlk.c:    if ((long)(q->ycoord) == i && !done)
promlk.c:      if (p->ycoord != q->ycoord)
promlk.c:        putc('-', outfile);
promlk.c:      if (!q->tip)
promlk.c:        for (j = 1; j <= n - 2; j++)
promlk.c:          putc('-', outfile);
promlk.c:        if (q->index - spp >= 10)
promlk.c:          fprintf(outfile, "%2ld", q->index - spp);
promlk.c:          fprintf(outfile, "-%ld", q->index - spp);
promlk.c:          putc('-', outfile);
promlk.c:    else if (!p->tip)
promlk.c:      if ((long)(last->ycoord) > i && (long)(first->ycoord) < i &&
promlk.c:           i != (long)(p->ycoord))
promlk.c:  if ((long)(p->ycoord) == i && p->tip)
promlk.c:      putc(nayme[p->index - 1][j], outfile);
promlk.c:  promlk_coordinates(curtree->root, &tipy);
promlk.c:  p = curtree->root;
promlk.c:  while (!p->tip)
promlk.c:    p = p->next->back;
promlk.c:  scale = 1.0 / (long)( get_tyme(p) - get_tyme(curtree->root) + 1.000);
promlk.c:  for (i = 1; i <= tipy - down; i++)
promlk.c:  if (p == curtree->root)
promlk.c:    fprintf(outfile, "%4ld          ", p->back->index - spp);
promlk.c:  if (p->tip)
promlk.c:      putc(nayme[p->index - 1][i], outfile);
promlk.c:    fprintf(outfile, "%4ld      ", p->index - spp);
promlk.c:  if (p != curtree->root)
promlk.c:    fprintf(outfile, "%11.5f", ( get_tyme(p) - get_tyme(curtree->root) ));
promlk.c:    v = ( get_tyme(p) - get_tyme(curtree->nodep[p->back->index -1]) );
promlk.c:  if (!p->tip)
promlk.c:      sib_ptr      = sib_ptr->next;
promlk.c:      sib_back_ptr = sib_ptr->back;
promlk.c:  if (p->tip)
promlk.c:    putc(inputSequences[p->index-1][n], outfile);
promlk.c:    if ((ally[n] == 0) || (location[ally[n]-1] == 0))
promlk.c:      j = location[ally[n]-1] - 1;
promlk.c:        f = ((prot_node*)p)->x[j][mx-1][i];
promlk.c:        if (!p->tip)
promlk.c:            q = q->next;
promlk.c:            f *= ((prot_node*)q)->x[j][mx-1][i];
promlk.c:          f = exp(log(f)/(num_sibs-1.0));
promlk.c:        mx = mp[n][mx - 1];
promlk.c:  if (p->tip)
promlk.c:      putc(nayme[p->index-1][i], outfile);
promlk.c:    fprintf(outfile, "%4ld      ", p->index - spp);
promlk.c:  if (!p->tip)
promlk.c:      sib_ptr = sib_ptr->next;
promlk.c:      rectrav(sib_ptr->back, m, n);
promlk.c:  for (i = 0; i <= sites-1; ++i)
promlk.c:  fprintf(outfile, "\nLn Likelihood = %11.5f\n\n", curtree->score);
promlk.c:  fprintf(outfile, " --------      ----      ---- ------     ------\n");
promlk.c:  describe(curtree->root);
promlk.c:    for (i = sites - 1; i >= 0; i--)
promlk.c:        nulike[j] = (1.0 - lambda + lambda * probcat[j]) * like[j];
promlk.c:            if (lambda * probcat[k - 1] * like[k - 1] > nulike[j])
promlk.c:              nulike[j] = lambda * probcat[k - 1] * like[k - 1];
promlk.c:        if ((ally[i] > 0) && (location[ally[i]-1] > 0))
promlk.c:          nulike[j] *= contribution[location[ally[i] - 1] - 1][j];
promlk.c:      if (probcat[i - 1] * like[i - 1] > mode)
promlk.c:        mode = probcat[i - 1] * like[i - 1];
promlk.c:      mx = mp[i - 1][mx - 1];
promlk.c:    for (i = sites - 1; i >= 0; i--)
promlk.c:        nulike[j] = (1.0 - lambda + lambda * probcat[j]) * like[j];
promlk.c:            nulike[j] += lambda * probcat[k - 1] * like[k - 1];
promlk.c:        if ((ally[i] > 0) && (location[ally[i]-1] > 0))
promlk.c:          nulike[j] *= contribution[location[ally[i] - 1] - 1][j];
promlk.c:        nulike[j] = (1.0 - lambda + lambda * probcat[j]) * like[j];
promlk.c:            nulike[j] += lambda * probcat[k - 1] * like[k - 1];
promlk.c:    for (i = 0; (i < 13) && (i < ((sites + (sites-1)/10 - 39) / 2)); i++)
promlk.c:        k = sites - 1;
promlk.c:      rectrav(curtree->root, i, k);
promlk.c:  for (i = 0; i <= sites-1; ++i)
promlk.c:      *p = treep->get_forknode(treep, nodei);
promlk.c:      (*p)->index = nodei;
promlk.c:      (*p)->tip = false;
promlk.c:      ((ml_node*)*p)->allocx((ml_node*)*p, endsite, rcategs);
promlk.c:      treep->nodep[(*p)->index - 1] = (*p);
promlk.c:      *p = treep->get_forknode(treep, nodei);
promlk.c:      ((ml_node*)*p)->allocx((ml_node*)*p, endsite, rcategs);
promlk.c:      (*p)->index = nodei;
promlk.c:      match_names_to_data(str, treep->nodep, p, spp);
promlk.c:      (*p)->initialized = false;
promlk.c:      (*p)->v = initialv;
promlk.c:      (*p)->iter = true;
promlk.c:      if ((*p)->back != NULL)
promlk.c:        (*p)->back->iter = true;
promlk.c:      (*p)->v = valyew / divisor;
promlk.c:      (*p)->iter = false;
promlk.c:      if ((*p)->back != NULL)
promlk.c:        (*p)->back->v = (*p)->v;
promlk.c:        (*p)->back->iter = false;
promlk.c:      treep->nodep[spp]->iter = false;
promlk.c:  if (p->tip)
promlk.c:      if (nayme[p->index - 1][i - 1] != ' ')
promlk.c:      c = nayme[p->index - 1][i];
promlk.c:    for (i=0; i < (num_sibs - 1); i++)
promlk.c:      sib_ptr = sib_ptr->next;
promlk.c:      promlk_treeout(sib_ptr->back);
promlk.c:    sib_ptr = sib_ptr->next;
promlk.c:    promlk_treeout(sib_ptr->back);
promlk.c:  if (p == curtree->root)
promlk.c:  x = get_tyme(p) - get_tyme(curtree->nodep[p->back->index - 1]);
promlk.c:    w = (long)(0.4342944822 * log(-x)) + 1;
promlk.c:  if (!p->tip)
promlk.c:      sib_ptr = sib_ptr->next;
promlk.c:      tymetrav(sib_ptr->back, x);
promlk.c:  if (!p->tip)
promlk.c:    while (q->next != p)
promlk.c:      q = q->next;
promlk.c:  (*x) = get_tyme(p) - p->v;
promlk.c:  /* constructs a binary tree from the pointers in curtree->nodep,
promlk.c:    /* Open in binary: ftell() is broken for UNIX line-endings under WIN32 */
promlk.c:      fprintf(outfile, "User-defined tree");
promlk.c:         since multiple trees require re-initialization */
promlk.c:      root = curtree->nodep[root->index - 1];
promlk.c:      curtree->root = root;
promlk.c:        tymetrav(curtree->root, &x);
promlk.c:        printf ("\tNumber of trees actually in file:\t%ld.\n\n", which - 1);
promlk.c:        exxit(-1);
promlk.c:        promlk_treeout(curtree->root);
promlk.c:        prot_freex_notip(nonodes, curtree->nodep);
promlk.c:      enterorder[i - 1] = i;
promlk.c:    curtree->root = curtree->nodep[spp];  /* debug: use enterorder?? */
promlk.c:    curtree->root->back = NULL;
promlk.c:      curtree->nodep[i]->back = NULL;
promlk.c:      q = curtree->nodep[i];
promlk.c:      q->back = NULL;
promlk.c:      while ((q = q->next) != curtree->nodep[i])
promlk.c:        q->back = NULL;
promlk.c:    curtree->insert_(curtree, curtree->nodep[enterorder[0]-1], curtree->nodep[enterorder[1]-1], false, false);
promlk.c:      there = curtree->root;
promlk.c:      item = curtree->nodep[enterorder[i - 1] - 1];
promlk.c:      nufork = curtree->nodep[spp + i - 2];
promlk.c:      curtree->copy(curtree, priortree);
promlk.c:      like = curtree->evaluate(curtree, curtree->root, 0);
promlk.c:      curtree->addtraverse(curtree, item, curtree->root, true, &qwhere, &bestyet, bestree, priortree, true, &multf);
promlk.c:      curtree->insert_(curtree, item, qwhere, false, multf);
promlk.c:      curtree->smoothall(curtree, curtree->root);
promlk.c:      curtree->locrearrange(curtree, curtree->root, false, priortree, bestree);
promlk.c:        writename(i - 1, 1, enterorder);
promlk.c:            sprintf(progbuf, "-");
promlk.c:      curtree->globrearrange(curtree, progress, true);
promlk.c:      curtree->copy(curtree, bestree);
promlk.c:    curtree->copy(curtree, bestree);
promlk.c:      // Free up FORKRINGS for use in next tree -- the order matters here as we want
promlk.c:      // the lowest-index forknode to be the first to be popped from the stack.
promlk.c:      for ( i = nonodes - 1 ; i >= spp ; i-- )
promlk.c:        curtree->release_fork(curtree, curtree->nodep[i]);
promlk.c:      curtree->root = NULL;
promlk.c:      if (jumb == 1 || bestree2->score < bestree->score)
promlk.c:        bestree->copy(bestree, bestree2);
promlk.c:        bestree2->copy(bestree2, curtree);
promlk.c:        bestree->copy(bestree, curtree);
promlk.c:      curtree->evaluate(curtree, curtree->root, 0);
promlk.c:        promlk_treeout(curtree->root);
promlk.c:  prom_free_all_x(nonodes2, curtree->nodep);
promlk.c:    prom_free_all_x(nonodes2, bestree->nodep);
promlk.c:      prom_free_all_x(nonodes2, bestree2->nodep);
promlk.c:    // User-defined HMM of rates
promlk.c:      initgammacat(rcategs-1, alpha, rrate, probcat);
promlk.c:      for (i = 0; i < rcategs-1; i++)
promlk.c:        probcat[i] = probcat[i]*(1.0-invarfrac);
promlk.c:      probcat[rcategs-1] = invarfrac;
promlk.c:      rrate[rcategs-1] = 0.0;
protdist.c:/* Version 4.0. (c) Copyright 1993-2013 by the University of Washington.
protdist.c:long cat[(long)ser - (long)ala + 1], numaa[(long)ser - (long)ala + 1];
protdist.c:{+0.00000000000000, -1.81721720738768, -1.87965834528616, -1.61403121885431,
protdist.c: -1.53896608443751, -1.40486966367848, -1.30995061286931, -1.24668414819041,
protdist.c: -1.17179756521289, -0.31033320987464, -0.34602837857034, -1.06031718484613,
protdist.c: -0.99900602987105, -0.45576774888948, -0.86014403434677, -0.54569432735296,
protdist.c: -0.76866956571861, -0.60593589295327, -0.65119724379348, -0.70249806480753};
protdist.c: {-0.04445795120462, -0.01557336502860, -0.09314817363516, +0.04411372100382,
protdist.c:  -0.00511178725134, +0.00188472427522, -0.02176250428454, -0.01330231089224,
protdist.c:  +0.01004072641973, +0.02707838224285, -0.00785039050721, +0.02238829876349,
protdist.c:  +0.00257470703483, -0.00510311699563, -0.01727154263346, +0.20074235330882,
protdist.c:  -0.07236268502973, -0.00012690116016, -0.00215974664431, -0.01059243778174},
protdist.c: {+0.09480046389131, +0.00082658405814, +0.01530023104155, -0.00639909042723,
protdist.c:  +0.00160605602061, +0.00035896642912, +0.00199161318384, -0.00220482855717,
protdist.c:  -0.00112601328033, +0.14840201765438, -0.00344295714983, -0.00123976286718,
protdist.c:  -0.00439399942758, +0.00032478785709, -0.00104270266394, -0.02596605592109,
protdist.c:  -0.05645800566901, +0.00022319903170, -0.00022792271829, -0.16133258048606},
protdist.c: {-0.06924141195400, -0.01816245289173, -0.08104005811201, +0.08985697111009,
protdist.c:  +0.00279659017898, +0.01083740322821, -0.06449599336038, +0.01794514261221,
protdist.c:  -0.01748667848380, +0.00161859106290, +0.00622486432503, -0.05854130195643,
protdist.c:  +0.15083728660504, +0.00030733757661, -0.00143739522173, -0.05295810171941},
protdist.c: {-0.14637948915627, +0.02029296323583, +0.02615316895036, -0.10311538564943,
protdist.c:  -0.00183412744544, -0.02589124656591, +0.11073673851935, +0.00848581728407,
protdist.c:  +0.00106057791901, +0.05530240732939, -0.00031533506946, -0.03124002869407,
protdist.c:  -0.01533984125301, -0.00288717337278, +0.00272787410643, +0.06300929916280,
protdist.c:  +0.07920438311152, -0.00041335282410, -0.00011648873397, -0.03944076085434},
protdist.c: {-0.05558229086909, +0.08935293782491, +0.04869509588770, +0.04856877988810,
protdist.c:  -0.00253836047720, +0.07651693957635, -0.06342453535092, -0.00777376246014,
protdist.c:  -0.08570270266807, +0.01943016473512, -0.00599516526932, -0.09157595008575,
protdist.c:  -0.00397735155663, -0.00440093863690, -0.00232998056918, +0.02979967701162,
protdist.c:  -0.00477299485901, -0.00144011795333, +0.01795114942404, -0.00080059359232},
protdist.c: {+0.05807741644682, +0.14654292420341, -0.06724975334073, +0.02159062346633,
protdist.c:  -0.00339085518294, -0.06829036785575, +0.03520631903157, -0.02766062718318,
protdist.c:  +0.03485632707432, -0.02436836692465, -0.00397566003573, -0.10095488644404,
protdist.c:  +0.02456887654357, +0.00381764117077, -0.00906261340247, -0.01043058066362,
protdist.c:  +0.01651199513994, -0.00210417220821, -0.00872508520963, -0.01495915462580},
protdist.c: {+0.02564617106907, +0.02960554611436, -0.00052356748770, +0.00989267817318,
protdist.c:  -0.00044034172141, -0.02279910634723, -0.00363768356471, -0.01086345665971,
protdist.c:  +0.01229721799572, +0.02633650142592, +0.06282966783922, -0.00734486499924,
protdist.c:  -0.13863936313277, -0.00993891943390, -0.00655309682350, -0.00245191788287,
protdist.c:  -0.02431633805559, -0.00068554031525, -0.00121383858869, +0.06280025239509},
protdist.c: {+0.11362428251792, -0.02080375718488, -0.08802750967213, -0.06531316372189,
protdist.c:  -0.00166626058292, +0.06846081717224, +0.07007301248407, -0.01713112936632,
protdist.c:  -0.05900588794853, -0.04497159138485, +0.04222484636983, +0.00129043178508,
protdist.c:  -0.01550337251561, -0.01553102163852, -0.04363429852047, +0.01600063777880,
protdist.c:  +0.05787328925647, -0.00008265841118, +0.02870014572813, -0.02657681214523},
protdist.c:  -0.00923516894192, +0.01209943150832, +0.02906782189141, +0.01992384905334,
protdist.c:  +0.00197323568330, +0.00017531415423, -0.01796698381949, +0.01887083962858,
protdist.c:  -0.00063335886734, -0.02365277334702, +0.01209445088200, +0.01308086447947,
protdist.c:  +0.01286727242301, -0.11420358975688, -0.01886991700613, +0.00238338728588},
protdist.c: {-0.01100105031759, -0.04250695864938, -0.02554356700969, -0.05473632078607,
protdist.c:  +0.00725906469946, -0.03003724918191, -0.07051526125013, -0.06939439879112,
protdist.c:  -0.00285883056088, +0.05334304124753, +0.12839241846919, -0.05883473754222,
protdist.c:  +0.02424304967487, +0.09134510778469, -0.00226003347193, -0.01280041778462,
protdist.c:  -0.00207988305627, -0.02957493909199, +0.05290385686789, +0.05465710875015},
protdist.c: {-0.01421274522011, +0.02074863337778, -0.01006411985628, +0.03319995456446,
protdist.c:  -0.00005371699269, -0.12266046460835, +0.02419847062899, -0.00441168706583,
protdist.c:  -0.08299118738167, -0.00323230913482, +0.02954035119881, +0.09212856795583,
protdist.c:  +0.00718635627257, -0.02706936115539, +0.04473173279913, -0.01274357634785,
protdist.c:  -0.01395862740618, -0.00071538848681, +0.04767640012830, -0.00729728326990},
protdist.c: {-0.03797680968123, +0.01280286509478, -0.08614616553187, -0.01781049963160,
protdist.c:  -0.01529816709967, +0.06885987924922, -0.11719120476535, -0.00014333663810,
protdist.c:  +0.00074336784254, +0.02893416406249, +0.07466151360134, -0.08182016471377,
protdist.c:  -0.06581536577662, -0.00018195976501, +0.00167443595008, +0.09015415667825},
protdist.c: {+0.03577726799591, -0.02139253448219, -0.01137813538175, -0.01954939202830,
protdist.c:  -0.04028242801611, -0.01777500032351, -0.02106862264440, +0.00465199658293,
protdist.c:  -0.02824805812709, +0.06618860061778, +0.08437791757537, -0.02533125946051,
protdist.c:  +0.02806344654855, -0.06970805797879, +0.02328376968627, +0.00692992333282,
protdist.c:  +0.02751392122018, +0.01148722812804, -0.11130404325078, +0.07776346000559},
protdist.c: {-0.06014297925310, -0.00711674355952, -0.02424493472566, +0.00032464353156,
protdist.c:  +0.03326534127710, -0.01558838623875, +0.13794237677194, -0.04292623056646,
protdist.c:  +0.01375763233229, -0.11125153774789, +0.03510076081639, -0.04531670712549,
protdist.c:  -0.06170413486351, -0.00182023682123, +0.05979891871679, -0.02551802851059},
protdist.c: {-0.03515069991501, +0.02310847227710, +0.00474493548551, +0.02787717003457,
protdist.c:  -0.12038329679812, +0.03178473522077, +0.04445111601130, -0.05334957493090,
protdist.c:  +0.01290386678474, -0.00376064171612, +0.03996642737967, +0.04777677295520,
protdist.c:  +0.00233689200639, +0.03917715404594, -0.01755598277531, -0.03389088626433,
protdist.c:  -0.02180780263389, +0.00473402043911, +0.01964539477020, -0.01260807237680},
protdist.c: {-0.04120428254254, +0.00062717164978, -0.01688703578637, +0.01685776910152,
protdist.c:  -0.02073122710938, -0.06932247350110, +0.11696314241296, -0.00322523765776,
protdist.c:  -0.01280515661402, +0.08717664266126, +0.06297225078802, -0.01290501780488,
protdist.c:  -0.04693925076877, -0.00177653675449, -0.08407812137852, -0.08380714022487},
protdist.c: {+0.03138655228534, -0.09052573757196, +0.00874202219428, +0.06060593729292,
protdist.c:  -0.03426076652151, -0.04832468257386, +0.04735628794421, +0.14504653737383,
protdist.c:  -0.01709111334001, -0.00278794215381, -0.03513813820550, -0.11690294831883,
protdist.c:  -0.00836264902624, +0.03270980973180, -0.02587764129811, +0.01638786059073,
protdist.c: {-0.04898722042023, -0.01460879656586, +0.00508708857036, +0.07730497806331,
protdist.c:  +0.04252420017435, +0.00484232580349, +0.09861807969412, -0.05169447907187,
protdist.c:  -0.00917820907880, +0.03679081047330, +0.04998537112655, +0.00769330211980,
protdist.c:  +0.01805447683564, -0.00498723245027, -0.14148416183376, -0.05170281760262,
protdist.c:  -0.03230723310784, -0.00032890672639, -0.02363523071957, +0.03801365471627},
protdist.c: {-0.02047562162108, +0.06933781779590, -0.02101117884731, -0.06841945874842,
protdist.c:  -0.00860967572716, -0.00886650271590, -0.07185241332269, +0.16703684361030,
protdist.c:  -0.00635847581692, +0.00811478913823, +0.01847205842216, +0.06700967948643,
protdist.c:  +0.00596607376199, +0.02318239240593, -0.10552958537847, -0.01980199747773,
protdist.c:  -0.02003785382406, -0.00593392430159, -0.00965391033612, +0.00743094349652}};
protdist.c:{0.0000001586972220, -1.8416770496147100, -1.6025046986139100, -1.5801012515121300,
protdist.c: -1.4987794099715900, -1.3520794233801900, -1.3003469390479700, -1.2439503327631300,
protdist.c: -1.1962574080244200, -1.1383730501367500, -1.1153278910708000, -0.4934843510654760,
protdist.c: -0.5419014550215590, -0.9657997830826700, -0.6276075673757390, -0.6675927795018510,
protdist.c: -0.6932641383465870, -0.8897872681859630, -0.8382698977371710, -0.8074694642446040};
protdist.c: {0.0368263046116572, -0.0006728917107827, 0.0008590805287740, -0.0002764255356960,
protdist.c:  -0.0004226254397134, 0.1805040629634510, -0.0272246813586204, 0.0005904606533477,
protdist.c:  -0.0183743200073889, -0.0009194625608688, 0.0008173657533167, -0.0262629806302238,
protdist.c:  0.0265738757209787, 0.0002176606241904, 0.0021315644838566, -0.1823229927207580},
protdist.c: {-0.0194800075560895, 0.0012068088610652, -0.0008803318319596, -0.0016044273960017,
protdist.c:  -0.0002938633803197, -0.0535796754602196, 0.0155163896648621, -0.0015006360762140,
protdist.c:  0.0021601372013703, 0.0268513218744797, -0.1085292493742730, 0.0149753083138452,
protdist.c:  0.1346457366717310, -0.0009371698759829, 0.0013501708044116, 0.0346352293103622,
protdist.c:  -0.0276963770242276, 0.0003643142783940, 0.0002074817333067, -0.0174108903914110},
protdist.c:  0.0002013267015151, -0.0227406863569852, 0.0098644845475047, 0.0064721276774396,
protdist.c:  0.0001389408104210, -0.0473713878768274, -0.0086984445005797, 0.0026913674934634,
protdist.c:  0.0283724052562196, 0.0001063665179457, 0.0027442574779383, -0.1875312134708470,
protdist.c: {0.0037510125027265, 0.0107095920636885, 0.0147305410328404, -0.0112351252180332,
protdist.c:  -0.0001500408626446, -0.1523450933729730, 0.0611532413339872, -0.0005496748939503,
protdist.c:  0.0048714378736644, -0.0003826320053999, 0.0552010244407311, 0.0482555671001955,
protdist.c:  -0.0461664995115847, -0.0021165008617978, -0.0004574454232187, 0.0233755883688949,
protdist.c:  -0.0035484915422384, 0.0009090698422851, 0.0013840637687758, -0.0073895139302231},
protdist.c: {-0.0111512564930024, 0.1025460064723080, 0.0396772456883791, -0.0298408501361294,
protdist.c:  -0.0001656742634733, -0.0079876311843289, 0.0712644184507945, -0.0010780604625230,
protdist.c:  -0.0035880882043592, 0.0021070399334252, 0.0016716329894279, -0.1810123023850110,
protdist.c:  0.0015141703608724, -0.0032700852781804, 0.0035503782441679, 0.0118634302028026,
protdist.c:  0.0044561606458028, -0.0001576678495964, 0.0023470722225751, -0.0027457045397157},
protdist.c: {0.1474525743949170, -0.0054432538500293, 0.0853848892349828, -0.0137787746207348,
protdist.c:  -0.0008274830358513, 0.0042248844582553, 0.0019556229305563, -0.0164191435175148,
protdist.c:  -0.0024501858854849, 0.0120908948084233, -0.0381456105972653, 0.0101271614855119,
protdist.c:  -0.0061945941321859, 0.0178841099895867, -0.0014577779202600, -0.0752120602555032,
protdist.c:  -0.1426985695849920, 0.0002862275078983, -0.0081191734261838, 0.0313401149422531},
protdist.c: {0.0542034611735289, -0.0078763926211829, 0.0060433542506096, 0.0033396210615510,
protdist.c:  0.0013965072374079, 0.0067798903832256, -0.0135291136622509, -0.0089982442731848,
protdist.c:  -0.0056744537593887, -0.0766524225176246, 0.1881210263933930, -0.0065875518675173,
protdist.c:  0.0416627569300375, -0.0953804133524747, -0.0012559228448735, 0.0101622644292547,
protdist.c:  -0.0304742453119050, 0.0011702318499737, 0.0454733434783982, -0.1119239362388150},
protdist.c: {0.1069409037912470, 0.0805064400880297, -0.1127352030714600, 0.1001181253523260,
protdist.c:  -0.0021480427488769, -0.0332884841459003, -0.0679837575848452, -0.0043812841356657,
protdist.c:  0.0153418716846395, -0.0079441315103188, -0.0121766182046363, -0.0381127991037620,
protdist.c:  -0.0036338726532673, 0.0195324059593791, -0.0020165963699984, -0.0061222685010268,
protdist.c:  -0.0253761448771437, -0.0005246410999057, -0.0112205170502433, 0.0052248485517237},
protdist.c: {-0.0325247648326262, 0.0238753651653669, 0.0203684886605797, 0.0295666232678825,
protdist.c:  -0.0003946714764213, -0.0157242718469554, -0.0511737848084862, 0.0084725632040180,
protdist.c:  -0.0167068828528921, 0.0686962159427527, -0.0659702890616198, -0.0014289912494271,
protdist.c:  -0.0167000964093416, -0.1276689083678200, 0.0036575057830967, -0.0205958145531018,
protdist.c: {-0.0463777468104402, 0.0394712148670596, 0.1118686750747160, 0.0440711686389031,
protdist.c:  -0.0026076286506751, -0.0268454015202516, -0.1464943067133240, -0.0137514051835380,
protdist.c:  -0.0094395514284145, -0.0144124844774228, 0.0249103379323744, -0.0071832157138676,
protdist.c:  0.0316121324137152, -0.0011350177559026, -0.0349998884574440, -0.0302651879823361},
protdist.c:  -0.0586974207121084, 0.0202001168873069, 0.0492204086749069, 0.1126593173463060,
protdist.c:  0.0116620013776662, -0.0780333711712066, -0.1109786767320410, 0.0407775100936731,
protdist.c:  -0.0205013161312652, -0.0653458585025237, 0.0347351829703865, 0.0304448983224773,
protdist.c:  0.0068813748197884, -0.0189002309261882, -0.0334507528405279, -0.0668143558699485},
protdist.c: {-0.0131548829657936, 0.0044244322828034, -0.0050639951827271, -0.0038668197633889,
protdist.c:  -0.1536822386530220, 0.0026336969165336, 0.0021585651200470, -0.0459233839062969,
protdist.c:  0.0117574347936383, 0.0373018612990383, 0.0024818527553328, -0.0133956606027299,
protdist.c:  -0.0020457128424105, 0.0154178819990401, 0.0246524142683911, 0.0275363065682921},
protdist.c: {-0.1542307272455030, 0.0364861558267547, -0.0090880407008181, 0.0531673937889863,
protdist.c:  0.0099593861698250, -0.0013941794862563, 0.0294065511237513, -0.1151906949298290,
protdist.c:  -0.0852991447389655, 0.0028699120202636, -0.0332087026659522, 0.0006811857297899},
protdist.c: {0.0281300736924501, -0.0584072081898638, -0.0178386569847853, -0.0536470338171487,
protdist.c:  -0.0186881656029960, -0.0240008730656106, -0.0541064820498883, 0.2217137098936020,
protdist.c:  -0.0260500001542033, 0.0234505236798375, 0.0311127151218573, -0.0494139126682672,
protdist.c:  0.0057093465049849, 0.0124937286655911, -0.0298322975915689, 0.0006520211333102,
protdist.c:  -0.0061018680727128, -0.0007081999479528, -0.0060523759094034, 0.0215845995364623},
protdist.c: {0.0295321046399105, -0.0088296411830544, -0.0065057049917325, -0.0053478115612781,
protdist.c:  -0.0100646496794634, -0.0015473619084872, 0.0008539960632865, -0.0376381933046211,
protdist.c:  -0.0328135588935604, 0.0672161874239480, 0.0667626853916552, -0.0026511651464901,
protdist.c:  0.0140451514222062, -0.0544836996133137, 0.0427485157912094, 0.0097455780205802,
protdist.c:  0.0177309072915667, -0.0828759701187452, -0.0729504795471370, 0.0670731961252313},
protdist.c: {0.0082646581043963, -0.0319918630534466, -0.0188454445200422, -0.0374976353856606,
protdist.c:  0.0037131290686848, -0.0132507796987883, -0.0306958830735725, -0.0044119395527308,
protdist.c:  -0.0140786756619672, -0.0180512599925078, -0.0208243802903953, -0.0232202769398931,
protdist.c:  -0.0063135878270273, 0.0110442171178168, 0.1824538048228460, -0.0006644614422758,
protdist.c:  -0.0069909097436659, 0.0255407650654681, 0.0099119399501151, -0.0140911517070698},
protdist.c: {0.0261344441524861, -0.0714454044548650, 0.0159436926233439, 0.0028462736216688,
protdist.c:  -0.0044572637889080, -0.0089474834434532, -0.0177570282144517, -0.0153693244094452,
protdist.c:  0.1160919467206400, 0.0304911481385036, 0.0047047513411774, -0.0456535116423972,
protdist.c:  0.0004491494948617, -0.0767108879444462, -0.0012688533741441, 0.0192445965934123,
protdist.c:  0.0202321954782039, 0.0281039933233607, -0.0590403018490048, 0.0364080426546883},
protdist.c: {0.0115826306265004, 0.1340228176509380, -0.0236200652949049, -0.1284484655137340,
protdist.c:  -0.0004742338006503, 0.0127617346949511, -0.0428560878860394, 0.0060030732454125,
protdist.c:  0.0029940462557054, -0.0483434904493132, -0.0071713680727884, -0.0036840391887209,
protdist.c:  0.0031454003250096, 0.0246243550241551, -0.0449551277644180, 0.0111449232769393},
protdist.c: {0.0140356721886765, -0.0196518236826680, 0.0030517022326582, 0.0582672093364850,
protdist.c:  -0.0000973895685457, 0.0021704767224292, 0.0341806268602705, -0.0152035987563018,
protdist.c:  -0.0903198657739177, 0.0259623214586925, 0.0155832497882743, -0.0040543568451651,
protdist.c:  0.0036477631918247, -0.0532892744763217, -0.0142569373662724, 0.0104500681408622,
protdist.c:  0.0103483945857315, 0.0679534422398752, -0.0768068882938636, 0.0280289727046158}};
protdist.c:{-0.00000000000000, -2.14002629929612, -1.98979275306040, -1.61725099201056,
protdist.c: -2.80992186734198, -1.38594141212323, -1.31163642598910, -1.13615091597604,
protdist.c: -0.94309789344695, -0.89352990819100, -0.88574592545073, -0.80708852248316,
protdist.c: -0.29118988576124, -0.71609206088348, -0.35071740499615, -0.63506018793414,
protdist.c: -0.58607551901193, -0.43219422054965, -0.46651052361080, -0.50178166423835};
protdist.c: {-0.05583404000123, +0.07120839966327, +0.00400805125434, -0.03129801097549,
protdist.c:  -0.00118034108025, -0.00005784011357, +0.02902717794652, +0.02708276678722,
protdist.c:  +0.00356211213890, -0.00023135837716, -0.00664026352398, -0.00508907267791,
protdist.c:  -0.00071251524340, -0.00486945372289, -0.00135045451646, +0.12196612602273,
protdist.c:  -0.18132166729332, -0.00169105641451, +0.00122917618601, +0.03219226394118},
protdist.c: {-0.07742221452519, -0.03748115414437, +0.00079427741129, +0.06621455225863,
protdist.c:  +0.01152345334999, -0.00159215605250, -0.14912593339834, -0.02073421293717,
protdist.c:  -0.00257114293195, +0.00172415279055, -0.00802280919503, -0.01451474306382,
protdist.c:  -0.00052310695156, +0.00071682705274, +0.00397089071348, +0.13414509621755},
protdist.c: {-0.00760157730678, -0.13464888045758, -0.00109350953234, +0.09691491222949,
protdist.c:  +0.00397563732586, -0.00116794506454, +0.08013959636870, -0.03419444283104,
protdist.c:  +0.00400280768757, +0.00313086663110, -0.01117543982112, -0.00790420559991,
protdist.c:  +0.00686844865706, +0.02617634632170, -0.00200399845722, +0.08338174656626,
protdist.c:  -0.04572409993867, -0.00363287217973, +0.00241890018298, -0.05786229078177},
protdist.c: {+0.19237839429982, +0.00936920504775, -0.00103825741944, +0.01301516566682,
protdist.c:  -0.00298084386031, +0.00086073267605, -0.11720030397012, +0.00386967090888,
protdist.c:  +0.00130601783642, +0.00117039343296, -0.00011295661483, -0.00244321776948,
protdist.c:  -0.00345972316360, +0.00632841773974, -0.00137491528318, +0.06066536462675,
protdist.c:  -0.04341598435303, +0.00046026085039, -0.00240125260948, -0.11499616804210},
protdist.c: {-0.00816399642309, +0.03904332577472, +0.00217615997223, +0.06920248747605,
protdist.c:  -0.15216640934508, -0.00215058532851, +0.00216959996160, -0.06400165079175,
protdist.c:  +0.00374260631293, -0.01259216064685, +0.04610273645827, +0.07567802899892,
protdist.c:  +0.01017707741174, -0.02129861470428, -0.00080639018503, +0.00251882906103,
protdist.c:  +0.00487431779457, -0.00277564548178, +0.00527652072718, +0.00299376295715},
protdist.c: {-0.02416186095021, +0.06365428019728, -0.00086128898275, +0.01755739058380,
protdist.c:  +0.04822031962360, +0.00320976686921, +0.01201063741405, -0.19827545954260,
protdist.c:  +0.02106647647638, +0.01539638198766, -0.04038364027773, -0.02761490057128,
protdist.c:  -0.00044434555998, -0.04732971908165, -0.00351669060268, +0.10063662090176,
protdist.c:  +0.07607272141690, -0.00308689198314, +0.01622209629216, -0.02837189421077},
protdist.c: {+0.04265086468003, +0.05340899569753, -0.00495372273040, +0.13897907859339,
protdist.c:  +0.00201020832199, +0.02842236259046, -0.06662575622256, -0.03425330796572,
protdist.c:  -0.02175684493748, -0.04387169128384, -0.00954341475964, -0.11730650176101,
protdist.c:  -0.06293401486805, +0.00540463861927, -0.00314856002941, +0.02391050985435},
protdist.c: {-0.02802290490738, -0.02332819439480, +0.00369779054561, +0.01253286741895,
protdist.c:  -0.00325676318145, +0.00965012439579, -0.01435514190282, +0.12436012061609,
protdist.c:  -0.05901681100082, +0.01995423817208, -0.03286905152859, +0.02372607121939,
protdist.c:  +0.00693466648679, -0.14509615875613, +0.01683405825364, +0.07353193080077,
protdist.c:  +0.04334536836696, -0.00265234625294, -0.01565624696203, -0.01031361738910},
protdist.c: {-0.02460312026951, -0.00537475481428, +0.00294583890088, -0.02467527365317,
protdist.c:  -0.03837469406373, -0.01283837094733, -0.00017579407388, +0.01476436566340,
protdist.c:  -0.00077427033892, +0.11380389559004, -0.11665175661120, +0.05120192488404,
protdist.c:  -0.06283825235884, +0.04536464633685, +0.00420699907266, +0.02793102015908,
protdist.c:  +0.02250185351213, +0.02103160879467, -0.00313272839243, -0.01431313739048},
protdist.c: {-0.04987602967631, +0.02580430417529, +0.00322641605290, +0.00817708477743,
protdist.c:  +0.00270273782711, -0.03233401096402, -0.01845464328848, +0.03166774809972,
protdist.c:  +0.01193761126316, +0.06483161550157, -0.10273069702818, +0.02611359766193,
protdist.c:  +0.08805291780676, +0.03539792506763, +0.00638298245185, -0.02914219506402,
protdist.c:  -0.00180778090863, -0.02067398043140, +0.00512245365396, -0.05439805697827},
protdist.c: {+0.11226928617049, -0.05641108235947, -0.01003858534543, -0.05340444138097,
protdist.c:  -0.01994944242374, -0.01982184819927, +0.01328602122537, -0.03683428431339,
protdist.c:  +0.09080224755726, +0.04204373974391, -0.03616950695684, -0.00358345207923,
protdist.c:  +0.01870869440641, -0.06709437992173, -0.04132141209130, -0.00682495544155,
protdist.c:  -0.02432097777380, -0.00310282570971, -0.00641419634325, +0.10818140123625},
protdist.c: {+0.04533821906241, +0.00390771864787, +0.06410513278796, -0.00113736415880,
protdist.c:  -0.01515784185713, -0.01513341972953, +0.01838242817543, +0.02613045754941,
protdist.c:  +0.00831538904539, -0.10906786160468, -0.19095546886161, +0.01592892726831,
protdist.c:  -0.00519320426014, +0.01468714939066, +0.03947554726095, +0.02095600227594,
protdist.c:  +0.02282660804805, -0.00134761956069, +0.02643953742917, +0.03149966309106},
protdist.c: {-0.10357897662612, +0.00130824113276, +0.00242439947626, +0.02114482907740,
protdist.c:  +0.01653594812858, -0.02663976157270, -0.03588183393957, +0.07342201348591,
protdist.c:  +0.13241079682933, -0.03428158637950, +0.02625156126026, +0.05234233613201,
protdist.c:  -0.02119791201732, -0.02855373377530, -0.01052417693312, -0.00323372082770,
protdist.c:  +0.00739950739543, +0.00758370109983, +0.00276244752287, -0.07969407946931},
protdist.c: {+0.01637752489549, +0.01082744645546, -0.18127090190353, +0.00541276949273,
protdist.c:  -0.00874095186559, +0.01337228720703, +0.01243401603656, +0.03712232039942,
protdist.c:  +0.01168462988224, -0.02370273239977, -0.04459991935523, -0.00776987931211,
protdist.c: {+0.00549856847065, +0.01009268267332, -0.00399590993125, +0.00814079798057,
protdist.c:  -0.00999288157006, +0.03190743162542, +0.00420829252392, +0.04235451144805,
protdist.c:  +0.01629269449456, +0.01174495400945, -0.00208528982939, -0.03007887724738,
protdist.c:  -0.03178285778040, +0.01690490621000, -0.02754455494947, +0.01552574459433,
protdist.c:  +0.02395525510229, -0.09259047973341, +0.00324091859590, +0.00820409331288},
protdist.c: {-0.00666774930139, -0.03418043598142, +0.00610763575449, -0.02756262574224,
protdist.c:  +0.02916995903761, -0.00639717835500, -0.02028741838191, -0.07481914480643,
protdist.c:  -0.01629807929547, +0.01285607231561, +0.02033006577061, +0.13516126620161,
protdist.c:  -0.01259268232592, -0.03541048730445, +0.10944988432794, -0.06037590303071,
protdist.c:  -0.05970959312366, -0.02256932323224, +0.07136556678877, -0.00756982931580},
protdist.c: {+0.03050501507852, +0.01506161517475, -0.01001594251119, +0.01676804744673,
protdist.c:  +0.00869702430342, -0.18125050468544, +0.01810275165595, +0.02169137128226,
protdist.c:  -0.02341671495253, +0.00032659000082, +0.05305287551800, -0.01596996819783,
protdist.c:  -0.01174880007098, +0.00435652942368, +0.00687727524281, +0.02688737383256,
protdist.c:  +0.02127640159418, -0.01100933685074, +0.00826892598273, +0.02153947073229},
protdist.c: {+0.01848223726886, +0.00697586541112, -0.03815599945692, +0.00818172926745,
protdist.c:  +0.04222634101058, -0.00550240684480, +0.00604084612224, -0.03119139180410,
protdist.c:  -0.02035333463814, -0.03176712096642, -0.02610593028075, +0.19158013119683,
protdist.c:  -0.00058814592661, +0.01569309196301, -0.06179751549128, +0.00846678186931,
protdist.c:  -0.00175539876637, -0.00896491973514, -0.09320055014258, +0.02173568994371},
protdist.c: {-0.00237681772908, -0.00273114014378, -0.00554787623529, +0.00038031746036,
protdist.c:  +0.01093431379624, +0.00301149416793, -0.00496583711803, +0.02334490717274,
protdist.c:  -0.02977882281517, -0.00649208856057, -0.00605179065586, +0.05450978926937,
protdist.c:  +0.00127225450745, -0.00150440564166, -0.15844580506689, +0.00271413223668,
protdist.c:  +0.00192239709140, +0.00785415824878, +0.11236993007742, -0.00041911006205}};
protdist.c:{0, -0.3204890565838896, -0.342118729655122, -0.3621199763344617,
protdist.c: -0.42425349827931047, -0.4630023522299679, -0.5194737422772733,
protdist.c: -0.5302951439754717, -0.5584153495101145, -0.6042595052233659,
protdist.c: -0.6198173099623858, -0.628117120410433, -0.6919863715850639,
protdist.c: -0.6929502926696651, -0.7032447061868652, -0.7256462874859375,
protdist.c: -0.7295089293264996, -0.7722898430933931, -0.8173066967456089,
protdist.c: -0.847148221517062};
protdist.c:{{-0.07203602702251978, -0.019009507130942526, -0.03901951463719818,
protdist.c:  -0.019009507130942606, -0.006003002251876636, -0.025012509382819414,
protdist.c:  -0.024012009007506618, -0.05602802101751522, -0.028014010508757663,
protdist.c:  -0.08804403302752412, -0.16808406305254608, -0.023011508632193763,
protdist.c:  -0.05402702026688983, -0.06103052289407924, -0.05402702026688981,
protdist.c:  -0.07203602702251961, -0.0860430322768985, -0.029014510884070466,
protdist.c:  -0.03301651238532159, -0.04302151613844923},
protdist.c: {-0.017517586373701557, 0.0044690135586081935, -0.012547515478628367,
protdist.c:  -0.008199133151888348, -0.0001753378969220847, -0.005523069196361307,
protdist.c:  -0.045476579242231176, -0.020794874062075728, -0.005992851303280668,
protdist.c:  -0.01692090889778262, 0.008518604383321375, -0.0014906045625853457,
protdist.c:  -0.0043451662257916164, -0.008380023894141992, -0.008449781923272679,
protdist.c:  -0.006757589814677082, -0.006812209689054099, 0.15994460862472504,
protdist.c:  0.0018555680932886933, -0.005404562947548753},
protdist.c: {-0.019277996470746055, 0.009829109719811603, 0.013202948689412925,
protdist.c:  0.025198260961503877, -0.0013641841815875873, -0.00029175830027572636,
protdist.c:  -0.048477064803570634, -0.06709708888503682, 0.0005140151608483916,
protdist.c:  -0.0187066637882293, -0.03387581045095514, -0.00906987403394297,
protdist.c:  -0.0015383956564741317, -0.024671714820480216, 0.046264883187204696,
protdist.c:  -0.008160913902120629, -0.02637253826834758},
protdist.c: {-0.008682367425506833, 0.1308245420552605, -0.0009902307786551396,
protdist.c:  0.0021533577789693264, 0.0018302468673956458, -8.104904463312574e-6,
protdist.c:  -0.02121288527128687, 0.0022004730748593436, 0.02895262905005636,
protdist.c:  -0.02862440289511849, -0.03506794418709437, 0.013135058042701658,
protdist.c:  -0.010837644809467235, -0.016660748098826256, -0.0010275830273285575,
protdist.c:  -0.007091584824714246, -0.010821723264122842, -0.013630810718571354,
protdist.c:  -0.0055818122336798795, -0.01885846443040689},
protdist.c: {0.041366580707261465, -0.01653024674480136, 0.024507592966653984,
protdist.c:  0.07433435408793489, -0.0007696362643516623, 0.00017448933549620038,
protdist.c:  -0.04618750574477313, 0.1532273183177617, 0.0019542152173381067,
protdist.c:  -0.03767100396837566, -0.08276199085637366, -0.002666407673209008,
protdist.c:  -0.006531432352357671, -0.037220275378753775, -0.0017193733418939235,
protdist.c:  0.01820359429610238, -0.021885140265573547, 0.0017639655718305442,
protdist.c:  -0.015901475501720733, -0.04568762240819522},
protdist.c: {0.06337177449107013, 0.008756997601184627, -0.013236110695539637,
protdist.c:  -0.09777320067436955, -0.0005624241015292617, -0.015625553895796642,
protdist.c:  0.014641343305865213, 0.13333464799733624, -0.03334176351375394,
protdist.c:  0.020886285164158573, -0.021351411147413693, -0.004221407588701612,
protdist.c:  0.00652933996807588, -0.020485809875335926, -0.010972299223996281,
protdist.c:  0.005275881758194924, -0.016995814866565775, 0.00658070679595712,
protdist.c:  -0.03235847602027496, 0.00754729452143467},
protdist.c: {-0.023580632634193858, -0.013753487943110659, 0.029792955307659512,
protdist.c:  -0.041315887349840485, 0.002376427104771009, 0.015295305238266738,
protdist.c:  -0.004837712531358289, 0.013527413002170084, 0.033860556020292386,
protdist.c:  -0.06823881415866824, -0.06729314886673311, 0.016355028108222914,
protdist.c:  0.023399767521499838, 0.004274668816229367, -0.0029212346062599845,
protdist.c:  0.09577503436099553, -0.11879971776859931},
protdist.c: {0.01925779102601801, 0.009711347466813488, -0.03778095491017673,
protdist.c:  0.02087064997740187, 0.00004370155520335176, -0.032538042143085005,
protdist.c:  0.008229548456067312, 0.0068497019920590796, -0.0035481698807180045,
protdist.c:  0.09600925733114388, -0.1293671545711665, -0.01805893436560895,
protdist.c:  0.0129846019931733, 0.18440740178711504, -0.04738688991162021,
protdist.c:  -0.013913010875502747, -0.059550458481848645, 0.008590765794775305,
protdist.c:  -0.023448375298234153, -0.0013627769418097012},
protdist.c: {-0.0011614155479893053, 0.008374138632152332, -0.08602969813606151,
protdist.c:  0.01618428070838692, -0.0037267876664575576, -0.036185555532887936,
protdist.c:  0.006612965037203697, 0.04254424297092725, -0.01563231128023001,
protdist.c:  0.013623578541869748, 0.025148275498654584, -0.012303674571282851,
protdist.c:  -0.01693479600077672, -0.04093898529585358, -0.046456630445416675,
protdist.c:  -0.010452879136453876, -0.02319653117378551, -0.004289480413052626,
protdist.c: {-0.015113725459035773, -0.006433680010864498, -0.13616818069087142,
protdist.c:  0.007165364605443812, 0.0024621963246728345, -0.01905359687656017,
protdist.c:  -0.08848067590192213, 0.14662081643887498, 0.012032964095981792,
protdist.c:  -0.0028324603575066044, 0.033818632658193785, 0.026797585455107915,
protdist.c:  0.030353427780873986, 0.06998351734355532, -0.005888989655947249,
protdist.c:  -0.05051591792299097, -0.05475146888946158},
protdist.c: {-0.005773100936949497, 0.024170804692645757, 0.021498754882537795,
protdist.c:  0.017262395016750306, -0.004044496016496676, 0.012913081796752797,
protdist.c:  0.0058602806287568815, -0.008924351183253075, -0.14436389890526954,
protdist.c:  -0.04201739639451209, 0.09312161964078457, -0.01844925301869748,
protdist.c:  0.0031250360849192664, 0.024236083380650263, -0.0043267024182858166,
protdist.c:  0.01165681936586893, -0.04867141063827842},
protdist.c: {0.15837771768788678, -0.00011088336830329658, -0.03604825622434168,
protdist.c:  0.0068141985260496175, 0.0021850907000897832, -0.019320487367611185,
protdist.c:  0.004794999066385206, -0.074261881799337, -0.008463426954720866,
protdist.c:  0.10277171685564128, -0.06232932642567465, 0.010349026955305596,
protdist.c:  0.04893622351930656, -0.08039533048305253, 0.01763876364729974,
protdist.c:  -0.0005628336326525686, 0.010919622419898661, 0.002478291892971593,
protdist.c:  0.006903109146312329, -0.09067633416145358},
protdist.c: {-0.056267000053740766, 0.00001559611113659412, -0.06997624645407705,
protdist.c:  -0.0004856327306789596, 0.015782741499842823, -0.032298505419166124,
protdist.c:  0.08152149684959237, -0.15772352469189893, 0.035873997001771005,
protdist.c:  -0.04377966808848243, -0.008136900467978166, 0.08646569195993649,
protdist.c: {-0.028956762786505812, -0.006418089191279312, 0.013355331278774085,
protdist.c:  0.004082472534287727, -0.013017215806988454, -0.05132506920970575,
protdist.c:  -0.0020566757887476475, -0.002549933907223532, -0.02800075007559069,
protdist.c:  -0.020799456084459156, -0.045764196722543754, 0.13014953498877524,
protdist.c:  0.041453984348620895, 0.0032104610951075685, -0.03068344533570832,
protdist.c:  0.01316257816927397, 0.009397744542286122, -0.0020450408063745927,
protdist.c:  -0.005117254195486473, 0.021921782953487866},
protdist.c: {0.11905947480828966, -0.00009122408070787313, -0.02592031519535036,
protdist.c:  0.0002350484193871946, -0.012917264458997395, 0.041727936507362846,
protdist.c:  -0.0004908453430108254, -0.02767056022553318, 0.0007959499465993049,
protdist.c:  -0.17267112232895548, -0.09580347391209115, -0.006248451018826487,
protdist.c:  -0.0029782580007121943, -0.031731110466620895, 0.0018131237083419207,
protdist.c: {-0.022195713696460062, 0.004126734170840236, 0.010930080238354666,
protdist.c:  -0.0016469864386048144, -0.05413030710784895, -0.05372772306304678,
protdist.c:  -0.001453627590607233, -0.004366764018311867, 0.005780751751248882,
protdist.c:  0.019350630598524297, -0.013367942472122864, -0.027476221627427855,
protdist.c:  -0.016768821861146848, 0.00041601740043731625, 0.12528463470256504,
protdist.c:  0.053964632575474694, -0.027896258902860953, 0.0006754919351719815,
protdist.c: {-0.011949017142319038, 0.00041124988456697607, -0.014743972951727937,
protdist.c:  -0.0013526659340555767, -0.04773190327121365, 0.07192322794406533,
protdist.c:  0.034597301049421623, -0.009441391996460581, -0.11090006936483317,
protdist.c:  -0.019733982354485806, -0.03129038972703463, -0.0005590677782725911,
protdist.c:  -0.007699468381066538, -0.037582280599009},
protdist.c: {-0.11800275951635548, 0.00256245081420642, -0.015528201780424496,
protdist.c:  -0.00048230140537089297, 0.013221933827325925, -0.006005755089795161,
protdist.c:  -0.00036568660549255214, 0.010299348338501754, 0.0007617166832344724,
protdist.c:  0.024295558497521255, -0.03576972321222767, -0.0290301134958795,
protdist.c:  0.17666705525000023, -0.042685553399493315, 0.00641493933924015,
protdist.c:  0.07545403577541585, -0.048245978978344276, -0.0027713059043912524,
protdist.c:  -0.00557677653477524, -0.005212882602896438},
protdist.c: {-0.03135660185064353, 0.0029256039204580706, 0.004210743772223673,
protdist.c:  -0.00037531946564787095, -0.013450526099290505, -0.01223262089998042,
protdist.c:  0.004200010319660261, -0.13107035673589032, -0.02730255597380461,
protdist.c:  0.04153224095397977, -0.0038510269311402326, -0.02049935716317613,
protdist.c:  -0.08665194067345698, 0.23866749205737664, 0.002861017825952498,
protdist.c: {-0.01825616713448373, -0.0020756327284446926, -0.002595442703692251,
protdist.c:  0.004860692431037114, 0.00294561175495154, -0.0008213210533982405,
protdist.c:  -0.21777958762651486, -0.07117930060980879, 0.0018682147366780313,
protdist.c:  0.005555757278753163, -0.011002120977473849}};
protdist.c:{0, -0.2984519658202581, -0.3735877750562505,
protdist.c: -0.40326342443650165, -0.4275462791078368, -0.42975546755905614,
protdist.c: -0.47135015336110575, -0.5504367946172593, -0.57640185413455,
protdist.c: -0.6096245220298862, -0.634319098588729, -0.6709446458122243,
protdist.c: -0.7063690245467197, -0.7258254272647924, -0.7457660080667772,
protdist.c: -0.7572751946958909, -0.7885280382111488, -0.8013249709506047,
protdist.c: -0.816432753033377, -0.8266122814253785};
protdist.c:{{-0.08662790433139517, -0.04397200219860013, -0.03908940195447013,
protdist.c:  -0.057045102852255135, -0.019307800965390098, -0.03672810183640525,
protdist.c:  -0.05805890290294535, -0.08325180416259033, -0.02443130122156497,
protdist.c:  -0.04846600242330021, -0.08620900431045043, -0.062028603101430234,
protdist.c:  -0.019502700975135085, -0.03843190192159516, -0.04576310228815513,
protdist.c:  -0.06951790347589525, -0.06101270305063528, -0.014385900719295096,
protdist.c:  -0.035274201763710045, -0.07089560354478038},
protdist.c: {-0.0353432487260441, -0.021505530758913108, -0.025932731055604143,
protdist.c:  -0.05545318409661715, 0.008582700769358057, -0.018812156421006438,
protdist.c:  -0.04558319937488951, -0.11475137880609051, -0.0025060306428045472,
protdist.c:  0.0562801476135858, 0.11948992035408662, -0.03794104566807277,
protdist.c:  0.018543172554928506, 0.08186103551389992, -0.028431648406207728,
protdist.c:  -0.03283433616908361, -0.014523500158627134, 0.032570521382550274,
protdist.c: {-0.015915420511329704, 0.009692435359590253, 0.00733707056430765,
protdist.c:  0.014516410175338501, -0.01142922097156033, 0.0014151462298009228,
protdist.c:  -0.056817719401905414, -0.0841601100058974, 0.003642883343466666,
protdist.c:  -0.016812029275416453, 0.030780081054979515, -0.010686171856182163,
protdist.c:  0.0016494833627142328, -0.018322966527695873, 0.09200973370947656,
protdist.c:  0.053179212168830356, -0.07294554626898914},
protdist.c: {0.013759333298633413, -0.011044774910643478, -0.01054548922245462,
protdist.c:  -0.024542406414697883, 0.1286385406931702, -0.014686969922713391,
protdist.c:  -0.022995901703596583, 0.03981546277066954, -0.013438277903075212,
protdist.c:  -0.0026156891434270277, -0.01719605364983678, -0.022100085463587327,
protdist.c:  -0.0027038562547360393, -0.02726223226367094, -0.016979508141960233,
protdist.c:  0.0053326765865718065, -0.0008379960574059017, 0.0184323927875773,
protdist.c:  -0.027060266092953242, 0.008031101008136131},
protdist.c: {-0.01254519793823637, -0.0009908787652949257, 0.011299091412613578,
protdist.c:  0.006333750904289955, -0.00896673595046517, 0.025036217259614912,
protdist.c:  -0.04584199019188938, -0.06184254509645476, 0.0009491089065080568,
protdist.c:  -0.01344469330991452, 0.08665016158734547, -0.00966343074212289,
protdist.c:  0.004618005598265847, -0.011432857407903152, -0.06323491318530367,
protdist.c:  0.09779646621500009, -0.06002326612260447},
protdist.c: {-0.0016266525745331382, -0.03571616585481501, -0.012864593388218992,
protdist.c:  -0.027956181739045773, -0.02381645137469793, -0.026783789261294978,
protdist.c:  -0.03639534743185881, 0.22793942592080588, -0.0155391138199017,
protdist.c:  0.02091180684719519, 0.03951311713946571, -0.04945549793708711,
protdist.c:  0.005337766553435219, 0.027944334318020563, -0.07575715375023316,
protdist.c:  -0.011634397366523292, -0.01866585157363799, -0.01569290654160444,
protdist.c: {-0.02167491927989601, 0.03126543078215943, 0.025440466494243783,
protdist.c:  0.04850226368389819, -0.048588408253198906, 0.013698388635919363,
protdist.c:  0.00430914445737426, -0.01979784396879971, -0.184201351355039,
protdist.c:  -0.0077607359519451255, 0.0037035775397267685, 0.001262356924065289,
protdist.c:  -0.009639989176310145, 0.008673474254133357},
protdist.c: {-0.02221551267346312, 0.12374836670233941, -0.021699849910208246,
protdist.c:  -0.13661033339596748, -0.0006552216949112155, 0.024585270444916665,
protdist.c:  -0.06339849548091075, 0.030378311586393907, 0.021988258750919438,
protdist.c:  -0.016118509633790558, 0.025338262967055193, 0.09802094176583749,
protdist.c:  0.005372099090136465, -0.007122351839115535, -0.0066637692227581044,
protdist.c:  -0.007835644589739501, -0.00732554509494566, -0.006507510495802753,
protdist.c:  -0.0017851639921132596, -0.03149360328387214},
protdist.c: {-0.0916807385182919, 0.011016309459468855, -0.0020598225581001718,
protdist.c:  -0.04218534118940628, 0.15866697238009075, 0.008368054572756483,
protdist.c:  -0.06075996365676529, -0.0949181212384951, -0.00044801094613308067,
protdist.c:  -0.04529231556005072, -0.09026321917993069},
protdist.c: {-0.05799954304417141, -0.012493490541584575, 0.006793981716528776,
protdist.c:  -0.00612890630650264, 0.023117688863084383, 0.06915553458623389,
protdist.c:  0.0293313384996369, 0.027297592094938088, -0.028932993736102662,
protdist.c:  0.0040820351276770125, -0.12156087736154904, 0.01908902651720602,
protdist.c:  -0.04330588468449417, -0.050930111781680325, -0.0014989376655455476,
protdist.c: {-0.07439341264189382, 0.04427720500137817, -0.021561968047326237,
protdist.c:  0.037793443915451516, 0.026596079808236237, -0.02193683563873892,
protdist.c:  0.07243586108500191, -0.12747646180849487, 0.040274930922826815,
protdist.c:  -0.015142541442547118, 0.038528976593187395, 0.027946468726088993,
protdist.c:  -0.08616602330115625, -0.0871658984721852, -0.00046359573749853416,
protdist.c:  -0.011864713395771715, 0.11365449047896045},
protdist.c: {-0.018676265992530913, -0.03032916723048719, 0.02390946837598704,
protdist.c:  -0.01782911279148313, -0.00010369195213233988, 0.018229248982449653,
protdist.c:  -0.026265592365137015, 0.003493994914378447, 0.12092493225397696,
protdist.c:  0.014175613261994796, -0.03932992215381625, -0.041399350796976965,
protdist.c:  -0.006543171718014073, 0.05346912217213576, 0.000060787295714846686,
protdist.c:  -0.08456609422154902, 0.017998277046062956},
protdist.c: {0.13641427702582373, -0.05607569623992714, -0.07567862880722315,
protdist.c:  -0.07581005560536624, -0.0016253951698452127, 0.07594399327169052,
protdist.c:  0.10609514139584342, -0.004275986391775505, 0.011077529691323619,
protdist.c:  -0.03369849883631017, 0.0014110828390904117, 0.004256412629543203,
protdist.c:  0.0032312078915726974, -0.0011189644241755856, -0.013253866783547516,
protdist.c:  -0.036508812311443976, -0.06016029122853343, 0.0010257570061342508,
protdist.c: {0.14750262415805065, 0.0911309133026857, -0.010696060780615264,
protdist.c:  0.053274645436451856, -0.005568584022893447, -0.04856688673265621,
protdist.c:  -0.04246658894913904, -0.025693701179748056, 0.014149821738870336,
protdist.c:  -0.0238518320717526, 0.03130454468071894, -0.07502626963344665,
protdist.c:  -0.039593836294283306, -0.00028981450762873234, -0.011100109630786765,
protdist.c:  0.022690676714141347, -0.10295386570138826, -0.0016892143324578064,
protdist.c:  -0.005384612345127122, 0.032828150151004966},
protdist.c: {-0.032251170323834844, -0.039820199719605036, 0.021045294937284194,
protdist.c:  -0.02904718811733145, 0.0005253020635774123, 0.00971066636193823,
protdist.c:  0.011158310265606946, 0.004196029762453968, -0.005600610474861128,
protdist.c:  -0.12418179933961741, -0.003356542003955646, -0.0003132971003851252,
protdist.c: {0.06244893561623596, -0.07928960485540668, 0.0837171063441727,
protdist.c:  -0.008668745942896044, -0.0007466305068550615, -0.016649673713913606,
protdist.c:  -0.07088698353000616, -0.012869118355702853, -0.006143718903716753,
protdist.c:  0.0018129436914273362, -0.011455847707142128, 0.125441787391439,
protdist.c:  0.027204607672753695, -0.12141465537341414, 0.0013695067372830692,
protdist.c:  -0.002300309551164875, 0.005661967348716818},
protdist.c: {-0.04712508072900232, 0.023468157192705074, 0.06240142010712506,
protdist.c:  -0.057138895219877486, -0.000893650204252724, 0.075894086172039,
protdist.c:  0.031311997790448624, -0.009092186877369823, -0.030003881385894177,
protdist.c:  0.06302914128271957, -0.015330492210388699, -0.09781633147000987,
protdist.c:  -0.004129938391497053, -0.0020107539165119047, -0.0033503702726770984,
protdist.c:  0.12803684997174333, -0.07496617381765575, -0.0007895004946909288,
protdist.c:  0.000803205648558524, -0.04229760317551147},
protdist.c: {-0.054344442317237944, 0.0076062347542590865, 0.052113382806553775,
protdist.c:  -0.01338060412047799, -0.001841020167889566, 0.04462408290449821,
protdist.c:  -0.01853587256061214, 0.0008466998362577875, -0.01698687995234879,
protdist.c:  -0.14832784903206883, 0.011374199079884949, -0.038698474923225,
protdist.c:  0.000540540905888088, 0.004959358159359442, -0.0005561017266875668,
protdist.c: {-0.07025301505041058, 0.00014556295076810773, -0.023343251086268068,
protdist.c:  -0.05000969932374482, -0.0014384061465977601, -0.11386504039712571,
protdist.c:  0.11768542466472931, -0.0020597266962605817, 0.021798453470143586,
protdist.c:  -0.030879385371217583, 0.00502072260921487, 0.028300880108756872,
protdist.c:  0.010513483575935114, -0.0015762496591778, -0.0017022305709658836,
protdist.c:  0.11508719160450812, -0.03754931341951792, -0.0005882734300546004,
protdist.c:  -0.0041161849921565455, 0.038829057159442244},
protdist.c: {-0.05692477482776453,
protdist.c:  -0.02653319031742664, -0.11737910264279769, 0.07393240388256206,
protdist.c:  -0.001457629722277124, 0.05204268349655665, -0.0828431366755649,
protdist.c:  0.00020430846339690879, 0.004671788553548594, -0.009741060538760074,
protdist.c:  -0.003072722768487825, 0.039698339427595854, -0.0019739169465894726,
protdist.c:  -0.002115387130603613, -0.004653490839902351, 0.13421042672478148,
protdist.c:  -0.02359714019601924, -0.0004044808786225971, 0.0009473370451194571,
protdist.c:{0, -0.2961760821103565, -0.365652626837339,
protdist.c: -0.38671932452970037, -0.42326849325269555, -0.4259265187114145,
protdist.c: -0.46723395913267607, -0.5464912156185182, -0.5747276926396807,
protdist.c: -0.6071328109720598, -0.6339632013794405, -0.6574093763937996,
protdist.c: -0.7044270860238384, -0.7209073186899997, -0.7506866192057006,
protdist.c: -0.7551296747258581, -0.7873932762264586, -0.810913109548552,
protdist.c: -0.8186876881556857, -0.8312217474625978};
protdist.c:  0.05426363213057566, -0.008222771313934937, 0.018809713405152625,
protdist.c:  -0.05370962500323136, -0.11682537170907294, 0.03784956873749698,
protdist.c:  -0.018090959226090976, -0.08213494648355214, 0.028286855860628388,
protdist.c:  0.03219538205560176, 0.015315516810597396, -0.03641081278800719,
protdist.c:  -0.05759474100865529, -0.057516220033223854},
protdist.c: {0.013908508233029233, -0.010741058910567529, -0.007714208965670546,
protdist.c:  -0.015297298394271297, 0.007269236977242451, -0.0018756949033623643,
protdist.c:  -0.006664263825360205, -0.05683568858201999, -0.011043132925220987,
protdist.c:  0.05682644999974395, 0.08796840626023222, -0.004697177080427231,
protdist.c:  0.0172228726525516, -0.02098971126197226, 0.007846410307414477,
protdist.c:  -0.0029840656912848637, 0.01625626156174595, -0.09437754876112107,
protdist.c:  -0.046171262350368926, 0.07209296565968756},
protdist.c: {-0.00974736417078596, 0.009501722363015276, 0.00803738792557657,
protdist.c:  0.019992975630319314, -0.133705276484346, 0.012188355967380203,
protdist.c:  0.01934081137991777, -0.02130857584342068, 0.010519629982552795,
protdist.c:  -0.0064803924513661074, 0.00012234185725716807, -0.008507305861602664,
protdist.c:  0.017744672681987653, -0.0015443320020960233},
protdist.c: {0.017001972980605583, -0.006489906779729108, -0.014677169244502181,
protdist.c:  -0.02328886701554861, -0.02234431907235601, -0.008850785928660137,
protdist.c:  -0.014074219549985632, 0.04166084124372423, -0.0301946523316424,
protdist.c:  0.04940505837763448, 0.06715661004038927, -0.010997957541837291,
protdist.c:  0.014151027692304757, -0.08465823457868984, -0.0013575378347905377,
protdist.c:  -0.004854819281866914, 0.009585577318432533, 0.05806716141178032,
protdist.c:  -0.10143174601847862, 0.06619196611321591},
protdist.c:  0.03646036942777444, -0.22632388532992248, 0.013241927942499966,
protdist.c:  -0.0126519030297753, -0.026892304398424605, 0.05047194826407599,
protdist.c:  -0.0028051221154343025, -0.03964872389239331, 0.0765434455893368,
protdist.c:  -0.022660972140598427, -0.01274527681022342},
protdist.c: {-0.02138020916176656, 0.03425299345673951, 0.024153790058582224,
protdist.c:  0.0482507607323018, -0.04549952579156671, 0.014454806196412361,
protdist.c:  0.0045270227357393335, -0.019332947733614644, -0.18449411930725765,
protdist.c:  -0.010377118224483985, 0.0013477904016434739, 0.0015276819290008386,
protdist.c:  -0.010873853651012295, 0.008615873334457262},
protdist.c: {0.031100196651222392, -0.12976272983272716, 0.02263493389126923,
protdist.c:  0.1296274612540156, -0.0005200921808423665, -0.023617222520153604,
protdist.c:  0.06286851709561977, -0.037127268321369686, -0.023181990407100086,
protdist.c:  0.01581920912219101, -0.03373007238524473, -0.08954171603182612,
protdist.c:  -0.005538475487059034, 0.004988852070652565, 0.00041515481016176714,
protdist.c: {0.0933977986651514, -0.0023762091403083255, 0.0013365608713029496,
protdist.c:  -0.07625410848932684, -0.014229002852796373, -0.018923156288257127,
protdist.c:  -0.05011703568425545, -0.033388769595753216, -0.0013562926640853774,
protdist.c:  0.0370897289935839, -0.15135867581356827, -0.0013749492828959036,
protdist.c:  -0.009968566953669395, -0.02611579119425035, -0.03704208151668012,
protdist.c:  0.06556910987316418, 0.0993718428782822, -0.00020237874125614145,
protdist.c: {0.0508588491496748, 0.02074929064165052, -0.009414272874378668,
protdist.c:  -0.0072050029432371605, -0.0029056780975801875, -0.005832860445956207,
protdist.c:  0.01089598428992686, -0.02148467581340314, -0.08432405046566478,
protdist.c:  -0.02908252531523741, -0.025629155791888698, 0.03589911036403491,
protdist.c:  -0.004158109843488059, 0.117564615584532, -0.016372687851348027,
protdist.c:  -0.07976525698973493, -0.031275996481797505},
protdist.c: {0.06464821330000899, -0.045286836663020184, 0.022896515019620173,
protdist.c:  -0.03061399329901384, -0.004724997500200521, -0.006785048270169905,
protdist.c:  -0.04014230346906003, -0.025295996131222423, 0.03325886214518461,
protdist.c:  -0.07349325440413453, 0.12744615710956125, -0.0359545987765727,
protdist.c:  0.012075402272480638, -0.023149650954854488, -0.028060336091316036,
protdist.c:  -0.0069083221755481955, -0.11684257749491975},
protdist.c: {0.013188712339840179, 0.025201546418153985, -0.01547116623524057,
protdist.c:  0.014048232951367411, -0.0004637616612669842, -0.01296275494490237,
protdist.c:  0.01925668907566004, -0.004200259245120385, -0.1095595432010714,
protdist.c:  -0.019302206061052752, 0.06104824533764773, 0.030302612215077566,
protdist.c:  0.00824836617423615, -0.07171111440266659, -0.0010333159680584465,
protdist.c:  0.004100219597481443, 0.0009441069369101624, -0.004033691341645613,
protdist.c:  0.09439486033276029, -0.031995778318109944},
protdist.c: {0.14297590994888154, -0.060680069216447474, -0.06973359032178301,
protdist.c:  -0.079385622621617, -0.0007449896720260359, 0.07692939457844014,
protdist.c:  0.09612418820143483, -0.005046310211767643, 0.00881332482064309,
protdist.c:  -0.0328952332317771, 0.00303725067794282, 0.017858974511086975,
protdist.c:  0.0020502868715589007, -0.0022060400797726904, -0.012470540858441098,
protdist.c:  -0.038547511534476046, -0.06356694815755778, 0.0010329335178927113,
protdist.c: {0.15461363123683958, 0.09796606687140999, -0.018215739459978716,
protdist.c:  0.05708269930294891, -0.004457887921182733, -0.05120795121552961,
protdist.c:  -0.030743349448867707, -0.025680743430060358, 0.013277648416397534,
protdist.c:  -0.02499476979565829, 0.023452872369277757, -0.09634376653153451,
protdist.c:  -0.023243876300254974, -0.00027382354224944546, -0.010476648413065363,
protdist.c:  0.010957598150794189, -0.08833475650934149, -0.0016910539222819028,
protdist.c:  -0.004026274488594908, 0.022340124630932986},
protdist.c: {0.02932380292890195, -0.05662966832020375, 0.05692339520018425,
protdist.c:  -0.011678029942641017, -0.0005390228218326405, -0.025949292388766497,
protdist.c:  -0.04330090400031425, -0.00685318295788398, -0.0025826092550182743,
protdist.c:  -0.0019840557360376026, 0.05959797696140827, 0.11363016187151163,
protdist.c:  -0.0941597103666233, -0.0021204494101853435, -0.000591497562243158,
protdist.c:  0.014424533762850206, -0.05990614400933401, 0.0010052536287629345,
protdist.c:  -0.00046915230824770446, 0.03185859472571239},
protdist.c: {-0.07127161064708971, 0.04008378242135459, -0.049505006163237684,
protdist.c:  -0.016180042487676606, 0.0003642467751329144, 0.03919260676511212,
protdist.c:  0.06590338394002404, 0.011654251492515852, -0.001575424458406114,
protdist.c:  0.0013775083805891326, 0.049027613056853755, -0.08793537574291099,
protdist.c:  -0.09003800568993192, -0.0015668629704929092, -0.001507158751259746,
protdist.c:  -0.0020990694072859878, 0.09442150867183564, -0.0008099928123995563,
protdist.c: {0.031827000793683266, -0.008980150796867165, -0.0814125469083036,
protdist.c:  0.04017629513013613, 0.0017340891665920514, -0.10103712010989731,
protdist.c:  -0.031274338581653426, 0.014546895520865697, 0.08382029516304329,
protdist.c:  -0.11566371882457122, 0.09046972657748834, 0.0005863046894871563,
protdist.c: {-0.013252155931930161, -0.0020087005643413675, 0.030844331179362014,
protdist.c:  0.027207484416002296, -0.0007806321125681434, 0.05889234364898691,
protdist.c:  -0.07250627377161177, 0.0035140587683799244, -0.01234225184768643,
protdist.c:  -0.14106845444653254, 0.01145560777956954, -0.013280996346456448,
protdist.c:  -0.06548765996486455, 0.03345642853759085, -0.00012797423882209658,
protdist.c: {-0.07595946442342082, 0.007807949526305038, 0.01579533203463662,
protdist.c:  -0.06687355235759444, -0.002083298571554414, -0.08376134249484893,
protdist.c:  0.11563215140325152, -0.0027686944696296554, 0.009061081411616084,
protdist.c:  -0.07908871694199837, 0.007708359113299237, -0.0029720288262342245,
protdist.c:  0.015633366477761538, -0.0009759708837499167, -0.0013625200711269959,
protdist.c:  0.10130997497899956, -0.039905002719783866, -0.000729477240624516,
protdist.c:  -0.0030357030316818055, 0.08656755708637867},
protdist.c: {-0.05429703937350998, -0.021867453707076184, -0.12564670875939996,
protdist.c:  0.07181163355889429, -0.0018167330492840166, 0.027826226325725845,
protdist.c:  -0.06649246159416587, -0.0005645161894281465, 0.00929303057159789,
protdist.c:  -0.013365448768531608, -0.002482959226404254, 0.047050626252299096,
protdist.c:  0.00020413104847392702, -0.0021653157344375287, -0.005541649439729806,
protdist.c:  0.14203499202174216, -0.03278527956210416, -0.0005241573294822634,
protdist.c:    exxit(-1);
protdist.c:        str = "Jones-Taylor-Thornton matrix";
protdist.c:    printf("  L                      Form of distance matrix?  %s\n", lower ? "Lower-triangular" : "Square");
protdist.c:        /* One category: Yes -> Gamma -> Gamma+Invar -> Yes */
protdist.c:  /* calculations related to transition-transversion ratio */
protdist.c:  aa = ttratio * freqr * freqy - freqa * freqg - freqc * freqt;
protdist.c:  xv = 1.0 - xi;
protdist.c:  if (xi <= 0.0 && xi >= -epsilon)
protdist.c:    printf("THIS TRANSITION-TRANSVERSION RATIO IS IMPOSSIBLE WITH");
protdist.c:    exxit(-1);}
protdist.c:    fprintf(outfile, "%ld", category[i - 1]);
protdist.c:        fprintf(outfile, "  Jones-Taylor-Thornton model distance\n");
protdist.c:      fprintf(outfile, "%15ld%13.3f\n", i, rate[i - 1]);
protdist.c:  j = nmlngth + (chars + (chars - 1) / 10) / 2 - 5;
protdist.c:  if (j < nmlngth - 1)
protdist.c:    j = nmlngth - 1;
protdist.c:    fprintf(outfile, "----");
protdist.c:    fprintf(outfile, "---------\n\n");
protdist.c:    /* eat white space -- if the separator line has spaces on it*/
protdist.c:        initname(i-1);
protdist.c:               charstate != '-' && charstate != '*') || charstate == 'J' ||
protdist.c:            printf("ERROR -- bad amino acid: %c at position %ld of species %3ld\n",
protdist.c:              printf("         The correct gap character is (-).\n");
protdist.c:            exxit(-1);
protdist.c:            case '-':
protdist.c:          gnode[i - 1][j - 1] = aa;
protdist.c:        exxit(-1);}
protdist.c:    for (i = 1; i <= ((chars - 1) / 60 + 1); i++)
protdist.c:          putc(nayme[j - 1][k], outfile);
protdist.c:        for (k = (i - 1) * 60 + 1; k <= l; k++)
protdist.c:          if (j > 1 && gnode[j - 1][k - 1] == gnode[0][k - 1])
protdist.c:            switch (gnode[j - 1][k - 1])
protdist.c:                charstate = '-';
protdist.c:    sumrates += oldweight[i] * rate[category[i] - 1];
protdist.c:  cat[(long)cys - (long)ala] = 1;
protdist.c:  cat[(long)met - (long)ala] = 2;
protdist.c:  cat[(long)val - (long)ala] = 3;
protdist.c:  cat[(long)leu - (long)ala] = 3;
protdist.c:  cat[(long)ileu - (long)ala] = 3;
protdist.c:  cat[(long)gly - (long)ala] = 4;
protdist.c:  cat[(long)ser - (long)ala] = 4;
protdist.c:  cat[(long)thr - (long)ala] = 4;
protdist.c:  cat[(long)pro - (long)ala] = 5;
protdist.c:  cat[(long)phe - (long)ala] = 6;
protdist.c:  cat[(long)tyr - (long)ala] = 6;
protdist.c:  cat[(long)trp - (long)ala] = 6;
protdist.c:  cat[(long)glu - (long)ala] = 7;
protdist.c:  cat[(long)gln - (long)ala] = 7;
protdist.c:  cat[(long)asp - (long)ala] = 7;
protdist.c:  cat[(long)asn - (long)ala] = 7;
protdist.c:  cat[(long)lys - (long)ala] = 8;
protdist.c:  cat[(long)arg - (long)ala] = 8;
protdist.c:  cat[(long)his - (long)ala] = 8;
protdist.c:                                aromatic, acid/acid-amide/hydrophilic, basic */
protdist.c:      if (cat[(long)b - (long)ala] == 3)
protdist.c:        cat[(long)b - (long)ala] = 2;
protdist.c:      if (cat[(long)b - (long)ala] == 5)
protdist.c:        cat[(long)b - (long)ala] = 4;
protdist.c:      if (cat[(long)b - (long)ala] == 2)
protdist.c:        cat[(long)b - (long)ala] = 1;
protdist.c:      if (cat[(long)b - (long)ala] == 4)
protdist.c:        cat[(long)b - (long)ala] = 3;
protdist.c:    if (cat[(long)b - (long)ala] == 3)
protdist.c:      cat[(long)b - (long)ala] = 2;
protdist.c:               + xv * (1 - freqt*freqt - freqc*freqc
protdist.c:                         - freqa*freqa - freqg*freqg);
protdist.c:              x *= xv * f[n - 1];
protdist.c:              x *= xi * f[n - 1] / g[n - 1] + xv * f[n - 1];
protdist.c:            b2 = trans[newsub[0] - 1][newsub[1] - 1][newsub[2] - 1];
protdist.c:              nb1 = numaa[(long)b1 - (long)ala];
protdist.c:              pie[nb1 - 1] += x;
protdist.c:                nb2 = numaa[(long)b2 - (long)ala];
protdist.c:                if (cat[(long)b1 - (long)ala] != cat[(long)b2 - (long)ala]) {
protdist.c:                  prob[nb1 - 1][nb2 - 1] += x * ease;
protdist.c:                  prob[nb1 - 1][nb1 - 1] += x * (1.0 - ease);
protdist.c:                  prob[nb1 - 1][nb2 - 1] += x;
protdist.c:                prob[nb1 - 1][nb1 - 1] += x;
protdist.c:    prob[i][i] -= pie[i];
protdist.c:  /* computes pi^(1/2)*B*pi^(-1/2)  */
protdist.c:      d = ctheta * prob[i - 1][k] + stheta * prob[j - 1][k];
protdist.c:      prob[j - 1][k] = ctheta * prob[j - 1][k] - stheta * prob[i - 1][k];
protdist.c:      prob[i - 1][k] = d;
protdist.c:      d = ctheta * prob[k][i - 1] + stheta * prob[k][j - 1];
protdist.c:      prob[k][j - 1] = ctheta * prob[k][j - 1] - stheta * prob[k][i - 1];
protdist.c:      prob[k][i - 1] = d;
protdist.c:      coeffs(prob[i - 2][i - 1], prob[i - 2][j - 1], &c, &s, accuracy);
protdist.c:{ /* QR eigenvalue-finder */
protdist.c:  for (i = n; i >= 2; i--) {
protdist.c:      TEMP = prob[i - 2][i - 2] - prob[i - 1][i - 1];
protdist.c:      TEMP1 = prob[i - 1][i - 2];
protdist.c:      approx = prob[i - 2][i - 2] + prob[i - 1][i - 1];
protdist.c:      if (prob[i - 1][i - 1] < prob[i - 2][i - 2])
protdist.c:        approx = (approx - d) / 2.0;
protdist.c:        prob[j][j] -= approx;
protdist.c:        coeffs(prob[j - 1][j - 1], prob[j][j - 1], &c, &s, accuracy);
protdist.c:    } while (fabs(prob[i - 1][i - 2]) > accuracy);
protdist.c:  double accuracy = 1.0e-6;
protdist.c:      elambdat = exp(-cvi*log(1.0-rate[cat-1]*tt*(eig[m]/(1.0-invarfrac))/cvi));
protdist.c:      elambdat = exp(rate[cat-1]*tt * eig[m]);
protdist.c:    q = prob[m][nb1 - 1] * prob[m][nb2 - 1] * elambdat;
protdist.c:      dp += rate[cat-1]*eig[m] * q;
protdist.c:      dp += (rate[cat-1]*eig[m]/(1.0-rate[cat-1]*tt*(eig[m]/(1.0-invarfrac))/cvi)) * q;
protdist.c:      d2p += (rate[cat-1]*rate[cat-1]*eig[m]*eig[m]*(1.0+1.0/cvi)/
protdist.c:              ((1.0-rate[cat-1]*tt*eig[m]/cvi)
protdist.c:               *(1.0-rate[cat-1]*tt*eig[m]/cvi))) * q;
protdist.c:    p *= (1.0 - invarfrac);
protdist.c:  dp *= (1.0 - invarfrac);
protdist.c:  d2p *= (1.0 - invarfrac);
protdist.c:    for (j = 0; j <= i - 1; j++) {
protdist.c:                nb1 = numaa[(long)b1 - (long)ala];
protdist.c:                nb2 = numaa[(long)b2 - (long)ala];
protdist.c:                  curv += oldweight[k]*(d2p / p - dp * dp / (p * p));
protdist.c:            printf("\nWARNING: NO OVERLAP BETWEEN SEQUENCES %ld AND %ld; -1.0 WAS WRITTEN\n", i+1, j+1);
protdist.c:            tt = -1.0/fracchange;
protdist.c:              tt -= slope / curv;
protdist.c:                printf("\nWARNING: INFINITE DISTANCE BETWEEN SPECIES %ld AND %ld; -1.0 WAS WRITTEN\n", i+1, j+1);
protdist.c:                tt = -1.0/fracchange;
protdist.c:                delta /= -2;
protdist.c:            delta /= -2;
protdist.c:        p = 1 - (double)m / n;
protdist.c:          dp = 1.0 - p - 0.2 * p * p;
protdist.c:            tt = -1.0;
protdist.c:            tt = -log(dp);
protdist.c:          tt = 1.0 - p;
protdist.c:      maketrans();              /* re-sets fracchange */
protpars.c:/* Version 4.0. (c) Copyright 1993-2013 by the University of Washington.
protpars.c:#define TEST2 fprintf(outfile, "\nrequires a total of %10.3f\n", curtree->score / -10)
protpars.c:#define TEST3(x) fprintf(outfile, "score(%c)=%g\n", x, t->score)
protpars.c:#define TEST4 if(root) for(i=0;i<endsite;i++) printf("%d ", ((pars_node*)root)->numsteps[i])
protpars.c:#define TEST7a fprintf(outfile, "site[%d] = %d ", i, ((protpars_node*)r)->siteset[i][0])
protpars.c:#define TEST7b fprintf(outfile, "site[%d] = %d ", i, ((protpars_node*)r)->siteset[i][1])
protpars.c:#define TEST7c fprintf(outfile, "site[%d] = %d ", i, ((protpars_node*)r)->siteset[i][2])
protpars.c:                      i, hypset[i], ((protpars_node*)r->next->back)->siteset[i], \
protpars.c:                      ((protpars_node*)r->next->next->back)->siteset[i], temparray->seq[i], k)
protpars.c:sitearray translate[(long)quest - (long)ala + 1];
protpars.c:  t->nuview = protpars_tree_nuview;
protpars.c:  t->evaluate = protpars_tree_evaluate;
protpars.c:  node->init = protpars_node_init;
protpars.c:  if ( n != NULL && n->seq != NULL )
protpars.c:    free(n->seq);
protpars.c:  n->seq =  (aas*)Malloc(chars * sizeof(aas));
protpars.c:  if ( n->siteset)
protpars.c:    free(n->siteset);
protpars.c:  n->siteset = (seqptr)Malloc(chars * sizeof(sitearray));
protpars.c:  /* this and the following are do-it-yourself garbage collectors.
protpars.c:    free((*p)->seq);
protpars.c:    (*p)->seq = (seqptr)Malloc(chars * sizeof(sitearray));
protpars.c:    garbage = garbage->next;
protpars.c:    (*p)->seq = (seqptr)Malloc(chars * sizeof(sitearray));
protpars.c:  (*p)->next = NULL;
protpars.c:  /* collect garbage on p -- put it on front of garbage list */
protpars.c:  p->next = garbage;
protpars.c:    translate[(long)a - (long)ala][0] = 1L << ((long)a);
protpars.c:    translate[(long)a - (long)ala][1] = 1L << ((long)a);
protpars.c:  translate[(long)del - (long)ala][1] = 1L << ((long)del);
protpars.c:  fulldel = (1L << ((long)stop + 1)) - (1L << ((long)ala));
protpars.c:  translate[(long)asx - (long)ala][0]
protpars.c:  translate[(long)glx - (long)ala][0]
protpars.c:  translate[(long)ser - (long)ala][0]
protpars.c:  translate[(long)unk - (long)ala][0] = fullset;
protpars.c:  translate[(long)quest - (long)ala][0] = fulldel;
protpars.c:  translate[(long)asx - (long)ala][1] = translate[(long)asn - (long)ala][1]
protpars.c:                                       | translate[(long)asp - (long)ala][1];
protpars.c:  translate[(long)glx - (long)ala][1] = translate[(long)gln - (long)ala][1]
protpars.c:                                       | translate[(long)glu - (long)ala][1];
protpars.c:  translate[(long)ser - (long)ala][1] = translate[(long)ser1 - (long)ala][1]
protpars.c:                                       | translate[(long)ser2 - (long)ala][1];
protpars.c:  translate[(long)unk - (long)ala][1] = fullset;
protpars.c:  translate[(long)quest - (long)ala][1] = fulldel;
protpars.c:      if (((1L << ((long)b)) & translate[(long)a - (long)ala][1]) != 0)
protpars.c:        s |= translate[(long)b - (long)ala][1];
protpars.c:    translate[(long)a - (long)ala][2] = s;
protpars.c:      printf("  .  Use dot-differencing to display them  %s\n",
protpars.c:    curtree->nodep[i]->init(curtree->nodep[i], i<spp, i);
protpars.c:      p = curtree->nodep[i]->next;
protpars.c:      while (p != curtree->nodep[i])
protpars.c:        p->init(p, false, i);
protpars.c:        p = p->next;
protpars.c:    bestrees[i - 1].btree = (long *)Malloc(spp * sizeof(long));
protpars.c:    headings(chars, "Sequences", "---------");
protpars.c:    /* eat white space -- if the separator line has spaces on it*/
protpars.c:        initname(i - 1);
protpars.c:               charstate != '-' && charstate != '*') || charstate == 'J' ||
protpars.c:            printf("WARNING -- BAD AMINO ACID:%c", charstate);
protpars.c:            exxit(-1);
protpars.c:            (charstate == '-') ? del  :  aa;
protpars.c:          ((protpars_node*)curtree->nodep[i - 1])->seq[j - 1] = aa;
protpars.c:          memcpy(((protpars_node*)curtree->nodep[i - 1])->siteset[j - 1], translate[(long)aa - (long)ala], sizeof(sitearray));
protpars.c:        exxit(-1);
protpars.c:    for (i = 1; i <= ((chars - 1) / 60 + 1); i++)
protpars.c:          putc(nayme[j - 1][k], outfile);
protpars.c:        for (k = (i - 1) * 60 + 1; k <= l; k++)
protpars.c:          if (j > 1 && ((protpars_node*)curtree->nodep[j - 1])->seq[k - 1] == ((protpars_node*)curtree->nodep[0])->seq[k - 1])
protpars.c:            tmpa = ((protpars_node*)curtree->nodep[j-1])->seq[k-1];
protpars.c:              (tmpa == del) ? '-' :
protpars.c:    ((node*)t->nodep[i - 1])->back = NULL;
protpars.c:    ((node*)t->nodep[i - 1])->tip = (i <= spp);
protpars.c:    ((node*)t->nodep[i - 1])->index = i;
protpars.c:      ((pars_node*)t->nodep[i - 1])->numsteps[j] = 0;
protpars.c:      p = ((node*)t->nodep[i - 1])->next;
protpars.c:      while (p != ((node*)t->nodep[i - 1]))
protpars.c:        p->back = NULL;
protpars.c:        p->tip = false;
protpars.c:        p->index = i;
protpars.c:          ((pars_node*)p)->numsteps[j] = 0;
protpars.c:        p = p->next;
protpars.c:  protpars_node *q = (protpars_node*)p->back;
protpars.c:    sum += ((pars_node*)p)->numsteps[m];
protpars.c:    sum += ((pars_node*)q)->numsteps[m];
protpars.c:    base[0] = q->siteset[m][0] & r->siteset[m][0];
protpars.c:    base[0] = (q->siteset[m][0] & r->siteset[m][1]) |
protpars.c:      (q->siteset[m][1] & r->siteset[m][0]);
protpars.c:    base[0] = (q->siteset[m][0] & r->siteset[m][2]) |
protpars.c:      (q->siteset[m][1] & r->siteset[m][1]) |
protpars.c:      (q->siteset[m][2] & r->siteset[m][2]);
protpars.c:  t->score = -sum;
protpars.c:  return -sum;
protpars.c:  protfillin(p, p->next->back, p->next->next->back);
protpars.c:      memcpy(ls, ((protpars_node*)left)->siteset[m], sizeof(sitearray));
protpars.c:      memcpy(rs, ((protpars_node*)rt)->siteset[m], sizeof(sitearray));
protpars.c:      n = ((pars_node*)rt)->numsteps[m];
protpars.c:      n = ((pars_node*)left)->numsteps[m];
protpars.c:      n = ((pars_node*)left)->numsteps[m] + ((pars_node*)rt)->numsteps[m];
protpars.c:                qs[j] |= translate[(long)aa - (long)ala][j-i];
protpars.c:    ((pars_node*)p)->numsteps[m] = n;
protpars.c:    memcpy(((protpars_node*)p)->siteset[m], qs, sizeof(sitearray));
protpars.c:  if (p != NULL && !p->tip)
protpars.c:    protfillin (p->next, p->next->next->back, p->back);
protpars.c:    protfillin (p->next->next, p->back, p->next->back);
protpars.c:    protpreorder (p->next->back);
protpars.c:    protpreorder (p->next->next->back);
protpars.c:  if (outgroup->back->index == curtree->root->index)
protpars.c:  p = curtree->root->next;
protpars.c:  q = curtree->root->next->next;
protpars.c:  p->back->back = q->back;
protpars.c:  q->back->back = p->back;
protpars.c:  p->back = outgroup;
protpars.c:  q->back = outgroup->back;
protpars.c:  outgroup->back->back = q;
protpars.c:  outgroup->back = p;
protpars.c:  /* recursive procedure adds nodes to user-defined tree */
protpars.c:    if ((*lparens) >= spp - 1)
protpars.c:      exxit(-1);
protpars.c:    q = curtree->nodep[(*nextnode) - 1];
protpars.c:    protaddelement(&q->next->back, nextnode, lparens, names, ch);
protpars.c:    q->next->back->back = q->next;
protpars.c:    protaddelement(&q->next->next->back, nextnode, lparens, names, ch);
protpars.c:    q->next->next->back->back = q->next->next;
protpars.c:    str[n - 1] = *ch;
protpars.c:      found = (found && ((str[i] == nayme[n - 1][i]) ||
protpars.c:                         ((nayme[n - 1][i] == '_') && (str[i] == ' '))));
protpars.c:      if (names[n - 1] == false)
protpars.c:        *p = curtree->nodep[n - 1];
protpars.c:        names[n - 1] = true;
protpars.c:        printf("\nERROR IN USER TREE: DUPLICATE NAME FOUND -- ");
protpars.c:          putchar(nayme[n - 1][i]);
protpars.c:        exxit(-1);
protpars.c:  /* read in user-defined tree and set it up */
protpars.c:  curtree->root = curtree->nodep[spp];
protpars.c:  curtree->root->back = NULL;
protpars.c:  protaddelement(&curtree->root, &nextnode, &lparens, names, &ch);
protpars.c:        n = i - 3;
protpars.c:      for (j = n; j <= (i - n); j++)
protpars.c:        for (m = n; m <= (i - j - n); m++)
protpars.c:          if (i - j - m < 3)
protpars.c:            sb &= c[i - j - m];
protpars.c:          d[j] |= translate[(long)aa - (long)ala][j - i];
protpars.c:    fprintf(outfile, "%3ld   ", r->back->index - spp);
protpars.c:  if (r->tip)
protpars.c:      putc(nayme[r->index - 1][i], outfile);
protpars.c:    fprintf(outfile, "%4ld      ", r->index - spp);
protpars.c:  for (i = b1 - 1; i < b2; i++)
protpars.c:    aa = ((protpars_node*)r)->seq[i];
protpars.c:        ch = '-';
protpars.c:      dot = (((protpars_node*)r)->siteset[i] [0] ==
protpars.c:             ((protpars_node*)curtree->nodep[r->back->index - 1])->siteset[i][0]
protpars.c:             || ((((protpars_node*)r)->siteset[i][0] &
protpars.c:                 (((protpars_node*)curtree->nodep[r->back->index - 1]) ->siteset[i] [0] &
protpars.c:  for (i = b1 - 1; i < b2; i++)
protpars.c:    if (!r->tip)
protpars.c:      protancestset(hypset[i], ((protpars_node*)r->next->back)->siteset[i], ((protpars_node*)r->next->next->back)->siteset[i], temparray->seq[i], k);
protpars.c:      memcpy(((protpars_node*)r)->siteset[i], temparray->seq[i], sizeof(sitearray));
protpars.c:      anc = ((protpars_node*)curtree->nodep[r->back->index - 1])
protpars.c:        ->siteset[i][0];
protpars.c:    if (!r->tip)
protpars.c:      hset = ((protpars_node*)r)->siteset[i][0];
protpars.c:      ((protpars_node*)r)->seq[i] = quest;
protpars.c:          ((protpars_node*)r)->seq[i] = aa;
protpars.c:        ((protpars_node*)r)->seq[i] = asx;
protpars.c:        ((protpars_node*)r)->seq[i] = glx;
protpars.c:        ((protpars_node*)r)->seq[i] = ser;
protpars.c:        ((protpars_node*)r)->seq[i] = unk;
protpars.c:    nonzero = (nonzero || (((protpars_node*)r)->siteset[i][0] & anc) == 0);
protpars.c:    maybe = (maybe || ((protpars_node*)r)->siteset[i][0] != anc);
protpars.c:  if (!r->tip)
protpars.c:    memcpy(temparray->seq, ((protpars_node*)r->next->back)->siteset, chars * sizeof(sitearray));
protpars.c:    for (i = b1 - 1; i < b2; i++)
protpars.c:      protancestset(hypset[i], ((protpars_node*)r->next->next->back)->siteset[i], nothing, ancset->seq[i], k);
protpars.c:    prothyptrav(r->next->back, ancset->seq, b1, b2, k, bottom, nothing );
protpars.c:    for (i = b1 - 1; i < b2; i++)
protpars.c:      protancestset(hypset[i], temparray->seq[i], nothing, ancset->seq[i], k);
protpars.c:    prothyptrav(r->next->next->back, ancset->seq, b1, b2, k, bottom, nothing);
protpars.c:  memcpy(nothing, translate[(long)quest - (long)ala], sizeof(sitearray));
protpars.c:  for (i = 1; i <= ((chars - 1) / 40 + 1); i++)
protpars.c:    prothyptrav(curtree->root, hypset, i * 40 - 39, n, k, &bottom, nothing);
protpars.c:    fprintf(outfile, "\nrequires a total of %10.3f\n", -(curtree->score));
protpars.c:    treeout(curtree->root, nextree, &col, curtree->root);
protpars.c:  /* constructs a binary tree from the pointers in curtree->nodep.
protpars.c:          sprintf(progbuf, "-");
protpars.c:          fprintf(outfile, "%6ld trees in all found\n", nextree - 1);
protpars.c:      for (i = 0; i <= (nextree - 2); i++)
protpars.c:        curtree->evaluate(curtree, curtree->root, 0);
protpars.c:        curtree->root = root_tree(curtree, curtree->root);
protpars.c:        protreroot(curtree->nodep[outgrno - 1]);
protpars.c:        reroot_tree(curtree, curtree->root); // RSGbugfix: Name change.
protpars.c:    /* Open in binary: ftell() is broken for UNIX line-endings under WIN32 */
protpars.c:      fprintf(outfile, "User-defined tree");
protpars.c:        protreroot(curtree->nodep[outgrno - 1]);
protpars.c:      curtree->evaluate(curtree, curtree->root, 0);
protpars.c:  fprintf(f, "t->score=%f\n", t->score);
protpars.c:  if(t->root) fprintf(f, "t->root=%p (%ld)\n", t->root, t->root->index);
protpars.c:  fprintf(f, "t->spp=%ld\n", t->spp);
protpars.c:  fprintf(f, "t->nonodes=%ld\n", t->nonodes);
protpars.c:  fprintf(f, "\n-------------------------------------\n");
protpars.c:    p=t->nodep[i];
protpars.c:    if(p) fprintf(f, "nodep[%d]->index=%ld\n", i, p->index);
protpars.c:    fprintf(f, "t->nodep[%d]=%p\n", i, p);
protpars.c:    if(p && p->nayme && p->nayme[0]) fprintf(f, "nodep[%d]->nayme=%s\n", i, p->nayme);
protpars.c:    if(p && p->back) fprintf(f, "nodep[%d]->back=%p (%ld)\n", i, p->back, p->back->index);
protpars.c:    if(p && p->next) fprintf(f, "nodep[%d]->next=%p (%ld)\n", i, p->next, p->next->index);
protpars.c:    if(p && p->next && p->next->back)
protpars.c:      fprintf(f, "nodep[%d]->next->back=%p (%ld)\n", i, p->next->back, p->next->back->index);
protpars.c:    if(q) q=q->next;
protpars.c:    if(q) q=q->next;
protpars.c:      for(j=2; q && q!=p && j<20; q=q->next, j++)
protpars.c:        for(k=0; k<j; k++) fprintf(f, "->next");
protpars.c:        fprintf(f, "=%p (%ld)\n", q, q->index);
protpars.c:        if(!q->back) continue;
protpars.c:        for(k=0; k<j; k++) fprintf(f, "->next");
protpars.c:        fprintf(f, "->back=%p (%ld)\n", q->back, q->back->index);
protpars.c:    if(p) q=p->next;
protpars.c:      for(j=1; j<20; q=q->next, j++)
protpars.c:        if(!q->back) continue;
protpars.c:        for(k=0; k<j; k++) fprintf(f, "->next");
protpars.c:        fprintf(f, "->back=%p (%ld)\n", q->back, q->back->index);
protpars.c:    if(p) q=p->next;
protpars.c:      for(j=1; j<20; q=q->next, j++)
protpars.c:          fprintf(f, "->next");
protpars.c:          fprintf(f, "=%p (%ld)\n", q, q->index);
protpars.c:      fprintf(f, "nodep[%d]->tip=%d\n", i, p->tip);
protpars.c:    fprintf(f, "\n-------------------------------------\n");
rest_common.c:/* Version 4.0. (c) Copyright 2012-2013 by the University of Washington.
rest_common.c:        tied = (tied && inputSequences[k - 1][alias[i] - 1] == inputSequences[k - 1][alias[j] - 1]);
rest_common.c:    i = j - 1;
rest_common.c:      j = i - gap;
rest_common.c:          flip = (inputSequences[k - 1][jj - 1] > inputSequences[k - 1][jg - 1]);
rest_common.c:          tied = (tied && inputSequences[k - 1][jj - 1] == inputSequences[k - 1][jg - 1]);
rest_common.c:        j -= gap;
restdist.c:/* Version 4.0. (c) Copyright 1994-2013 by the University of Washington.
restdist.c:    exxit(-1);
restdist.c:    printf("  L                  Form of distance matrix?  %s\n", (lower ? "Lower-triangular" : "Square"));
restdist.c:  xi = (ttratio - 0.5)/(ttratio + 0.5);
restdist.c:  xv = 1.0 - xi;
restdist.c:      exxit(-1);
restdist.c:      exxit(-1);
restdist.c:  if(fscanf(infile, "%*[ 0-9]") < 0)    // RSGnote: How many values must be read?
restdist.c:    exxit(-1);
restdist.c:  j = nmlngth + (sites + (sites - 1) / 10) / 2 - 5;
restdist.c:  if (j < nmlngth - 1)
restdist.c:    j = nmlngth - 1;
restdist.c:    fprintf(outfile, "----");
restdist.c:    fprintf(outfile, "-----\n\n");
restdist.c:    /* eat white space -- if the separator line has spaces on it*/
restdist.c:        initname(i - 1);
restdist.c:          if (ch != '1' && ch != '0' && ch != '+' && ch != '-' && ch != '?') {
restdist.c:            printf(" ERROR -- Bad symbol %c", ch);
restdist.c:            exxit(-1);
restdist.c:            ch = '-';
restdist.c:          inputSequences[i - 1][j - 1] = ch;
restdist.c:        exxit(-1);
restdist.c:    for (i = 1; i <= ((sites - 1) / 60 + 1); i++) {
restdist.c:        for (k = (i - 1) * 60 + 1; k <= l; k++) {
restdist.c:          putc(inputSequences[j][k - 1], outfile);
restdist.c:    if ((inputSequences[m-1][ii-1] == '+') ||
restdist.c:        (inputSequences[n-1][ii-1] == '+')) {
restdist.c:      if ((inputSequences[m-1][ii-1] == '+') && (inputSequences[n-1][ii-1] == '+')) {
restdist.c:    if (exp(-sitelength*1.38629436) > f) {
restdist.c:      exxit(-1);
restdist.c:      f = (sqrt(f*(f+8.0))-f)/2.0;
restdist.c:        g = exp(0.25*log(f * (3-2*g)));
restdist.c:        delta = g - h;
restdist.c:    vv = - (2.0/sitelength) * log(g);
restdist.c:      vv = -(3.0/2.0)*log((4.0/3.0)*pp - (1.0/3.0));
restdist.c:          p1 = exp(-cvi * log(1 + tt / cvi));
restdist.c:          p2 = exp(-cvi * log(1 + xv * tt / cvi))
restdist.c:            - exp(-cvi * log(1 + tt / cvi));
restdist.c:          p3 = 1.0 - exp(-cvi * log(1 + xv * tt / cvi));
restdist.c:          p1 = exp(-tt);
restdist.c:          p2 = exp(-xv * tt) - exp(-tt);
restdist.c:          p3 = 1.0 - exp(-xv * tt);
restdist.c:        g = q1 - pp;
restdist.c:          delta = fabs(delta) / -2.0;
restdist.c:        sprintf(progbuf, "%c", nayme[i - 1][j]);
restdist.c:      d[i - 1][j - 1] = v;
restdist.c:      d[j - 1][i - 1] = v;
restdist.c:      sprintf(progbuf, "%c", nayme[spp - 1][j]);
restdist.c:  xi = (ttratio - 0.5)/(ttratio + 0.5);
restdist.c:  xv = 1.0 - xi;
restml.c:/* Version 4.0. (c) Copyright 2012-2013 by the University of Washington.
restml.c:typedef sitelike2 *phenotype2;  /* Array of length ml_node->endsite */
restml.c:  ret = t->freetrans[t->transindex];
restml.c:  t->transindex--;
restml.c:  for ( i = 0 ; i < t->transindex; i++ )
restml.c:    if ( t->freetrans[i] == trans )
restml.c:  t->transindex++;
restml.c:  t->freetrans[t->transindex] = trans;
restml.c:    t->freetrans[i] = i;
restml.c:  t->transindex = nonodes2 - 1;
restml.c:  ((restml_tree*)t)->trans = (transptr)Malloc(t->nonodes * sizeof(transmatrix));
restml.c:  for (i = 0; i < t->nonodes; ++i)
restml.c:    ((restml_tree*)t)->trans[i] = alloctrans(sitelength);
restml.c:  ((restml_tree*)t)->travmatrix = alloctrans(sitelength);
restml.c:  ((restml_tree*)t)->freetrans = Malloc(t->nonodes* sizeof(long));
restml.c:  for ( i = 0; i < t->nonodes; i++ )
restml.c:    ((restml_tree*)t)->freetrans[i] = i+1;
restml.c:  ((restml_tree*)t)->transindex = t->nonodes - 1;
restml.c:  n->branchnum = -1;
restml.c:  if(n->ml_node.endsite != endsite)
restml.c:    printf("EWIFX -- realloc needed\n");
restml.c:    n->ml_node.endsite = endsite;
restml.c:    // BUG.968 -- free here
restml.c:    n->x = NULL;
restml.c:  if(n->x == NULL)
restml.c:    printf("BUG.968 -- realloc needed\n");
restml.c:    n->x = (phenotype2)Malloc((1+endsite) * sizeof(sitelike2));
restml.c:    if(n->x[i] == NULL)
restml.c:      n->x[i] = init_sitelike(sitelength);
restml.c:    if ( n->ml_node.node.tip == false )
restml.c:        n->x[i][j] = 1.0;
restml.c:  printf("BUG.968 -- branch %ld x[0][0] %lf\n", n->branchnum, n->x[0][0]);
restml.c:  if(n->branchnum != -1)
restml.c:  // don't add 1 to endsite here, it's taken care of in restml-specific routines
restml.c:  allocx(nonodes, endsite, sitelength, (ml_node**)t->nodep);
restml.c:  ((restml_tree*)t)->lr_temps = Malloc(NLR_TEMPS * sizeof(transmatrix));
restml.c:    ((restml_tree*)t)->lr_temps[i] = Malloc((sitelength + 1) * sizeof(double * ));
restml.c:      ((restml_tree*)t)->lr_temps[i][j] = Malloc((sitelength + 1) * sizeof(double));
restml.c:  t->evaluate = restml_tree_evaluate;
restml.c:  t->save_traverses = restml_tree_save_traverses;
restml.c:  t->restore_traverses = restml_tree_restore_traverses;
restml.c:  t->nuview = restml_tree_nuview;
restml.c:  t->save_lr_nodes = restml_tree_save_lr_nodes;
restml.c:  t->restore_lr_nodes = restml_tree_restore_lr_nodes;
restml.c:  t->do_branchl_on_insert_f = (do_branchl_on_insert_t)restml_tree_do_branchl_on_insert;
restml.c:  t->do_branchl_on_re_move_f = (do_branchl_on_re_move_t) restml_tree_do_branchl_on_re_move;
restml.c:  ((ml_tree*)t)->makenewv = (makenewv_t)restml_tree_makenewv;
restml.c:  ((restml_tree*)t)->get_trans = get_trans;
restml.c:  ((restml_tree*)t)->free_trans = free_trans;
restml.c:  n->branchnum = -1;
restml.c:  n->ml_node.allocx = restml_node_allocx;
restml.c:  n->ml_node.node.copy = restml_node_copy;
restml.c:  n->ml_node.freex = restml_node_freex;
restml.c:  n->ml_node.node.node_print_f = restml_node_print;
restml.c:  printf(" restml(branchnum:%ld)", rn->branchnum);
restml.c:    exxit(-1);
restml.c:  nonodes2 = spp * 2 - 1;
restml.c:    pie[i] = 3 * pie[i - 1] * (sitelength - i + 1) / i;
restml.c:    nonodes2--;
restml.c:      exxit(-1);
restml.c:      exxit(-1);
restml.c:      exxit(-1);
restml.c:  j = nmlngth + (sites + (sites - 1) / 10) / 2 - 5;
restml.c:  if (j < nmlngth - 1)
restml.c:    j = nmlngth - 1;
restml.c:    fprintf(outfile, "----");
restml.c:    fprintf(outfile, "-----\n\n");
restml.c:    /* eat white space -- if the separator line has spaces on it*/
restml.c:        initname(i - 1);
restml.c:          if (ch != '1' && ch != '0' && ch != '+' && ch != '-' && ch != '?')
restml.c:            exxit(-1);
restml.c:            ch = '-';
restml.c:          inputSequences[i - 1][j - 1] = ch;
restml.c:        exxit(-1);}
restml.c:    for (i = 1; i <= ((sites - 1) / 60 + 1); i++)
restml.c:        for (k = (i - 1) * 60 + 1; k <= l; k++)
restml.c:          putc(inputSequences[j][k - 1], outfile);
restml.c:        ((restml_node*)curtree->nodep[i])->x[k][l] = 1.0;
restml.c:      switch (inputSequences[i][j - 1])
restml.c:            ((restml_node*)curtree->nodep[i])->x[k][m] = 0.0;
restml.c:        case '-':
restml.c:          ((restml_node*)curtree->nodep[i])->x[k][0] = 0.0;
restml.c:      ((restml_node*)curtree->nodep[i])->x[0][k] = 1.0;
restml.c:    ((restml_node*)curtree->nodep[i])->x[0][0] = 0.0;
restml.c:    /* Search for site with '-' for all species */
restml.c:        if ( inputSequences[k][alias[i] - 1] != '-' )
restml.c:      weightsum += (enzymes - 1) * weight[i];
restml.c:     If both tempslope and tempcurve are non-NULL, slope
restml.c:    if (p > 1.0 - epsilon)
restml.c:      p = 1.0 - epsilon;
restml.c:    binom1[0] = exp((sitelength - i) * log(1 - p));
restml.c:    for (k = 1; k <= sitelength - i; k++)
restml.c:      binom1[k] = binom1[k - 1] * (p / (1 - p)) * (sitelength - i - k + 1) / k;
restml.c:    binom2[0] = exp(i * log(1 - pover3));
restml.c:      binom2[k] = binom2[k - 1] * (pover3 / (1 - pover3)) * (i - k + 1) / k;
restml.c:      if (i - j > 0)
restml.c:        m1 = i - j;
restml.c:      if (sitelength - j < i)
restml.c:        m2 = sitelength - j;
restml.c:        pijk = binom1[j - i + k] * binom2[k];
restml.c:          term = (j-i+2*k)/p - (sitelength-j-k)/(1.0-p) - (i-k)/(3.0-p);
restml.c:          sumc += pijk * (term * term - (j-i+2*k)/(p*p) - (sitelength-j-k)/((1.0-p)*(1.0-p)) - (i-k)/((3.0-p)*(3.0-p)) );
restml.c:  tm = ((restml_tree*)curtree)->trans[i - 1];
restml.c:  q = p->back;
restml.c:  y = p->v;
restml.c:  copy_sitelike(x1, ((restml_node*)p)->x[0], sitelength);
restml.c:  copy_sitelike(x2, ((restml_node*)q)->x[0], sitelength);
restml.c:    lnlike0 = log(enzymes * (1.0 - like0));
restml.c:    copy_sitelike(x1, ((restml_node*)p)->x[i], sitelength);
restml.c:    copy_sitelike(x2, ((restml_node*)q)->x[i], sitelength);
restml.c:      term -= lnlike0;
restml.c:      l0gf[which - 1][i - 1] = term;
restml.c:      l0gl[which - 1] = sum;
restml.c:  tr->score = sum;
restml.c:  q = p->next->back;
restml.c:  r = p->next->next->back;
restml.c:  copymatrix(tempq, ((restml_tree*)curtree)->trans[((restml_node*)q)->branchnum - 1]);
restml.c:  copymatrix(tempr, ((restml_tree*)curtree)->trans[((restml_node*)r)->branchnum - 1]);
restml.c:    copy_sitelike(xq, ((restml_node*)q)->x[i], sitelength);
restml.c:    copy_sitelike(xr, ((restml_node*)r)->x[i], sitelength);
restml.c:    copy_sitelike(((restml_node*)p)->x[i], xp, sitelength);
restml.c:  p->initialized = true;
restml.c:  /* Newton-Raphson algorithm improvement of a branch length */
restml.c:  q = p->back;
restml.c:  y = p->v;
restml.c:      copy_sitelike(xx1, ((restml_node*)p)->x[i], sitelength);
restml.c:      copy_sitelike(xx2, ((restml_node*)q)->x[i], sitelength);
restml.c:        curve += weight[i] * (sumc/sum-temp*temp);
restml.c:    if (trunc8 && fabs(like0 - 1.0) > 1.0e-10)
restml.c:      like -= weightsum * log(enzymes * (1.0 - like0));
restml.c:      slope += weightsum * slope0 /(1.0 - like0);
restml.c:      curve += weightsum * (curve0 /(1.0 - like0) + slope0*slope0/((1.0 - like0)*(1.0 - like0)));
restml.c:      if (fabs(y - yold) < epsilon)
restml.c:    done = fabs(y-yold) < epsilon;
restml.c:  smoothed = (fabs(yold-yorig) < epsilon) && (yorig > 1000.0*epsilon);
restml.c:  p->v = yold;
restml.c:  q->v = yold;
restml.c:  branchtrans(((restml_node*)p)->branchnum, yold);
restml.c:  t->score = oldlike;
restml.c:  if (where->v >= 0.75)
restml.c:    where->v = 0.75;
restml.c:    where->v = 0.75 * (1 - sqrt(1 - 1.333333 * where->v));
restml.c:  if ( where->v < epsilon )
restml.c:    where->v = epsilon;
restml.c:  where->back->v = where->v;
restml.c:  forknode->next->next->v = where->v;
restml.c:  forknode->next->next->back->v = forknode->next->next->v;
restml.c:      ((restml_node*)where->back)->x[i][j] = 1.0;
restml.c:      ((restml_node*)where->back->next)->x[i][j] = 1.0;
restml.c:      ((restml_node*)where->back->next->next)->x[i][j] = 1.0;
restml.c:  // BUG.968 -- branchnum overwritten -- is it freed anywhere?
restml.c:  ((restml_node*)where->back)->branchnum = ((restml_node*)where)->branchnum;
restml.c:  ((restml_node*)forknode->next->next->back)->branchnum = ((restml_node*)forknode->next->next)->branchnum = t->get_trans(t);
restml.c:  ((restml_node*)forknode)->branchnum = ((restml_node*)forknode->back)->branchnum = t->get_trans(t);
restml.c:  branchtrans(((restml_node*)where)->branchnum, where->v);
restml.c:  branchtrans(((restml_node*)forknode->next->next)->branchnum, forknode->next->next->v);
restml.c:  branchtrans(((restml_node*)forknode)->branchnum, forknode->v);
restml.c:  free_trans((restml_tree*)t, ((restml_node*)q->back)->branchnum);
restml.c:  free_trans(((restml_tree*)t), ((restml_node*)p)->branchnum);
restml.c:  ((restml_node*)q->back)->branchnum = ((restml_node*)q)->branchnum;
restml.c:  q->v =  0.75*(1 - (1 - 1.333333 * q->v) * (1 - 1.333333*p->v));
restml.c:  if ( q->v > 1 - epsilon)
restml.c:    q->v = 1 - epsilon;
restml.c:  else if ( q->v < epsilon)
restml.c:    q->v = epsilon;
restml.c:  q->back->v = q->v;
restml.c:  branchtrans(((restml_node*)q)->branchnum, q->v);
restml.c:  long oldendsite = dst->ml_node.endsite;
restml.c:  dst->branchnum = src->branchnum;
restml.c:  /* If src->endsite differs from dst->endsite, free dst->x[] */
restml.c:  if ( oldendsite != 0 && oldendsite != dst->ml_node.endsite)
restml.c:    for ( i = 0 ; i <= ((ml_node*)src)->endsite ; i++ )
restml.c:      free(dst->x[i]);
restml.c:    free(dst->x);
restml.c:    dst->x = (phenotype2)Malloc(((((ml_node*)src)->endsite)+1) * sizeof(sitelike2));
restml.c:    for ( i = 0 ; i <= ((ml_node*)src)->endsite ; i++ )
restml.c:      dst->x[i] = init_sitelike(sitelength);
restml.c:    copy_sitelike(dst->x[i], src->x[i], sitelength);
restml.c:  for ( i = 0 ; i<((tree*)a)->nonodes; i++ )
restml.c:    copymatrix(b->trans[i], a->trans[i]);
restml.c:  /* set up and adjust branch lengths of a three-species tree */
restml.c:  hookup(tr->nodep[enterorder[0] - 1], tr->nodep[enterorder[1] - 1]);
restml.c:  tr->nodep[enterorder[0] - 1]->v = initialv;
restml.c:  tr->nodep[enterorder[1] - 1]->v = initialv;
restml.c:  ((restml_node*)tr->nodep[enterorder[0] - 1])->branchnum = ((restml_node*)tr->nodep[enterorder[1] - 1])->branchnum = get_trans((restml_tree*)tr);
restml.c:  tr->insert_(tr, tr->nodep[enterorder[2] - 1], tr->nodep[enterorder[1] - 1], false, false);
restml.c:  tr->root = tr->nodep[enterorder[2]-1]->back;
restml.c:  copymatrix(rt->lr_temps[0], rt->trans[((restml_node *)r->back)->branchnum - 1]);
restml.c:  copymatrix(rt->lr_temps[1], rt->trans[((restml_node*)r->back->next)->branchnum - 1]);
restml.c:  copymatrix(rt->lr_temps[2], rt->trans[((restml_node*)r->back->next->next)->branchnum - 1]);
restml.c:  copymatrix(rt->lr_temps[3], rt->trans[((restml_node*)p->next)->branchnum - 1]);
restml.c:  copymatrix(rt->lr_temps[4], rt->trans [((restml_node*)p->next->next)->branchnum - 1]);
restml.c:  restoredFork->branchnum = r->branchnum;
restml.c:  restoredFork->next->branchnum = restoredFork->next->back->branchnum;
restml.c:  restoredFork->next->next->branchnum = restoredFork->next->next->back->branchnum;
restml.c:  // BUG.968 -- this relies on the re_move code in locrearrange_recurs
restml.c:  // not over-writing the node info in r->back
restml.c:  ((restml_node*)r)->branchnum = ((restml_node*)(r->back))->branchnum;
restml.c:  ((restml_node*)r->back->next->back)->branchnum = ((restml_node*)(r->back->next))->branchnum;
restml.c:  ((restml_node*)r->back->next->next->back)->branchnum = ((restml_node*)(r->back->next->next))->branchnum;
restml.c:  copymatrix(rt->trans[((restml_node*)r->back)->branchnum - 1], rt->lr_temps[0]);
restml.c:  copymatrix(rt->trans[((restml_node*)r->back->next)->branchnum - 1], rt->lr_temps[1]);
restml.c:  copymatrix(rt->trans[((restml_node*)r->back->next->next)->branchnum - 1], rt->lr_temps[2]);
restml.c:  copymatrix(rt->trans[((restml_node*)p->next)->branchnum - 1], rt->lr_temps[3]);
restml.c:  copymatrix(rt->trans[((restml_node*)p->next->next)->branchnum - 1], rt->lr_temps[4]);
restml.c:  if (p->tip)
restml.c:    p->xcoord = (long)(over * lengthsum + 0.5);
restml.c:    p->ycoord = (*tipy);
restml.c:    p->ymin = (*tipy);
restml.c:    p->ymax = (*tipy);
restml.c:  q = p->next;
restml.c:    (*x) = -0.75 * log(1.0 - 1.333333 * q->v);
restml.c:    restml_coordinates(q->back, lengthsum + (*x), tipy, tipmax, x);
restml.c:    q = q->next;
restml.c:  } while ((p == curtree->root || p != q) && (p != curtree->root || p->next != q));
restml.c:  first = p->next->back;
restml.c:  while (q->next != p)
restml.c:    q = q->next;
restml.c:  last = q->back;
restml.c:  p->xcoord = (long)(over * lengthsum + 0.5);
restml.c:  if (p == curtree->root)
restml.c:    p->ycoord = p->next->next->back->ycoord;
restml.c:    p->ycoord = (first->ycoord + last->ycoord) / 2;
restml.c:  p->ymin = first->ymin;
restml.c:  p->ymax = last->ymax;
restml.c:  restml_coordinates(curtree->root, 0.0, &tipy, &tipmax, &x);
restml.c:  for (i = 1; i <= tipy - down; i++)
restml.c:  for ( i = 0 ; i <= n->ml_node.endsite; i++ )
restml.c:    free(n->x[i]);
restml.c:  free(n->x);
restml.c:  n->x = (phenotype2)Malloc((1+endsite) * sizeof(sitelike2));
restml.c:    n->x[i] = init_sitelike(sitelength);
restml.c:    if ( n->ml_node.node.tip == false )
restml.c:        n->x[i][j] = 1.0;
restml.c:  n->ml_node.endsite = endsite;
restml.c:    free(((restml_node*)treenode[i])->x);
restml.c:      free(((restml_node*)p)->x);
restml.c:      p = p->next;
restml.c:  p = q->v;
restml.c:    binom1[0] = exp((sitelength - i) * log(1 - p));
restml.c:    for (k = 1; k <= (sitelength - i); k++)
restml.c:      binom1[k] = binom1[k - 1] * (p / (1 - p)) * (sitelength - i - k + 1) / k;
restml.c:    binom2[0] = exp(i * log(1 - pover3));
restml.c:      binom2[k] = binom2[k - 1] * (pover3 / (1 - pover3)) * (i - k + 1) / k;
restml.c:      if (i - j > 0)
restml.c:        m1 = i - j;
restml.c:      if (sitelength - j < i)
restml.c:        m2 = sitelength - j;
restml.c:        pijk = binom1[j - i + k] * binom2[k];
restml.c:        term = (j-i+2*k)/p - (sitelength-j-k)/(1.0-p) - (i-k)/(3.0-p);
restml.c:                        - (j-i+2*k)/(p*p)
restml.c:                        - (sitelength-j-k)/((1.0-p)*(1.0-p))
restml.c:                        - (i-k)/((3.0-p)*(3.0-p)) );
restml.c:  r = q->back;
restml.c:    copy_sitelike(x1, ((restml_node*)q)->x[i], sitelength);
restml.c:    copy_sitelike(x2, ((restml_node*)r)->x[i], sitelength);
restml.c:    sumc += weight[i] * (curvef / f - TEMP * TEMP);
restml.c:    copy_sitelike(x1, ((restml_node*)q)->x[0], sitelength);
restml.c:    copy_sitelike(x2, ((restml_node*)r)->x[0], sitelength);
restml.c:    (*sumlr) += weightsum * log((1.0 - sumr) / (1.0 - f));
restml.c:    sums += weightsum * slopef / (1.0 - f);
restml.c:    TEMP = slopef / (1.0 - f);
restml.c:    sumc += weightsum * (curvef / (1.0 - f) + TEMP * TEMP);
restml.c:  if (sumc < -1.0e-6)
restml.c:    return ((-sums - sqrt(sums * sums - 3.841 * sumc)) / sumc);
restml.c:    return -1.0;
restml.c:  q = p->back;
restml.c:  fprintf(outfile, "%4ld      ", q->index - spp);
restml.c:  if (p->tip)
restml.c:      putc(nayme[p->index - 1][i], outfile);
restml.c:    fprintf(outfile, "%4ld      ", p->index - spp);
restml.c:  if (q->v >= 0.75)
restml.c:    fprintf(outfile, "%13.5f", -0.75 * log(1 - 1.333333 * q->v));
restml.c:  if (p->iter)
restml.c:      if (q->v - s <= 0.0)
restml.c:        fprintf(outfile, "%9.5f", -0.75 * log(1 - 1.333333 * (q->v - s)));
restml.c:      if (q->v + s >= 0.75)
restml.c:        fprintf(outfile, "%12.5f", -0.75 * log(1 - 1.333333 * (q->v + s)));
restml.c:  if (!p->tip)
restml.c:    describe(p->next->back);
restml.c:    describe(p->next->next->back);
restml.c:  fprintf(outfile, "Ln Likelihood = %11.5f\n\n", curtree->score);
restml.c:  fprintf(outfile, " -------        ---            ------");
restml.c:  fprintf(outfile, "      ------- ---------- ------\n");
restml.c:  describe(curtree->root->next->back);
restml.c:  describe(curtree->root->next->next->back);
restml.c:  describe(curtree->root->back);
restml.c:  if (p->tip)
restml.c:      if (nayme[p->index - 1][i - 1] != ' ')
restml.c:      c = nayme[p->index - 1][i];
restml.c:    restml_treeout(p->next->back);
restml.c:    restml_treeout(p->next->next->back);
restml.c:    if (p == curtree->root)
restml.c:      restml_treeout(p->back);
restml.c:  if (p->v >= 0.75)
restml.c:    x = -1.0;
restml.c:    x = -0.75 * log(1 - 1.333333 * p->v);
restml.c:    w = (long)(0.43429448222 * log(-x)) + 1;
restml.c:  if (p == curtree->root)
restml.c: * Save node q in t->temp, including the branch number and
restml.c:  branchnum = ((restml_node *)t->temp_q)->branchnum = rq->branchnum;
restml.c:  copymatrix (rt->travmatrix, rt->trans[branchnum-1]);
restml.c:  /* BUG.968 -- check that this should even happen at all */
restml.c:  if(! q->back->tip)
restml.c:    rt->free_trans(rt, ((restml_node*)q->back->next)->branchnum);
restml.c:    rt->free_trans(rt, ((restml_node*)q->back->next->next)->branchnum);
restml.c:  rq->branchnum = ((restml_node*)t->temp_q)->branchnum;
restml.c:  ((restml_node*)q->back)->branchnum = rq->branchnum;
restml.c:  copymatrix (rt->trans[rq->branchnum-1], rt->travmatrix);
restml.c:  if (((restml_node*)p)->branchnum == 0)
restml.c:    ((restml_node*)p)->branchnum = t->get_trans(t);
restml.c:    ((restml_node*)p->back)->branchnum = ((restml_node*)p)->branchnum;
restml.c:  p->initialized = false;
restml.c:  p->back->initialized = false;
restml.c:  if ((!lngths) || p->iter)
restml.c:    branchtrans(((restml_node*)p)->branchnum, initialv);
restml.c:    p->v = initialv;
restml.c:    p->back->v = initialv;
restml.c:    branchtrans(((restml_node*)p)->branchnum, p->v);
restml.c:  if (!p->tip)
restml.c:    q = p->next;
restml.c:      inittravtree(t, q->back);
restml.c:      q = q->next;
restml.c:  return 3.0/4.0 * (1.0-exp(-4.0/3.0 * v));
restml.c:    t->nodep[i]->v = adjusted_v(t->nodep[i]->v);
restml.c:    t->nodep[i]->v = adjusted_v(t->nodep[i]->v);
restml.c:    t->nodep[i]->next->v = adjusted_v(t->nodep[i]->next->v);
restml.c:    t->nodep[i]->next->next->v = adjusted_v(t->nodep[i]->next->next->v);
restml.c:    /* Open in binary: ftell() is broken for UNIX line-endings under WIN32 */
restml.c:      fprintf(outfile, "User-defined tree");
restml.c:      treeread2 (intree, &curtree->root, curtree->nodep, lngths, &trweight, &goteof, &haslengths, &spp, false, nonodes2);
restml.c:        curtree->root = curtree->nodep[outgrno - 1]->back;
restml.c:      if ( reusertree && ( which == 1 || curtree->score > bestree2->score ))
restml.c:        curtree->copy(curtree, bestree2);
restml.c:        bestree2->copy(bestree2, curtree);
restml.c:        curtree->root = curtree->nodep[0]->back;
restml.c:          curtree->root = curtree->nodep[outgrno - 1]->back;
restml.c:        restml_treeout(curtree->root);
restml.c:      standev2(numtrees, maxwhich, 0, endsite-1, maxlogl, l0gl, l0gf, aliasweight, seed);
restml.c:      enterorder[i - 1] = i;
restml.c:    curtree->root = curtree->nodep[enterorder[0] - 1]->back;
restml.c:      bestyet = - nextsp*sites*sitelength*log(4.0);
restml.c:        curtree->copy(curtree, priortree);
restml.c:      curtree->addtraverse(curtree, curtree->nodep[enterorder[nextsp - 1] - 1], curtree->root, true, &qwhere, &bestyet, bestree, priortree, smoothit, NULL);
restml.c:        bestree->copy(bestree, curtree);
restml.c:        curtree->insert_(curtree, curtree->nodep[enterorder[nextsp - 1] - 1], qwhere, false, false);
restml.c:        curtree->smoothall(curtree, curtree->root);
restml.c:        bestyet = curtree->score;
restml.c:        writename(nextsp - 1, 1, enterorder);
restml.c:            if ( (j - spp) % (( nonodes2 / 72 ) + 1 ) == 0 )
restml.c:              putchar('-');
restml.c:        curtree->globrearrange(curtree, progress, smoothit);
restml.c:        curtree->locrearrange(curtree, curtree->nodep[enterorder[0] - 1], smoothit, priortree, bestree);
restml.c:    curtree->copy(curtree, bestree);
restml.c:        bestree->copy(bestree, bestree2);
restml.c:        if (bestree2->score < bestree->score)
restml.c:          bestree->copy(bestree, bestree2);
restml.c:        bestree2->copy(bestree2, curtree);
restml.c:      curtree->root = curtree->nodep[outgrno - 1]->back;
restml.c:        restml_treeout(curtree->root);
restml.c:  freex2(nonodes2, curtree->nodep);
restml.c:    freex2(nonodes2, priortree->nodep);
restml.c:    freex2(nonodes2, bestree->nodep);
restml.c:      freex2(nonodes2, bestree2->nodep);
restml.c:  funcs->node_new = restml_node_new;
restml.c:  funcs->tree_new = restml_tree_new;
restore.c:/* Version 4.0. (c) Copyright 2012-2013 by the University of Washington.
restore.c:  SL_POINT      /* No-op checkpoint */
restore.c:/* Remember a recently-allocated block. Return a checkpoint.  */
restore.c:  sl->log = Slist_new();
restore.c:  sl->next_id = 0;
restore.c:  Slist_delete(&(log->log));
restore.c:  pool_usecount--;
restore.c:  sb->type = SL_POINT;
restore.c:  sb->id   = log->next_id;
restore.c:  log->next_id++;
restore.c:  sb->size = 0;
restore.c:  sb->loc  = NULL;
restore.c:  sb->data = NULL;
restore.c:  Slist_push(log->log, sb);
restore.c:  return sb->id;
restore.c:  sb->type = SL_DATA;
restore.c:  sb->id   = log->next_id;
restore.c:  log->next_id++;
restore.c:  sb->size = size;
restore.c:  sb->loc  = loc;
restore.c:  sb->data = (*sl_malloc)(size);
restore.c:  assert( sb->data != NULL );
restore.c:  memcpy(sb->data, loc, size);
restore.c:  Slist_push(log->log, sb);
restore.c:  return sb->id;
restore.c:  sb->type = SL_NEWBORN;
restore.c:  sb->size = 0;
restore.c:  sb->id   = log->next_id;
restore.c:  log->next_id++;
restore.c:  sb->data = NULL;
restore.c:  sb->loc  = ptr;
restore.c:  assert( sb->loc != NULL );
restore.c:  Slist_push(log->log, (void *)sb);
restore.c:  return sb->id;
restore.c:  sb->type = SL_ZOMBIE;
restore.c:  sb->size = 0;
restore.c:  sb->id   = log->next_id;
restore.c:  log->next_id++;
restore.c:  sb->data = NULL;
restore.c:  sb->loc  = ptr;
restore.c:  Slist_push(log->log, (void *)sb);
restore.c:  return sb->id;
restore.c:    assert( !Slist_isempty(log->log) );
restore.c:    sb = (saveblock *)Slist_pop(log->log);
restore.c:    switch (sb->type)
restore.c:        memcpy(sb->loc, sb->data, sb->size);
restore.c:        (*sl_free)(sb->data);
restore.c:        (*sl_free)(sb->loc);
restore.c:    if ( sb->id == id ) {
restore.c:  while ( !Slist_isempty(log->log) ) {
restore.c:    sb = (saveblock *)Slist_pop(log->log);
restore.c:    switch (sb->type)
restore.c:        (*sl_free)(sb->data);
restore.c:        (*sl_free)(sb->loc);
retree.c:/* Version 4.0. (c) Copyright 1993-2013 by the University of Washington.
retree.c:#define maxsz           99999  /* size of pointer array.  >= 2*maxsp - 1  */
retree.c:      *p = treep->get_forknode(treep, nodei);
retree.c:      (*p)->index = nodei;
retree.c:      (*p)->tip = false;
retree.c:      (*p)->deleted=false;
retree.c:      (*p)->deadend=false;
retree.c:      (*p)->onebranch=false;
retree.c:      (*p)->onebranchhaslength=false;
retree.c:        (*p)->nayme[i] = '\0';
retree.c:      treep->nodep[(*p)->index - 1] = (*p);
retree.c:      *p = treep->get_forknode(treep, nodei);
retree.c:      (*p)->index = nodei;
retree.c:      if ((*p)->back)
retree.c:        (*p)->back->back = *p;
retree.c:        (*p)->haslength = (*p)->back->haslength;
retree.c:        if ((*p)->haslength)
retree.c:          (*p)->length = (*p)->back->length;
retree.c:      *p = treep->get_forknode(treep, nodei);
retree.c:      treep->nodep[(*ntips) - 1] = *p;
retree.c:      (*p)->index = *ntips;
retree.c:      (*p)->tip = true;
retree.c:      (*p)->hasname = true;
retree.c:      strncpy ((*p)->nayme, str, MAXNCH);
retree.c:      (*p)->haslength = true;
retree.c:        (*p)->length = valyew / divisor;
retree.c:        (*p)->length = 0.0;
retree.c:      if ( (*p)->back != NULL)
retree.c:        (*p)->back->haslength = (*p)->haslength;
retree.c:        (*p)->back->length = (*p)->length;
retree.c:      (*p)->haslength = false;
retree.c:      if ( (*p)->back != NULL )
retree.c:        (*p)->back->haslength  = false;
retree.c:    *p = treep->get_forknode(treep, index);
retree.c:    (*p)->index = index;
retree.c:    (*p)->hasname = false;
retree.c:    (*p)->haslength = false;
retree.c:    (*p)->deleted=false;
retree.c:    (*p)->deadend=false;
retree.c:    (*p)->onebranch=false;
retree.c:    (*p)->onebranchhaslength=false;
retree.c:      (*p)->nayme[j] = '\0';
retree.c:    (*p)->next = q;
retree.c:  (*p)->next->next->next = *p;
retree.c:  q = (*p)->next;
retree.c:    (*p)->back = NULL;
retree.c:    (*p)->tip = false;
retree.c:    *p = (*p)->next;
retree.c:  treep->nodep[index - 1] = *p;
retree.c:  *p = treep->get_forknode(treep, index);
retree.c:  (*p)->index = index;
retree.c:  (*p)->tip = true;
retree.c:  (*p)->hasname = false;
retree.c:  (*p)->haslength = false;
retree.c:  treep->nodep[index - 1] = *p;
retree.c:  /* configure to machine -- set up special characters */
retree.c:  cch[(long)ch_over] = '-';
retree.c:  if (p->tip)
retree.c:    (*localhl) = ((*localhl) && p->haslength);
retree.c:  q = p->next;
retree.c:    (*localhl) = ((*localhl) && q->haslength);
retree.c:      ltrav(q->back, localhl);
retree.c:    q = q->next;
retree.c:  ltrav(curtree->root, &localhl);
retree.c:  if (below != treep->nodep[below->index - 1])
retree.c:    below = treep->nodep[below->index - 1];
retree.c:      newfork->haslength = true;
retree.c:      newfork->next->haslength = true;
retree.c:      newfork->next->next->haslength = true;
retree.c:  if (below->back != NULL)
retree.c:    below->back->back = newfork;
retree.c:  newfork->back = below->back;
retree.c:  rtdesc->back = newfork->next->next;
retree.c:  newfork->next->next->back = rtdesc;
retree.c:  newfork->next->back = leftdesc;
retree.c:  leftdesc->back = newfork->next;
retree.c:  if (treep->root == below)
retree.c:    treep->root = newfork;
retree.c:  treep->root->back = NULL;
retree.c:  if (newfork->back != NULL)
retree.c:    length = newfork->back->length / 2.0;
retree.c:    newfork->length = length;
retree.c:    newfork->back->length = length;
retree.c:    below->length = length;
retree.c:    below->back->length = length;
retree.c:    length = newtip->length / 2.0;
retree.c:    newtip->length = length;
retree.c:    newtip->back->length = length;
retree.c:    below->length = length;
retree.c:    below->back->length = length;
retree.c:    below->haslength = true;
retree.c:  newtip->back->length = newtip->length;
retree.c:  /*xx ?? debug what to do if no ancestral node -- have to create one */
retree.c:  if (atnode != treep->nodep[atnode->index - 1])
retree.c:    atnode = treep->nodep[atnode->index - 1];
retree.c:  q = treep->nodep[newtip->index-1]->back;
retree.c:    q = treep->nodep[q->index-1];
retree.c:    if (newtip == q->next->next->back)
retree.c:      q->next->back = newtip;
retree.c:      newtip->back = q->next;
retree.c:      q->next->next->back = NULL;
retree.c:  if (newtip->back != NULL)
retree.c:    add_at(treep, atnode, newtip, treep->nodep[newtip->back->index-1]);
retree.c:  if (parent != treep->nodep[parent->index - 1])
retree.c:    parent = treep->nodep[parent->index - 1];
retree.c:  newnode = treep->get_forknode(treep, parent->index);
retree.c:  newnode->tip = false;
retree.c:  newnode->deleted=false;
retree.c:  newnode->deadend=false;
retree.c:  newnode->onebranch=false;
retree.c:  newnode->onebranchhaslength=false;
retree.c:    newnode->nayme[i] = '\0';
retree.c:  newnode->index = parent->index;
retree.c:    q = q->next;
retree.c:  } while (q->next != parent);
retree.c:  newnode->next = parent;
retree.c:  q->next = newnode;
retree.c:  newnode->back = newchild;
retree.c:  newchild->back = newnode;
retree.c:  if (newchild->haslength)
retree.c:    newnode->length = newchild->length;
retree.c:    newnode->haslength = true;
retree.c:    newnode->haslength = false;
retree.c:  if ((*item)->back == NULL)
retree.c:  *forknode = treep->nodep[(*item)->back->index - 1];
retree.c:  if ((*forknode)->next->back == *item)
retree.c:  q = (*forknode)->next;
retree.c:    if (q->next->back == *item)
retree.c:    q = q->next;
retree.c:    p->next = (*item)->back->next;
retree.c:    (*item)->back = NULL;
retree.c:    if (*item == (*forknode)->next->back)
retree.c:      if (treep->root == *forknode)
retree.c:        treep->root = (*forknode)->next->next->back;
retree.c:      if (treep->root == *forknode)
retree.c:        treep->root = (*forknode)->next->back;
retree.c:    p = (*item)->back->next->back;
retree.c:    q = (*item)->back->next->next->back;
retree.c:      p->back = q;
retree.c:      q->back = p;
retree.c:        p->length += q->length;
retree.c:        q->length = p->length;
retree.c:        (*item)->length = (*forknode)->next->length + (*forknode)->next->next->length;
retree.c:    (*forknode)->back = NULL;
retree.c:    p = (*forknode)->next;
retree.c:      p->back = NULL;
retree.c:      p = p->next;
retree.c:    (*item)->back = NULL;
retree.c:  q = treep->root->next;
retree.c:    q = p->next;
retree.c:  } while (q != treep->root);
retree.c:  if((outgroup->back->index == treep->root->index) && !(nodecount > 2))
retree.c:  p = outgroup->back;
retree.c:  while (p->index != treep->root->index)
retree.c:    q = treep->nodep[p->index - 1]->back;
retree.c:    treep->nodep[p->index - 1] = p;
retree.c:    treep->nodep[p->index - 1] = p;
retree.c:    r->next = treep->root->next;
retree.c:    treep->root->next = NULL;
retree.c:    maketriad(treep, &treep->root, nonodes);
retree.c:      /* root->haslength remains false, or else treeout() will generate a bogus extra length */
retree.c:      treep->root->next->haslength = true;
retree.c:      treep->root->next->next->haslength = true;
retree.c:    q = treep->root->next;
retree.c:    q->back->back = r->back;
retree.c:    r->back->back = q->back;
retree.c:      r->back->length = r->back->length + q->back->length;
retree.c:      q->back->length = r->back->length;
retree.c:  treep->root->next->back = outgroup;
retree.c:  treep->root->next->next->back = outgroup->back;
retree.c:  outgroup->back->back = treep->root->next->next;
retree.c:  outgroup->back = treep->root->next;
retree.c:    templen = outgroup->length / 2.0;
retree.c:    outgroup->length = templen;
retree.c:    outgroup->back->length = templen;
retree.c:    treep->root->next->next->length = templen;
retree.c:    treep->root->next->next->back->length = templen;
retree.c:  if (p->tip)
retree.c:    nl = strlen(treep->nodep[p->index - 1]->nayme);
retree.c:      (*across) = (*maxchar) - (long)(nl * (*tipmax) / lengthsum + 0.5);
retree.c:  q = p->next;
retree.c:    if (q->length >= lmin)
retree.c:      sublength = q->length;
retree.c:    ltrav_(treep, q->back, lengthsum + sublength, lmin, tipmax, across, maxchar);
retree.c:    q = q->next;
retree.c:    maxchar = screenwidth - 13;
retree.c:    maxchar = screenwidth - 5;
retree.c:  } while (fabs((*tipmax) - oldtipmax) > 0.01 * oldtipmax && i <= 40);
retree.c:  if (p->tip)
retree.c:    p->xcoord = (long)((*across) * lengthsum / (*tipmax) + 0.5);
retree.c:    p->ycoord = (*tipy);
retree.c:    p->ymin   = (*tipy);
retree.c:    p->ymax   = (*tipy);
retree.c:  q = p->next;
retree.c:    coordinates(q->back, lengthsum + q->length, across, tipy, tipmax);
retree.c:    q = q->next;
retree.c:  first = p->next->back;
retree.c:  while (q->next != p)
retree.c:    q = q->next;
retree.c:  last = q->back;
retree.c:  p->xcoord = (long)((*across) * lengthsum / (*tipmax) + 0.5);
retree.c:  if (p == curtree->root)
retree.c:    if (curtree->root->next->next->next == curtree->root)
retree.c:      p->ycoord = (first->ycoord + last->ycoord) / 2;
retree.c:      p->ycoord = p->next->next->back->ycoord;
retree.c:    p->ycoord = (first->ycoord + last->ycoord) / 2;
retree.c:  p->ymin = first->ymin;
retree.c:  p->ymax = last->ymax;
retree.c:  if (p->tip)
retree.c:    p->xcoord = 0;
retree.c:    p->ycoord = (*tipy);
retree.c:    p->ymin   = (*tipy);
retree.c:    p->ymax   = (*tipy);
retree.c:  q = p->next;
retree.c:    flatcoordinates(q->back, tipy);
retree.c:    q = q->next;
retree.c:  first = p->next->back;
retree.c:  q = p->next;
retree.c:  while (q->next != p)
retree.c:    q = q->next;
retree.c:  last = q->back;
retree.c:  p->xcoord = (last->ymax - first->ymin) * 3 / 2;
retree.c:  if (p == curtree->root)
retree.c:    if (curtree->root->next->next->next == curtree->root)
retree.c:      p->ycoord = (first->ycoord + last->ycoord) / 2;
retree.c:      p->ycoord = p->next->next->back->ycoord;
retree.c:    p->ycoord = (first->ycoord + last->ycoord) / 2;
retree.c:  p->ymin = first->ymin;
retree.c:  p->ymax = last->ymax;
retree.c:    if ((*pos) >= leftedge && (*pos) - leftedge + 1 < screenwidth)
retree.c:  if (i == (long)p->ycoord && (p == curtree->root || (*subtree)))
retree.c:    if (p->index >= 100)
retree.c:      nnwrite(p->index, 3, &pos, leftedge, screenwidth);
retree.c:    else if (p->index >= 10)
retree.c:      nnwrite(p->index, 2, &pos, leftedge, screenwidth);
retree.c:      nnwrite(p->index, 1, &pos, leftedge, screenwidth);
retree.c:    if (!p->tip)
retree.c:      r = p->next;
retree.c:        if (i >= r->back->ymin && i <= r->back->ymax)
retree.c:          q = r->back;
retree.c:        r = r->next;
retree.c:      first = p->next->back;
retree.c:      r = p->next;
retree.c:      while (r->next != p)
retree.c:        r = r->next;
retree.c:      last = r->back;
retree.c:      n = (long)(q->xcoord - p->xcoord);
retree.c:      n = (long)(p->xcoord - q->xcoord);
retree.c:    if (n < 3 && !q->tip)
retree.c:      n--;
retree.c:    if ((long)q->ycoord == i && !done)
retree.c:      if (!haslengths && !q->haslength)
retree.c:      if (q->deleted)
retree.c:      else if ((long)q->ycoord == (long)p->ycoord)
retree.c:      if (n > 1 || q->tip)
retree.c:        grwrite(c, n - 3, &pos);
retree.c:      if (q->index >= 100)
retree.c:        nnwrite(q->index, 3, &pos, leftedge, screenwidth);
retree.c:      else if (q->index >= 10)
retree.c:        nnwrite(q->index, 2, &pos, leftedge, screenwidth);
retree.c:        nnwrite(q->index, 1, &pos, leftedge, screenwidth);
retree.c:    else if (!q->tip)
retree.c:      if ((long)last->ycoord > i && (long)first->ycoord < i &&
retree.c:          i != (long)p->ycoord)
retree.c:        if(p->deleted)
retree.c:        if (!p->tip)
retree.c:          r = p->next;
retree.c:            s = r->back;
retree.c:            if ((long)s->ycoord < (long)p->ycoord && !s->deleted)
retree.c:              up_nondel = (long)s->ycoord;
retree.c:            if (s->ycoord > p->ycoord && !s->deleted &&
retree.c:              down_nondel = (long)s->ycoord;
retree.c:            if (i < (long)p->ycoord && s->deleted && i > (long)s->ycoord)
retree.c:            if (i > (long)p->ycoord && s->deleted && i < (long)s->ycoord)
retree.c:            r = r->next;
retree.c:          if ((up_nondel != 0) && i < (long)p->ycoord && i > up_nondel)
retree.c:          if ((down_nondel != 0) && i > (long)p->ycoord && i < down_nondel)
retree.c:        chwrite(' ', n - 1, &pos, leftedge, screenwidth);
retree.c:  if ((long)p->ycoord == i && p->tip)
retree.c:    if (p->hasname)
retree.c:        if (curtree->nodep[p->index - 1]->nayme[j - 1] != '\0')
retree.c:        chwrite(curtree->nodep[p->index - 1]->nayme[j], 1, &pos, leftedge, screenwidth);
retree.c:    nuroot = curtree->root;
retree.c:    dow--;
retree.c:  treelines = tipy - dow;
retree.c:    printf("** %ld lines above screen **\n", topedge - 1);
retree.c:  if ((treelines - topedge + 1) > (screenlines - vmargin))
retree.c:    if (i >= topedge && i < topedge + screenlines - vmargin)
retree.c:  if ((treelines - topedge + 1) > (screenlines - vmargin))
retree.c:    printf("** %ld", treelines - (topedge - 1 + screenlines - vmargin));
retree.c:  if (treelines - topedge + vmargin + 1 < screenlines)
retree.c:      exxit(-1);
retree.c:  nonodes = spp * 2 - 1;
retree.c:  maketip(treep, &treep->root, 1);
retree.c:  add_at(treep, treep->root, newtip, newfork);
retree.c:    maketriad(treep, &newfork, spp + i - 1);
retree.c:    add_at(treep, treep->nodep[spp + i - 3], newtip, newfork);
retree.c:  nonodes = spp * 2 - 1;
retree.c:  maketip(curtree, &curtree->root, 1);
retree.c:  add_at(curtree, curtree->root, newtip, newfork);
retree.c:        exxit(-1);
retree.c:    if (j >= i)                         /* has user chosen a non-tip? if so, offer choice */
retree.c:          exxit(-1);
retree.c:        if (!curtree->nodep[j - 1]->tip)
retree.c:          add_child(curtree, curtree->nodep[j - 1], curtree->nodep[i - 1]);
retree.c:        curtree->nodep[i-1]->back = newfork;
retree.c:        newfork->back = curtree->nodep[i-1];
retree.c:        add_before(curtree, curtree->nodep[j - 1], curtree->nodep[i - 1]);
retree.c:        if (curtree->nodep[k - 2] != NULL)
retree.c:          curtree->nodep[k - 1] = curtree->nodep[k - 2];
retree.c:          curtree->nodep[k - 1]->index = k;
retree.c:          curtree->nodep[k - 1]->next->index = k;
retree.c:          curtree->nodep[k - 1]->next->next->index = k;
retree.c:        k--;
retree.c:      nonodes = spp * 2 - 1;
retree.c:    if ((curtree->nodep[i - 1] != curtree->nodep[i]) && (curtree->nodep[i - 1] != NULL))
retree.c:    curtree->nodep[spp + i] = curtree->nodep[uniquearray[i] - 1];
retree.c:    curtree->nodep[spp + i]->index = spp + i + 1;
retree.c:    curtree->nodep[spp + i]->next->index = spp + i + 1;
retree.c:    curtree->nodep[spp + i]->next->next->index = spp + i + 1;
retree.c:    curtree->nodep[i] = NULL;
retree.c:  nonodes = spp * 2 - 1;
retree.c:  /* These assignments moved from treeconstruct -- they seem to happen only here. */
retree.c:  // BUG.967 -- these are default values below, this should be
retree.c:        /* Open in binary: ftell() is broken for UNIX line-endings under WIN32 */
retree.c:      // BUG.967 these may need to be re-incorporated in a more modern way
retree.c:      treeread(treesets[whichtree].tree_p, intree, &(treesets[whichtree].tree_p->root), dummy_treenode, &goteof, &firsttree, &nextnode, &haslengths, initretreenode, true, -1);
retree.c:  q = treesets[whichtree].tree_p->root->next;
retree.c:    q = p->next;
retree.c:  } while (q != treesets[whichtree].tree_p->root);
retree.c:  outgrno = treesets[whichtree].tree_p->root->next->back->index;
retree.c:    reroot(curtree, curtree->nodep[outgrno - 1]);
retree.c:  // BUG.967 -- need to test and possibly replace
retree.c:  // treesets[0].tree_p->free(treesets[0].tree_p);
retree.c:  // treesets[1].tree_p->free(treesets[1].tree_p);
retree.c:  // simplifiedtree.tree_p->free(treesets[1].tree_p);
retree.c:  start = curtree->nodep[index - 1];
retree.c:  q = start->next;
retree.c:    q = q->next;
retree.c:  while (curtree->nodep[i-1] != NULL)
retree.c:    r = curtree->nodep[i - 1];
retree.c:    if (!(r->tip))
retree.c:      r->index--;
retree.c:    if (!(r->tip))
retree.c:      q = r->next;
retree.c:        q->index--;
retree.c:        q = q->next;
retree.c:    curtree->nodep[i - 1] = curtree->nodep[i];
retree.c:  nonodes--;
retree.c:  else if ( i < 1 || i > spp*2 - 1 )
retree.c:  else if (i == curtree->root->index )
retree.c:  else if ( curtree->nodep[i-1]->deleted )
retree.c:    else if ( j < 1 || j > spp*2 - 1 )
retree.c:    else if ( curtree->nodep[j-1]->deleted )
retree.c:    else if (j != curtree->root->index && curtree->nodep[curtree->nodep[j-1]->back->index - 1]->deleted )
retree.c:    else if ( curtree->nodep[j-1] == curtree->nodep[curtree->nodep[i-1]->back->index -1] )
retree.c:      for ( p = curtree->nodep[j-1]; p != curtree->root; p = curtree->nodep[p->back->index - 1] )
retree.c:        if ( p == curtree->nodep[i-1] )
retree.c:            exxit(-1);
retree.c:          if ( curtree->nodep[j - 1]->deleted || curtree->nodep[j - 1]->tip )
retree.c:          else if ( curtree->nodep[j-1] == curtree->nodep[curtree->nodep[i-1]->back->index -1] )
retree.c:            re_move(curtree, &curtree->nodep[i - 1], &q);
retree.c:            add_child(curtree, curtree->nodep[j - 1], curtree->nodep[i - 1]);
retree.c:              consolidatetree(q->index);
retree.c:          if (j == curtree->root->index) /* can't insert at root */
retree.c:            re_move(curtree, &(curtree->nodep[i - 1]), &q);
retree.c:              curtree->nodep[q->index-1]->next->back = curtree->nodep[i-1];
retree.c:              curtree->nodep[i-1]->back = curtree->nodep[q->index-1]->next;
retree.c:            add_before(curtree, curtree->nodep[j - 1], curtree->nodep[i - 1]);
retree.c:  if (p->tip)
retree.c:  q = p->next;
retree.c:    if (q->next->next == p)
retree.c:      r = q->next;
retree.c:    q = q->next;
retree.c:    lprev->next = r;
retree.c:    rprev->next = l;
retree.c:    temp = r->next;
retree.c:    r->next = l->next;
retree.c:    l->next = temp;
retree.c:    if (i < (loopcount - 1))
retree.c:      q = p->next;
retree.c:        if (q == lprev->next && !lprevflag)
retree.c:          l = q->next;
retree.c:        if (q->next == rprev)
retree.c:          r = q->next;
retree.c:        q = q->next;
retree.c:    q = p->next;
retree.c:      fliptrav(q->back, true);
retree.c:      q = q->next;
retree.c:  /* flip at a node left-right */
retree.c:      ok = !any_deleted(curtree->nodep[i - 1]);
retree.c:    fliptrav(curtree->nodep[i - 1], true);
retree.c:  if ((i >= 1 && i <= spp) || (i > spp && i <= nonodes && any_deleted(curtree->nodep[i - 1])))
retree.c:  /* flip at a node left-right */
retree.c:      ok = !curtree->nodep[i - 1]->deleted;
retree.c:    fliptrav(curtree->nodep[i - 1], false);
retree.c:  if ((i >= 1 && i <= spp) || (i > spp && i <= nonodes && curtree->nodep[i - 1]->deleted))
retree.c:  if (p->tip)
retree.c:    (*localdl) = ((*localdl) || p->deleted);
retree.c:  q = p->next;
retree.c:    (*localdl) = ((*localdl) || q->deleted);
retree.c:    ifdeltrav(q->back, localdl);
retree.c:    q = q->next;
retree.c:  if (p->deleted)
retree.c:  if (p->tip)
retree.c:    p->beyond = 0.0;
retree.c:    q = p->next;
retree.c:      templen = q->back->deleted ? 0.0 : q->length + oltrav(q->back);
retree.c:      q->beyond = templen;
retree.c:      q = q->next;
retree.c:    p->beyond = maxlen;
retree.c:  oltrav(curtree->root);
retree.c:  p = curtree->root;
retree.c:  q = p->next;
retree.c:  grnode = q->back;
retree.c:  q = curtree->root->next;
retree.c:    q = p->next;
retree.c:  } while (q != curtree->root);
retree.c:  p = curtree->root;
retree.c:  q = curtree->root->next;
retree.c:    if (greatlen <= q->beyond)
retree.c:      greatlen = q->beyond;
retree.c:      grnode = q->back;
retree.c:    if ((greatlen > q->beyond) && (q->beyond >= lesslen))
retree.c:      lesslen = q->beyond;
retree.c:      lsnode = q->back;
retree.c:    q = q->next;
retree.c:  /* If we don't have two non-deleted nodes to balance between then we can't midpoint root the tree */
retree.c:  if (grnode->deleted || lsnode->deleted || grnode == lsnode)
retree.c:  balance = greatlen - (greatlen + lesslen) / 2.0;
retree.c:  grlen = grnode->length;
retree.c:  while ((balance - grlen > 1e-10) && ok)
retree.c:    q = p->next;
retree.c:    maxnode = q->back;
retree.c:      if (maxlen <= q->beyond)
retree.c:        maxlen = q->beyond;
retree.c:        maxnode = q->back;
retree.c:      q = q->next;
retree.c:    p = curtree->root;
retree.c:    q = p->next;
retree.c:    grnode = q->back;
retree.c:      if (greatlen <= q->beyond)
retree.c:        greatlen = q->beyond;
retree.c:        grnode = q->back;
retree.c:      if ((greatlen > q->beyond) && (q->beyond >= lesslen))
retree.c:        lesslen = q->beyond;
retree.c:        lsnode = q->back;
retree.c:      q = q->next;
retree.c:    if (grnode->deleted || lsnode->deleted || grnode == lsnode)
retree.c:    balance = greatlen - (greatlen + lesslen) / 2.0;
retree.c:    grlen = grnode->length;
retree.c:      p = curtree->root;
retree.c:      q = p->next;
retree.c:      grnode = q->back;
retree.c:        if (greatlen <= q->beyond)
retree.c:          greatlen = q->beyond;
retree.c:          grnode = q->back;
retree.c:        if ((greatlen > q->beyond) && (q->beyond >= lesslen))
retree.c:          lesslen = q->beyond;
retree.c:          lsnode = q->back;
retree.c:        q = q->next;
retree.c:      balance = greatlen - (greatlen + lesslen) / 2.0;
retree.c:    grnode->length -= balance;
retree.c:    if (((grnode->length) < 0.0) && (grnode->length > -1.0e-10))
retree.c:      grnode->length = 0.0;
retree.c:    grnode->back->length = grnode->length;
retree.c:    if (((lsnode->length) < 0.0) && (lsnode->length > -1.0e-10))
retree.c:      lsnode->length = 0.0;
retree.c:    lsnode->length += balance;
retree.c:    lsnode->back->length = lsnode->length;
retree.c:    if (any_deleted(curtree->root))
retree.c:  p->deleted = value;
retree.c:  if (p->tip)
retree.c:  q = p->next;
retree.c:    deltrav(q->back, value);
retree.c:    q = q->next;
retree.c:  if ( p->next == NULL) return;
retree.c:  q=p->next;
retree.c:    fill_del(q->back);
retree.c:    q=q->next;
retree.c:  q=p->next;
retree.c:    if ( !q->back->deleted )
retree.c:    q=q->next;
retree.c:  p->deleted = alldell;
retree.c:  fill_del(curtree->root);
retree.c:  return(curtree->nodep[nodenum - 1]->deleted);
retree.c:  ok1 = (ok1 && i >= 1 && i <= nonodes && i != curtree->root->index && !isdeleted(i));
retree.c:    reg_del(curtree->nodep[i - 1], true);
retree.c:  ok1 = (ok1 && i >= 1 && i < spp * 2 && isdeleted(i) && ( i == curtree->root->index || !curtree->nodep[curtree->nodep[i - 1]->back->index - 1]->deleted));
retree.c:    reg_del(curtree->nodep[i - 1], false);
retree.c:  if (any_deleted(curtree->root))
retree.c:        exxit(-1);
retree.c:  /* Count the non-deleted branches hanging off of this node into branchcount.
retree.c:  if (p->tip)
retree.c:  q = p->next;
retree.c:    if (!q->back->deleted)
retree.c:      if (!q->back->tip)
retree.c:        treetrav(q->back);
retree.c:      if (!q->back->deadend && !q->back->deleted)
retree.c:        onebranchp = q->back;
retree.c:    q = q->next;
retree.c:    p->deadend = true;
retree.c:    p->deadend = false;
retree.c:  p->onebranch = false;
retree.c:  if (branchcount == 1 && onebranchp->tip)
retree.c:    p->onebranch = true;
retree.c:    p->onebranchnode = onebranchp;
retree.c:    p->onebranchhaslength = (p->haslength || (p == curtree->root)) && onebranchp->haslength;
retree.c:    if (p->onebranchhaslength)
retree.c:      p->onebranchlength = onebranchp->length + p->length;
retree.c:  if (branchcount == 1 && !onebranchp->tip)
retree.c:    p->onebranch = true;
retree.c:    if (onebranchp->onebranch)
retree.c:      p->onebranchnode = onebranchp->onebranchnode;
retree.c:      p->onebranchhaslength = (p->haslength || (p == curtree->root)) && onebranchp->onebranchhaslength;
retree.c:      if (p->onebranchhaslength)
retree.c:        p->onebranchlength = onebranchp->onebranchlength + p->length;
retree.c:      p->onebranchnode = onebranchp;
retree.c:      p->onebranchhaslength = p->haslength && onebranchp->haslength;
retree.c:      if (p->onebranchhaslength)
retree.c:        p->onebranchlength = onebranchp->length + p->length;
retree.c:  tonode->index   = fromnode->index;
retree.c:  tonode->deleted = fromnode->deleted;
retree.c:  tonode->tip     = fromnode->tip;
retree.c:  tonode->hasname = fromnode->hasname;
retree.c:  if (fromnode->hasname)
retree.c:      tonode->nayme[i] = fromnode->nayme[i];
retree.c:  tonode->haslength = fromnode->haslength;
retree.c:  if (fromnode->haslength)
retree.c:    tonode->length = fromnode->length;
retree.c:// BUG.967 -- we are mixing two trees here -- careful
retree.c:  newnode = desttree->get_forknode(desttree, srcNode->index); // BUG.967 worried about index
retree.c:  if (srctree->nodep[srcNode->index - 1] == srcNode)
retree.c:    desttree->nodep[srcNode->index - 1] = newnode;
retree.c:  if (srcNode->tip)
retree.c:  if (srcNode->onebranch && srcNode->onebranchnode->tip)
retree.c:    simcopynode(srcNode->onebranchnode, newnode);
retree.c:    if (srcNode->onebranchhaslength)
retree.c:      newnode->length = srcNode->onebranchlength;
retree.c:  else if (srcNode->onebranch && !srcNode->onebranchnode->tip)
retree.c:    /* recurse down p->onebranchnode */
retree.c:    srcNode->onebranchnode->length = srcNode->onebranchlength;
retree.c:    srcNode->onebranchnode->haslength = srcNode->onebranchnode->haslength;
retree.c:    return simcopytrav(srctree, srcNode->onebranchnode, desttree);
retree.c:    /* Multiple non-deleted branch case:  go round the node recursing
retree.c:    q = srcNode->next;
retree.c:      if (!q->back->deleted && !q->back->deadend)
retree.c:        lastnodeidx = q->back->index;
retree.c:      q = q->next;
retree.c:    q = srcNode->next;
retree.c:    newnextnode = desttree->get_forknode(desttree, q->index); // BUG.967 worried about index
retree.c:    newnode->next = newnextnode;
retree.c:      if (!q->back->deleted && !q->back->deadend)
retree.c:        newnextnode->back = simcopytrav(srctree, q->back, desttree);
retree.c:        newnextnode->back->back = newnextnode;
retree.c:        q = q->next;
retree.c:        if (newnextnode->back->index == lastnodeidx)
retree.c:          newnextnode->next = newnode;
retree.c:          newnextnode->next = newnode;
retree.c:          newnextnode = desttree->get_forknode(desttree, q->index); // BUG.967 worried about index
retree.c:          temp->next = newnextnode;
retree.c:      { /*xx this else and q=q->next are experimental
retree.c:        q = q->next;
retree.c:  simplifiedtree.tree_p->root = simcopytrav(curtree, curtree->root, simplifiedtree.tree_p);
retree.c:    w = (long)(0.43429448222 * log(-x)) + 1;
retree.c:  /* If this is a tip or there are no non-deleted branches from this node, render this node as a tip (write its name).  */
retree.c:  if (p == curtree->root)
retree.c:  if (p->tip)
retree.c:    if (p->hasname)
retree.c:        if ((curtree->nodep[p->index - 1]->nayme[i - 1] != '\0') && (curtree->nodep[p->index - 1]->nayme[i - 1] != ' '))
retree.c:        if (p->haslength)
retree.c:          x = p->length;
retree.c:        c = curtree->nodep[p->index - 1]->nayme[i];
retree.c:  else if (p->onebranch && p->onebranchnode->tip)
retree.c:    if (p->onebranchnode->hasname)
retree.c:        if ((curtree->nodep[p->index - 1]->nayme[i - 1] != '\0') && (curtree->nodep[p->index - 1]->nayme[i - 1] != ' '))
retree.c:        if ((p->haslength && writeparens) || p->onebranch)
retree.c:          if (!(p->onebranch && !p->onebranchhaslength))
retree.c:            if (p->onebranch)
retree.c:              x = p->onebranchlength;
retree.c:              x = p->length;
retree.c:        c = p->onebranchnode->nayme[i];
retree.c:  else if (p->onebranch && !p->onebranchnode->tip)
retree.c:    treeout(p->onebranchnode, true, 0.0, indent, true);
retree.c:    /* Multiple non-deleted branch case:  go round the node
retree.c:      if (p == curtree->root)
retree.c:    if (p != curtree->root)
retree.c:        if ((p->haslength && writeparens) || p->onebranch)
retree.c:          if (!(p->onebranch && !p->onebranchhaslength))
retree.c:            if (p->onebranch)
retree.c:              x = p->onebranchlength;
retree.c:              x = p->length;
retree.c:    q = p->next;
retree.c:      if (!q->back->deleted && !q->back->deadend)
retree.c:        lastnodeidx = q->back->index;
retree.c:      q = q->next;
retree.c:    q = p->next;
retree.c:      if (!q->back->deleted && !q->back->deadend)
retree.c:        treeout(q->back, true, 0.0, indent, true);
retree.c:      if (q->back->index == lastnodeidx)
retree.c:      q = q->next;
retree.c:      if ((q->next == p) && (q->back->deleted || q->back->deadend))
retree.c:    if (p != curtree->root)
retree.c:          indent -= 2;
retree.c:          indent -= 2;
retree.c:    if ((p->haslength && writeparens) || p->onebranch)
retree.c:      if (!(p->onebranch && !p->onebranchhaslength))
retree.c:        if (p->onebranch)
retree.c:          x = p->onebranchlength;
retree.c:          x = p->length;
retree.c:  if (p == curtree->root)
retree.c:    *p = curtree->get_forknode(curtree, index);
retree.c:    (*p)->index = index;
retree.c:    (*p)->hasname = false;
retree.c:    (*p)->haslength = false;
retree.c:    (*p)->deleted=false;
retree.c:    (*p)->deadend=false;
retree.c:    (*p)->onebranch=false;
retree.c:    (*p)->onebranchhaslength=false;
retree.c:      (*p)->nayme[j] = '\0';
retree.c:    (*p)->next = q;
retree.c:  (*p)->next->next->next = *p;
retree.c:  q = (*p)->next;
retree.c:    (*p)->back = NULL;
retree.c:    (*p)->tip = false;
retree.c:    *p = (*p)->next;
retree.c:  treetrav(curtree->root);
retree.c:  treesets[whichtree].tree_p->root = curtree->root;        /* Store the current root */
retree.c:  curtree->root = simplifiedtree.tree_p->root;                /* Point root at simplified tree */
retree.c:  curtree->root->haslength = false;              /* Root should not have a length */
retree.c:  if (curtree->root->tip)
retree.c:    if (curtree->root->next->next->next == curtree->root)
retree.c:    treeout(curtree->root, true, 0.0, 0, true);
retree.c:  curtree->root = treesets[whichtree].tree_p->root;     /* Point root at original (real) tree */
retree.c:  newbase->next->back = curtree->root->next->back;
retree.c:  newbase->next->next->back = curtree->root;
retree.c:  if (newbase->next->back->haslength)
retree.c:    newbase->next->back->length /= 2.0;
retree.c:    newbase->next->next->back->length =
retree.c:      newbase->next->back->length;
retree.c:    newbase->next->next->back->haslength = true;
retree.c:  temp = curtree->root->next->next;
retree.c:  curtree->root->next = temp;
retree.c:  curtree->root = newbase;
retree.c:  treeout(curtree->root, true, 0.0, 0, true);
retree.c:  /* Use the leftmost non-tip immediate descendant of the root,
retree.c:  curtree->root = simplifiedtree.tree_p->root;
retree.c:  /* first, search for leftmost non-tip immediate descendent of root */
retree.c:  q = curtree->root->next->back;
retree.c:  r = curtree->root->next->next->back;
retree.c:  if (q->tip && r->tip)
retree.c:    treeout(curtree->root, true, 0.0, 0, false);
retree.c:  else if (!(q->tip))
retree.c:    newbase = curtree->get_forknode(curtree, 0); // BUG.967 there a better index than 0 ??
retree.c:    newbase->next = q->next;
retree.c:    q->next = newbase;
retree.c:    q->back = r;
retree.c:    r->back = q;
retree.c:    if (q->haslength && r->haslength)
retree.c:      sumlength = q->length + r->length;
retree.c:      q->length = sumlength;
retree.c:      q->back->length = sumlength;
retree.c:      q->haslength = false;
retree.c:      r->haslength = false;
retree.c:    curtree->root = newbase;
retree.c:    treeout(curtree->root, true, 0.0, 0, false);
retree.c:  else if (q-tip && !(r->tip))
retree.c:      temp = temp->next;
retree.c:    } while (temp->next != r);
retree.c:    newbase = curtree->get_forknode(curtree, 0); // BUG.967 there a better index than 0 ??
retree.c:    newbase->next = temp->next;
retree.c:    temp->next = newbase;
retree.c:    q->back = r;
retree.c:    r->back = q;
retree.c:    if (q->haslength && r->haslength)
retree.c:      sumlength = q->length + r->length;
retree.c:      q->length = sumlength;
retree.c:      q->back->length = sumlength;
retree.c:      q->haslength = false;
retree.c:      r->haslength = false;
retree.c:    curtree->root = newbase;
retree.c:    treeout(curtree->root, true, 0.0, 0, false);
retree.c:  if ( curtree->root->deleted )
retree.c:      exxit(-1);
retree.c:        leftedge -= hscroll;
retree.c:      if (treelines - topedge + 3 >= screenlines)
retree.c:        topedge -= vscroll;
retree.c:        if (hscroll > leftedge - vscreenwidth + 1)
retree.c:      exxit(-1);
retree.c:      ok = (ok && !curtree->nodep[i - 1]->deleted);
retree.c:      ok = (curtree->nodep[i - 1] != curtree->root);
retree.c:      exxit(-1);
retree.c:    p = curtree->nodep[i - 1];
retree.c:    if (p->haslength)
retree.c:      x = p->length;
retree.c:        w = (long)(0.43429448222 * log(-x)) + 1;
retree.c:    hslngth = p->haslength;
retree.c:        p->length = length;
retree.c:        p->haslength = true;
retree.c:        if (p->back != NULL)
retree.c:          p->back->length = length;
retree.c:          p->back->haslength = true;
retree.c:        p->haslength = false;
retree.c:        if (p->back != NULL)
retree.c:          p->back->haslength = false;
retree.c:        exxit(-1);
retree.c:        curtree->nodep[i]->haslength = false;
retree.c:        if (curtree->nodep[i] != NULL)
retree.c:          curtree->nodep[i]->haslength = false;
retree.c:          curtree->nodep[i]->next->haslength = false;
retree.c:          curtree->nodep[i]->next->next->haslength = false;
retree.c:        if (!curtree->nodep[i - 1]->deleted)
retree.c:    if (curtree->nodep[tipno - 1]->hasname)
retree.c:        if (curtree->nodep[tipno - 1]->nayme[i - 1] != '\0')
retree.c:        putchar(curtree->nodep[tipno - 1]->nayme[i]);
retree.c:      curtree->nodep[tipno - 1]->nayme[i] = ' ';
retree.c:    strncpy(curtree->nodep[tipno-1]->nayme, tipname, MAXNCH);
retree.c:    curtree->nodep[tipno - 1]->hasname = true;
retree.c:      nuroot = curtree->nodep[i - 1];
retree.c:      nuroot = curtree->root;
retree.c:    ok = (ok && i >= 1 && i <= nonodes && i != curtree->root->index);
retree.c:      ok = (ok && !curtree->nodep[i - 1]->deleted);
retree.c:      ok = !curtree->nodep[curtree->nodep[i - 1]->back->index - 1]->deleted;
retree.c:      exxit(-1);
retree.c:  reroot(curtree, curtree->nodep[outgrno - 1]);
retree.c:        exxit(-1);
retree.c:        exxit(-1);
retree.c:    curtree->root = treesets[whichtree].tree_p->root;
retree.c:  curtree->root = treesets[whichtree].tree_p->root;
retree.c:  //drawit(fontname, &xoffset, &yoffset, numlines, curtree->root);
seqboot.c:/* Version 4.0. (c) Copyright 1993-2013 by the University of Washington.
seqboot.c:double fracsample = 0.5; /* ...or user-defined sample freq, [0..inf) */
seqboot.c:/* [0..spp-1][0..sites-1] */
seqboot.c:Char *factor = NULL;  /* factor[sites] - direct read-in of factors file */
seqboot.c:long *factorr = NULL; /* [0..sites-1] => nondecreasing [1..groups] */
seqboot.c:/* Mapping with read-in weights eliminated
seqboot.c:long *newwhere   = NULL;    /* Map [0..newgroups-1] => [1..newsites] */
seqboot.c:long *newhowmany = NULL;    /* Number of chars for each [0..newgroups-1] */
seqboot.c:long *newerfactor  = NULL;  /* Map [0..newersites-1] => [1..newergroups] */
seqboot.c:long *newerwhere   = NULL;  /* Map [0..newergroups-1] => [1..newersites] */
seqboot.c:long *newerhowmany = NULL;  /* Number of chars for each [0..newergroups-1] */
seqboot.c:long **charorder   = NULL;  /* Permutation [0..spp-1][0..newergroups-1] */
seqboot.c:long **sppord      = NULL;  /* Permutation [0..newergroups-1][0..spp-1] */
seqboot.c:           regular && jackknife ? "Delete-half jackknife" :
seqboot.c:           (!regular) && jackknife ? "Delete-fraction jackknife" :
seqboot.c:        if (fabs(fracsample*100 - (int)(fracsample*100)) > 0.01)
seqboot.c:        printf("  B      Block size for block-bootstrapping?  %ld\n", blocksize);
seqboot.c:        printf("  B      Block size for block-bootstrapping?  %ld (regular bootstrap)\n", blocksize);
seqboot.c:      printf("  .     Use dot-differencing to display them  %s\n",
seqboot.c:    exxit(-1);
seqboot.c:      exxit(-1);
seqboot.c:        exxit(-1);
seqboot.c:        sites += alleles[i] - 1;
seqboot.c:      maxalleles--;
seqboot.c:        m = alleles[i] - 1;
seqboot.c:        factorr[l - 1] = k;
seqboot.c:      factorr[i - 1] = i;
seqboot.c:    how_many[factorr[i - 1] - 1]++;
seqboot.c:    if (where[factorr[i - 1] - 1] == 0)
seqboot.c:      where[factorr[i - 1] - 1] = i;
seqboot.c:  groups = factorr[sites - 1];
seqboot.c:    if (oldweight[where[i] - 1] > 0)
seqboot.c:      newwhere[newgroups - 1] = where[i];
seqboot.c:      newhowmany[newgroups - 1] = how_many[i];
seqboot.c:  j = nmlngth + (sites + (sites - 1) / 10) / 2 - 5;
seqboot.c:  if (j < nmlngth - 1)
seqboot.c:    j = nmlngth - 1;
seqboot.c:          fprintf(outfile, "Block-bootstrap with block size %ld\n\n", blocksize);
seqboot.c:          fprintf(outfile, "Partial (%2.0f%%) block-bootstrap with block size %ld\n\n",
seqboot.c:          fprintf(outfile, "Delete-half Jackknife\n\n");
seqboot.c:          fprintf(outfile, "Delete-%2.0f%% Jackknife\n\n", 100*(1.0-fracsample));
seqboot.c:    fprintf(outfile, "----");
seqboot.c:    fprintf(outfile, "----\n\n");
seqboot.c:      initname(i - 1);
seqboot.c:          exxit(-1);
seqboot.c:          exxit(-1);
seqboot.c:          nodef[i - 1][j - 1] = x;
seqboot.c:    /* eat white space -- if the separator line has spaces on it*/
seqboot.c:        initname(i-1);
seqboot.c:            charstate = nodep[0][j-1];
seqboot.c:          nodep[i-1][j-1] = charstate;
seqboot.c:        exxit(-1);
seqboot.c:    m = (sites - 1) / 8 + 1;
seqboot.c:    m = (sites - 1) / 60 + 1;
seqboot.c:        n = (i - 1) * 8;
seqboot.c:        n = (i - 1) * 60;
seqboot.c:    /* q -> number of sites remaining to sample
seqboot.c:     * r -> number of sites remaining
seqboot.c:     * p = q / r -> chance that next site is sampled */
seqboot.c:    if (fabs(newgroups*fracsample - (long)(newgroups*fracsample+0.5)) > 0.00001)
seqboot.c:          < (newgroups*fracsample - (long)(newgroups*fracsample))
seqboot.c:          /((long)(newgroups*fracsample+1.0)-(long)(newgroups*fracsample)))
seqboot.c:        q--;
seqboot.c:      r--;
seqboot.c:        weight[j - 1]++;
seqboot.c:    exxit(-1);
seqboot.c:  permute_vec(sppord[n-1], spp);
seqboot.c:    sppord[0][j - 1] = j;
seqboot.c:      sppord[i][j - 1] = sppord[i - 1][j - 1];
seqboot.c:              case (dna): fprintf(outfile, "DNA missing=N gap=-"); break;
seqboot.c:              case (rna): fprintf(outfile, "RNA missing=N gap=-"); break;
seqboot.c:                fprintf(outfile, "protein missing=? gap=-");
seqboot.c:        fprintf(outfile, " %3ld", alleles[factorr[newerwhere[i] - 1] - 1]);
seqboot.c:  /* When rewriting to PHYLIP, only convert interleaved <-> sequential
seqboot.c:          while (nayme[j][n2-1] == ' ')
seqboot.c:            n2--;
seqboot.c:        for (k = 0; k < nmlngth-n2; k++)
seqboot.c:      for (k = l - 1; k < m; k++)
seqboot.c:        for (n2 = -1; n2 <= (newerhowmany[charorder[j][k]] - 2); n2++)
seqboot.c:            x = nodef[sppord[charorder[j][k]][j] - 1][newerwhere[charorder[j][k]] + n2];
seqboot.c:            charstate = nodep[sppord[charorder[j][k]][j] - 1][newerwhere[charorder[j][k]] + n2];
seqboot.c:{ /* write out one set of post-bootstrapping weights */
seqboot.c:    for (k = l - 1; k < m; k++)
seqboot.c:          if (weight[k-j] < 10)
seqboot.c:            fprintf(outweightfile, "%c", (char)('0'+weight[k-j]));
seqboot.c:            fprintf(outweightfile, "%c", (char)('A'+weight[k-j]-10));
seqboot.c:      for(k=l-1 ; k < m ; k++)
seqboot.c:    for (k = l - 1; k < m; k++)
seqboot.c:      for (n2 = -1; n2 <= (newerhowmany[k] - 2); n2++)
seqboot.c:        for(k=l-1 ; k < m ; k++)
seqboot.c:    for (k = l - 1; k < m; k++)
seqboot.c:      for (n2 = -1; n2 <= (newerhowmany[k] - 2); n2++)
seqboot.c:  //steptr wfactor;                       // RSGnote: "wfactor" is written-to but never read.
seqboot.c:      for(k=l-1 ; k < m ; k++)
seqboot.c:        symbol = (symbol == '+') ? '-' : '+';
seq.c:/* Version 4.0. (c) Copyright 1993-2013 by the University of Washington.
seq.c:    /* eat white space -- if the separator line has spaces on it*/
seq.c:        initname(i-1);
seq.c:          if ((strchr("ABCDGHKMNRSTUVWXY?O-", charstate)) == NULL)
seq.c:              printf("        The correct gap character is (-).\n");
seq.c:            exxit(-1);
seq.c:          inputSequences[i - 1][j - 1] = charstate;
seq.c:        exxit(-1);
seq.c:  headings(nchars, "Sequences", "---------");
seq.c:  for (i = 1; i <= ((nchars - 1) / 60 + 1); i++)
seq.c:        putc(nayme[j - 1][k], outfile);
seq.c:      for (k = (i - 1) * 60 + 1; k <= l; k++)
seq.c:        if (dotdiff && (j > 1 && inputSequences[j - 1][k - 1] == inputSequences[0][k - 1]))
seq.c:          charstate = inputSequences[j - 1][k - 1];
seq.c:      treenode[i-1]->back = NULL;
seq.c:      treenode[i-1]->init(treenode[i-1], i<=spp, i);
seq.c:      treenode[i-1]->iter = true;
seq.c:      treenode[i-1]->initialized = true;
seq.c:      p = treenode[i-1]->next;
seq.c:      while (p != treenode[i-1])
seq.c:        p->back = NULL;
seq.c:        p->init(p, false, i);
seq.c:        p->iter = true;
seq.c:        p->initialized = false;
seq.c:        p = p->next;
seq.c:  fprintf(fp, "   A    %10.5f\n", freq->a);
seq.c:  fprintf(fp, "   C    %10.5f\n", freq->c);
seq.c:  fprintf(fp, "   G    %10.5f\n", freq->g);
seq.c:  fprintf(fp, "  T(U)  %10.5f\n", freq->t);
seq.c:  freq->a = freqa;
seq.c:  freq->c = freqc;
seq.c:  freq->g = freqg;
seq.c:  freq->t = freqt;
seq.c:  freq->r = freqa + freqg;
seq.c:  freq->y = freqc + freqt;
seq.c:  freq->ar = freq->a / freq->r;
seq.c:  freq->cy = freq->c / freq->y;
seq.c:  freq->gr = freq->g / freq->r;
seq.c:  freq->ty = freq->t / freq->y;
seq.c:  aa = ttratio * freq->r * freq->y - freqa * freqg - freqc * freqt;
seq.c:  bb = freqa * freq->gr + freqc * freq->ty;
seq.c:  freq->xi = aa / (aa + bb);
seq.c:  freq->xv = 1.0 - freq->xi;
seq.c:  if (freq->xi < 0.0)
seq.c:    freq->xi = 0.0;
seq.c:    freq->xv = 1.0;
seq.c:    ttratio = (freq->a*freq->g+freq->c*freq->t)/(freq->r*freq->y);
seq.c:  freq->fracchange = freq->xi * (2 * freqa * freq->gr + 2 * freqc * freq->ty) +
seq.c:    freq->xv *
seq.c:    (1.0 - freqa*freqa - freqc*freqc
seq.c:     - freqg*freqg - freqt*freqt );
seq.c:  freq->ttratio = ttratio;
seq.c:      j = i - gap;
seq.c:        jj = alias[j - 1];
seq.c:        jg = alias[j + gap - 1];
seq.c:          flip = (inputSequences[k - 1][jj - 1] > inputSequences[k - 1][jg - 1]);
seq.c:          tied = (tied && inputSequences[k - 1][jj - 1] == inputSequences[k - 1][jg - 1]);
seq.c:        itemp = alias[j - 1];
seq.c:        alias[j - 1] = alias[j + gap - 1];
seq.c:        alias[j + gap - 1] = itemp;
seq.c:        itemp = weight[j - 1];
seq.c:        weight[j - 1] = weight[j + gap - 1];
seq.c:        weight[j + gap - 1] = itemp;
seq.c:        j -= gap;
seq.c:        tied = (tied && inputSequences[k - 1][alias[i - 1] - 1] == inputSequences[k - 1][alias[j - 1] - 1]);
seq.c:        weight[i - 1] += weight[j - 1];
seq.c:        weight[j - 1] = 0;
seq.c:        ally[alias[j - 1] - 1] = alias[i - 1];
seq.c:    i = j - 1;
seq.c:    if (ally[alias[i - 1] - 1] != alias[i - 1])
seq.c:          found = (ally[alias[j - 1] - 1] == alias[j - 1]);
seq.c:          j--;
seq.c:          itemp = alias[i - 1];
seq.c:          alias[i - 1] = alias[j - 1];
seq.c:          alias[j - 1] = itemp;
seq.c:          itemp = weight[i - 1];
seq.c:          weight[i - 1] = weight[j - 1];
seq.c:          weight[j - 1] = itemp;
seq.c:     alias[i-1] is the number of the site that comes ith in lexicographical
seq.c:     aliasweight[i-1] will end up as the weight of all sites that have
seq.c:      j = i - gap;
seq.c:        jj = alias[j - 1];
seq.c:        jg = alias[j + gap - 1];
seq.c:        tied = (category[jj - 1] == category[jg - 1]);
seq.c:        flip = (category[jj - 1] > category[jg - 1]);
seq.c:          flip = (inputSequences[k - 1][jj - 1] > inputSequences[k - 1][jg - 1]);
seq.c:          tied = (tied && inputSequences[k - 1][jj - 1] == inputSequences[k - 1][jg - 1]);
seq.c:        itemp = alias[j - 1];
seq.c:        alias[j - 1] = alias[j + gap - 1];
seq.c:        alias[j + gap - 1] = itemp;
seq.c:        itemp = aliasweight[j - 1];
seq.c:        aliasweight[j - 1] = aliasweight[j + gap - 1];
seq.c:        aliasweight[j + gap - 1] = itemp;
seq.c:        j -= gap;
seq.c:     ally[i-1] ends up as the number of the site (in the original site
seq.c:      tied = (category[alias[i - 1] - 1] == category[alias[j - 1] - 1]);
seq.c:        tied = (tied && inputSequences[k - 1][alias[i - 1] - 1] == inputSequences[k - 1][alias[j - 1] - 1]);
seq.c:      aliasweight[i - 1] += aliasweight[j - 1];
seq.c:      aliasweight[j - 1] = 0;
seq.c:      ally[alias[j - 1] - 1] = alias[i - 1];
seq.c:    if (aliasweight[i - 1] > 0)
seq.c:          found = (aliasweight[j - 1] > 0);
seq.c:          j--;
seq.c:          itemp = alias[i - 1];
seq.c:          alias[i - 1] = alias[j - 1];
seq.c:          alias[j - 1] = itemp;
seq.c:          itemp = aliasweight[i - 1];
seq.c:          aliasweight[i - 1] = aliasweight[j - 1];
seq.c:          aliasweight[j - 1] = itemp;
seq.c:  assert(p->index > 0);                 // RSGdebug
seq.c:  if (i == (long)p->ycoord && p == root)
seq.c:    if (p->index - spp >= 10)
seq.c:      fprintf(outfile, " %2ld", p->index - spp);
seq.c:      fprintf(outfile, "  %ld", p->index - spp);
seq.c:    if (!p->tip)
seq.c:      r = p->next;
seq.c:        if (i >= r->back->ymin && i <= r->back->ymax)
seq.c:          q = r->back;
seq.c:        r = r->next;
seq.c:      first = p->next->back;
seq.c:      r = p->next;
seq.c:      while (r->next != p)
seq.c:        r = r->next;
seq.c:      last = r->back;
seq.c:    n = (long)(scale * (p->xcoord - q->xcoord) + 0.5);
seq.c:    if (n < 3 && !q->tip)
seq.c:      n--;
seq.c:    if ((long)q->ycoord == i && !done)
seq.c:        putc('-', outfile);
seq.c:      if (!q->tip)
seq.c:        for (j = 1; j <= n - 2; j++)
seq.c:          putc('-', outfile);
seq.c:        assert(q->index > 0);           // RSGdebug
seq.c:        if (q->index - spp >= 10)
seq.c:          fprintf(outfile, "%2ld", q->index - spp);
seq.c:          fprintf(outfile, "-%ld", q->index - spp);
seq.c:          putc('-', outfile);
seq.c:    else if (!p->tip)
seq.c:      if ((long)last->ycoord > i && (long)first->ycoord < i && i != (long)p->ycoord)
seq.c:  if ((long)p->ycoord == i && p->tip)
seq.c:    assert(p->index > 0);               // RSGdebug
seq.c:      putc(nayme[p->index - 1][j], outfile);
seq.c:  assert(p->index > 0);                 // RSGdebug
seq.c:  if (p->tip)
seq.c:      if (nayme[p->index - 1][i - 1] != ' ')
seq.c:      c = nayme[p->index - 1][i];
seq.c:    q = p->next;
seq.c:      treeout(q->back, nextree, col, root);
seq.c:      q = q->next;
seq.c:    fprintf(outtree, "[%6.4f];\n", 1.0 / (nextree - 1));
seq.c:  p = curtree->root;
seq.c:  q = curtree->root;
seq.c:  assert(p->index > 0);                 // RSGdebug
seq.c:  if (i == (long)p->ycoord && p == curtree->root)
seq.c:    if (p->index - spp >= 10)
seq.c:      fprintf(outfile, " %2ld", p->index - spp);
seq.c:      fprintf(outfile, "  %ld", p->index - spp);
seq.c:    if (!p->tip)
seq.c:      r = p->next;
seq.c:        if (i >= r->back->ymin && i <= r->back->ymax)
seq.c:          q = r->back;
seq.c:        r = r->next;
seq.c:      } while (!(done || (p != curtree->root && r == p) || (p == curtree->root && r == p->next)));
seq.c:      first = p->next->back;
seq.c:      while (r->next != p)
seq.c:        r = r->next;
seq.c:      last = r->back;
seq.c:      if (p == curtree->root)
seq.c:        last = p->back;
seq.c:    done = (p->tip || p == q);
seq.c:    n = (long)(scale * (q->xcoord - p->xcoord) + 0.5);
seq.c:    if (n < 3 && !q->tip)
seq.c:      n--;
seq.c:    if ((long)q->ycoord == i && !done)
seq.c:      if ((long)p->ycoord != (long)q->ycoord)
seq.c:        putc('-', outfile);
seq.c:      if (!q->tip)
seq.c:        for (j = 1; j <= n - 2; j++)
seq.c:          putc('-', outfile);
seq.c:        assert(q->index > 0);           // RSGdebug
seq.c:        if (q->index - spp >= 10)
seq.c:          fprintf(outfile, "%2ld", q->index - spp);
seq.c:          fprintf(outfile, "-%ld", q->index - spp);
seq.c:          putc('-', outfile);
seq.c:    else if (!p->tip)
seq.c:      if ((long)last->ycoord > i && (long)first->ycoord < i && (i != (long)p->ycoord || p == curtree->root))
seq.c:  if ((long)p->ycoord == i && p->tip)
seq.c:      putc(nayme[p->index-1][j], outfile);
seq.c:{  /* do paired sites test (KHT or SH test) on user-defined trees */
seq.c:    fprintf(outfile, "Kishino-Hasegawa-Templeton test\n\n");
seq.c:      fprintf(outfile, "%3ld%10.1f", which, nsteps[which - 1] / 10);
seq.c:        fprintf(outfile, "  <------ best\n");
seq.c:            temp = (fsteps[which - 1][i] - fsteps[minwhich - 1][i]);
seq.c:        sd = sqrt(sumw / (sumw - 1.0) * (sum2 - sum * sum / sumw));
seq.c:        fprintf(outfile, "%10.1f%12.4f", (nsteps[which - 1] - minsteps) / 10, sd);
seq.c:  {           /* Shimodaira-Hasegawa test using normal approximation */
seq.c:      fprintf(outfile, "Shimodaira-Hasegawa test on first %d of %ld trees\n\n", MAXSHIMOTREES, numtrees);
seq.c:      fprintf(outfile, "Shimodaira-Hasegawa test\n\n");
seq.c:            temp = temp + wt*(fsteps[i][k]-sum)
seq.c:              *(fsteps[j][k]-sum2);
seq.c:    for (i = 0; i < numtrees; i++)   /* in-place Cholesky decomposition of trees x trees covariance matrix */
seq.c:      for (j = 0; j <= i-1; j++)
seq.c:        temp = sqrt(covar[i][i] - sum);
seq.c:        if (fabs(temp) < 1.0E-12)
seq.c:          covar[j][i] = (covar[j][i] - sum)/temp;
seq.c:        if (nsteps[j]-sum2 <= f[j] - sum)
seq.c:      if ((minwhich-1) == i)
seq.c:        fprintf(outfile, "  <------ best\n");
seq.c:        fprintf(outfile, " %9.1f  %10.3f", nsteps[i]-sum2, P[i]);
seq.c:{  /* do paired sites test (KHT or SH) for user-defined trees */
seq.c:    fprintf(outfile, "Kishino-Hasegawa-Templeton test\n\n");
seq.c:      fprintf(outfile, "%3ld %9.1f", which, l0gl[which - 1]);
seq.c:        fprintf(outfile, "  <------ best\n");
seq.c:            temp = l0gf[which - 1][i] - l0gf[maxwhich - 1][i];
seq.c:        sd = sqrt(sumw / (sumw - 1.0) * (sum2 - sum * sum / sumw ));
seq.c:        fprintf(outfile, "%10.1f %11.4f", (l0gl[which - 1])-maxlogl, sd);
seq.c:        if ((sum < 0.0) && ((-sum) > 1.95996 * sd))
seq.c:  {           /* Shimodaira-Hasegawa test using normal approximation */
seq.c:      fprintf(outfile, "Shimodaira-Hasegawa test on first %d of %ld trees\n\n", MAXSHIMOTREES, numtrees);
seq.c:      fprintf(outfile, "Shimodaira-Hasegawa test\n\n");
seq.c:            temp = temp + wt * (l0gf[i][k]-sum) * (l0gf[j][k]-sum2);
seq.c:    for (i = 0; i < numtrees; i++)  /* in-place Cholesky decomposition of trees x trees covariance matrix */
seq.c:      for (j = 0; j <= i-1; j++)
seq.c:        temp = sqrt(covar[i][i] - sum);
seq.c:        if (fabs(temp) < 1.0E-12)
seq.c:          covar[j][i] = (covar[j][i] - sum)/temp;
seq.c:        if (maxlogl-l0gl[j] <= sum-f[j])
seq.c:      if ((maxwhich-1) == i)
seq.c:        fprintf(outfile, "  <------ best\n");
seq.c:        fprintf(outfile, " %9.1f  %10.3f", l0gl[i]-maxlogl, P[i]);
Slist.c: * Implementation of singly-linked list
Slist.c:  node->data = data;
Slist.c:  node->next = NULL;
Slist.c:  l->length = 0;
Slist.c:  l->first = NULL;
Slist.c:  l->last = NULL;
Slist.c:  for ( node = l->first; node != NULL; node = node->next )
Slist.c:  if ( i == l->length )
Slist.c:    printf("List %p->length is %ld, should be %ld!\n", (void *)l, l->length, i);
Slist.c:  return l->length == 0;
Slist.c:  if ( l->first == NULL )
Slist.c:    assert(l->last == NULL);
Slist.c:    l->last = node;
Slist.c:  node->next = l->first;
Slist.c:  l->first = node;
Slist.c:  l->length++;
Slist.c:  del = l->first;
Slist.c:  data = del->data;
Slist.c:  l->first = del->next;
Slist.c:  if ( l->first == NULL )
Slist.c:    l->last = NULL;
Slist.c:  l->length--;
Slist.c:  if ( l->last == NULL )
Slist.c:    assert( l->first == NULL);
Slist.c:    l->first = node;
Slist.c:    l->last->next = node;
Slist.c:  l->last = node;
Slist.c:  l->length++;
Slist.c:  iter->next = l->first;
Slist.c:  if ( iter->next == NULL )
Slist.c:  data = iter->next->data;
Slist.c:  iter->next = iter->next->next;
threshml.c:/* Version 4.0a. (c) Copyright 2004-2013 by the University of Washington.
threshml.c:    printf("  B                           Burn-in steps?  %ld\n", burnin);
threshml.c:              printf("Number of burn-in steps (must be nonnegative)?\n");
threshml.c:      exxit(-1);
threshml.c:      exxit(-1);
threshml.c:  alloctree(&curtree.nodep, 2*spp-1);
threshml.c:  setuptree(&curtree, 2*spp-1);
threshml.c:  /* allocview(&curtree, 2*spp-1, chars);  debug */
threshml.c:    fprintf(outfile, "----");
threshml.c:    fprintf(outfile, "                       ----------\n\n");
threshml.c:      if(fscanf(infile, "%lf", &x[k][j - 1]) < 1) // read them in
threshml.c:        exxit(-1);
threshml.c:        fprintf(outfile, " %9.5f", x[k][j - 1]);
threshml.c:      printf("\nERROR:  End-of-Line or End-of-File in the middle of species name.\n\n");
threshml.c:      exxit(-1);
threshml.c:      exxit(-1);
threshml.c:    headings(chars, "Characters", "-----------");
threshml.c:    /* eat white space -- if the separator line has spaces on it*/
threshml.c:        initname(i-1);   /* just take the name as is */
threshml.c:        getthisname();   /* take the name for the (i+1)-th species */
threshml.c:          exxit(-1);
threshml.c:            exxit(-1);
threshml.c:          yy[i - 1][j - 1] = charstate;            /* store the character */
threshml.c:    for (i = 1; i <= ((chars2 - 1) / 60 + 1); i++) {  /* ranges of characters */
threshml.c:          putc(nayme[j - 1][k], outfile);
threshml.c:        for (k = (i - 1) * 60 + 1; k <= l; k++) {     /* print characters */
threshml.c:          charstate = yy[j - 1][k - 1];
threshml.c:        exxit(-1);
threshml.c:      exxit(-1);
threshml.c:        exxit(-1);
threshml.c:      *p = treep->get_forknode(treep, nodei);
threshml.c:      (*p)->index = nodei;
threshml.c:      (*p)->tip = false;
threshml.c:      treep->nodep[(*p)->index - 1] = (*p);
threshml.c:      ((cont_node_type*)(*p))->view = (phenotype3)Malloc((long)chars * sizeof(double));
threshml.c:      *p = treep->get_forknode(treep, nodei);
threshml.c:      (*p)->index = nodei;
threshml.c:      (*p)->tip = false;
threshml.c:      treep->nodep[(*p)->index - 1] = (*p);
threshml.c:      ((cont_node_type*)(*p))->view = (phenotype3)Malloc((long)chars * sizeof(double));
threshml.c:      match_names_to_data (str, treep->nodep, p, spp);
threshml.c:      ((cont_node_type*)(*p))->view = (phenotype3)Malloc((long)chars * sizeof(double));
threshml.c:      (*p)->deltav = 0.0;
threshml.c:      (*p)->v = valyew / divisor;
threshml.c:      if ((*p)->back != NULL)
threshml.c:        (*p)->back->v = (*p)->v;
threshml.c:  if (p->tip) {        /* initially we assume cutoff is at 50% point, so ... */
threshml.c:      if (yy[p->index - 1][i] == '0')
threshml.c:        ((cont_node_type*)p)->view[i] = -0.79788456;   /* mean of left half
threshml.c:        if (yy[p->index - 1][i] == '1')
threshml.c:          ((cont_node_type*)p)->view[i] = 0.79788456;  /* mean of right half
threshml.c:          if (yy[p->index - 1][i] == '?')
threshml.c:            ((cont_node_type*)p)->view[i] = 0.0;    /* mean of the whole
threshml.c:      ((cont_node_type*)p)->view[i] = x[p->index - 1][i];    /* copy in the
threshml.c:    qq = p->next;
threshml.c:      initliabilities(qq->back);
threshml.c:      if (qq->v <= 0.0)
threshml.c:      else wt = 1/qq->v;
threshml.c:        sumnumerator[i] += wt * ((cont_node_type*)qq->back)->view[i];
threshml.c:      qq = qq->next;
threshml.c:      ((cont_node_type*)p)->view[i] = sumnumerator[i] / sumdenominator;
threshml.c:    qq = p->next;
threshml.c:        ((cont_node_type*)qq)->view[i] = ((cont_node_type*)q)->view[i];
threshml.c:      qq = qq->next;
threshml.c:  vv = p->v;
threshml.c:    zz[i] = ((cont_node_type*)p)->view[i] - ((cont_node_type*)(p->back))->view[i];
threshml.c:      sum -= zz[i]*zz[j]*FF[i][j]/vv;
threshml.c:    sumloglrt -= 0.5*sum;
threshml.c:  if (p->tip) {   /* just do the ancestor branch for a tip */
threshml.c:        q = q->next;
threshml.c:  if (p->tip) {                     /* weighted sampling of a tip value */
threshml.c:        xx[i] = ((cont_node_type*)p->back)->view[i];
threshml.c:        xx[i] = ((cont_node_type*)p)->view[i];
threshml.c:        xx[i] = ((cont_node_type*)p)->view[i];
threshml.c:        rejected = ((yy[p->index - 1][i-chars1] == '0') && (sum > 0)) ||
threshml.c:          ((yy[p->index - 1][i-chars1] == '1') && (sum < 0));
threshml.c:          sum = sum + ((xnew-xold)  /* log of ratio of densities after, before */
threshml.c:                       *(xnew+xold-2.0*((cont_node_type*)p->back)->view[i]))
threshml.c:        if (randum(seed) < exp(-sum)) {      /* else replace by new values */
threshml.c:            ((cont_node_type*)p)->view[i] = xx[i];
threshml.c:    if ((p != root) && (p->v <= 0.0))      /* If too close to have changed */
threshml.c:        ((cont_node_type*)p)->view[i] = ((cont_node_type*)(p->back))->view[i];
threshml.c:      q = q->next;
threshml.c:          if ((*q->back).v <= 0.0)
threshml.c:            wt = 1.0/(*q->back).v;
threshml.c:        q = q->next;
threshml.c:            sum = 1.0e+9*((cont_node_type*)(q->back))->view[i];
threshml.c:            sum = ((cont_node_type*)(q->back))->view[i]/(*q->back).v;
threshml.c:        q = q->next;
threshml.c:            if ((*q->back).v <= 0.0)
threshml.c:              wt = 1.0/(*q->back).v;
threshml.c:            sum = sum + wt * ((cont_node_type*)(q->back))->view[i];
threshml.c:          q = q->next;
threshml.c:        ((cont_node_type*)p)->view[i] = xx[i] =
threshml.c:        q = q->next;
threshml.c:          ((cont_node_type*)q)->view[i] = ((cont_node_type*)p)->view[i];
threshml.c:          q = q->next;
threshml.c:    q = q->next;              /* if not, don't go out the one you came from */
threshml.c:      updateliabilities(q->back);
threshml.c:      q = q->next;
threshml.c:          CC[i][j] += (((cont_node_type*)p)->view[i]-((cont_node_type*)(p->back))->view[i])
threshml.c:            * (((cont_node_type*)p)->view[j]-((cont_node_type*)(p->back))->view[j]) / (*p).v;
threshml.c:    q = p->next;
threshml.c:      updatecovariances(q->back);
threshml.c:      q = q->next;
threshml.c:     is the lower-triangular square root of its previous value */
threshml.c:  for (i = 0; i < chars; i++) { /* in-place Cholesky decomposition of C */
threshml.c:    for (j = 0; j <= i-1; j++)
threshml.c:      temp = sqrt(c[i][i] - sum);
threshml.c:      if (fabs(temp) < 1.0E-12)
threshml.c:        c[j][i] = (c[j][i] - sum)/temp;
threshml.c:  } /* c is now the lower-triangular square root of its previous value */
threshml.c:  /* Gauss-Jordan reduction -- invert matrix a in place, overwriting previous
threshml.c:          a[j][k] -= temp * a[i][k];
threshml.c:  /* use the inferred covariances, square-rooting them, to correct the
threshml.c:      BB[i][j] = sum;  /* don't update it right away as AA gets re-used */
threshml.c:    liabvars[i] = sqrt(liabvars[i]);     /* and square-root it */
threshml.c:      ((cont_node_type*)curtree.nodep[i])->view[j] /= liabvars[j];
threshml.c:      norm += (AA[i][j]-BB[i][j])*(AA[i][j]-BB[i][j]);
threshml.c:  if (norm > 0.0)               /* norm is the root-sum-of-squares */
threshml.c:  invert(CC);                           /* do an in-place inverse of CC */
threshml.c:        sum += CC[j][k]*((cont_node_type*)curtree.nodep[i])->view[k];
threshml.c:      ((cont_node_type*)curtree.nodep[i])->view[j] = xx[j];
threshml.c:        ((cont_node_type*)curtree.nodep[i])->view[j] /= liabvars[j];
threshml.c:      d = ctheta * a[i - 1][k] + stheta * a[j - 1][k];
threshml.c:      a[j - 1][k] = ctheta * a[j - 1][k] - stheta * a[i - 1][k];
threshml.c:      a[i - 1][k] = d;
threshml.c:      d = ctheta * a[k][i - 1] + stheta * a[k][j - 1];
threshml.c:      a[k][j - 1] = ctheta * a[k][j - 1] - stheta * a[k][i - 1];
threshml.c:      a[k][i - 1] = d;
threshml.c:      coeffs(a[i - 2][i - 1], a[i - 2][j - 1], &c, &s, accuracy);
threshml.c:{ /* QR eigenvalue-finder */
threshml.c:  for (i = n; i >= 2; i--) {
threshml.c:      TEMP = a[i - 2][i - 2] - a[i - 1][i - 1];
threshml.c:      TEMP1 = a[i - 1][i - 2];
threshml.c:      approx = a[i - 2][i - 2] + a[i - 1][i - 1];
threshml.c:      if (a[i - 1][i - 1] < a[i - 2][i - 2])
threshml.c:        approx = (approx - d) / 2.0;
threshml.c:        a[j][j] -= approx;
threshml.c:        coeffs(a[j - 1][j - 1], a[j][j - 1], &c, &s, accuracy);
threshml.c:    } while (fabs(a[i - 1][i - 2]) > accuracy);
threshml.c:  accuracy = 1.0e-6;
threshml.c:      if ((j > 0) && (j%6 == 5) && ((j+1) != chars)) /* in six-column blocks */
threshml.c:  fprintf(outfile, "   --------       -----------\n");
threshml.c:    fprintf(outfile, "  %6ld        %12.6f\n", i+1, eig[chars-i-1]);
threshml.c:      BB[i][j] = eigvecs[eigorder[chars-i-1]][j];
threshml.c:  /* Gauss-Jordan log determinant calculation.
threshml.c:    if (fabs(a[i][i]) < 1.0E-37) {
threshml.c:      exxit(-1);
threshml.c:          a[j][k] -= temp * a[i][k];
threshml.c:  /* compute for next-to-last chain, if testing, the log determinants of the
threshml.c:      FF[i][j] = MM1[i][j]-MM0[i][j];
threshml.c:  loglr = -0.5*(spp-1)*(logdetMM1-logdetMM0) + log(sumlrt) - log((double)sumsteps);
threshml.c:  fprintf(outfile, "   -----         -----------------------\n");
threshml.c:  for (i = 0; i < chars-1; i++)
threshml.c:  freeview(&curtree, 2*spp-1);    /* free the nodes on the tree */
threshml.c:  freetree(&curtree.nodep, 2*spp-1);
threshml.c:      printf("------");
threshml.c:      printf("                                           ----------    --------------\n");
threshml.c:      printf("\nBurn-in: %ld updates\n", burnin);
threshml.c:      nexttolasttime = (i == (cycles-1));   /* ... the next-to-last one? */
threshml.c:      done = testing;       /* set whether doing a null-hypotheis run */
threshml.c:  funcs->node_new = cont_node_new;
threshml.c:  /* Open in binary: ftell() is broken for UNIX line-endings under WIN32 */
threshml.c:  ncases = numtrees;    /* ncases will be how many tree-data pairs are done */
treedist.c:/* Version 4.0. (c) Copyright 1993-2013 by the University of Washington.
treedist.c:                        // programs do -- it stores info with tree nodes,
treedist.c:  *lengths = pattern_array[0][tree_index]->length;
treedist.c:{ /* set treeN to be the tree_index-th tree in pattern_elm */
treedist.c:    treeN[i] = pattern_array[i][tree_index]->apattern;
treedist.c:  *pattern_size = *pattern_array[0][tree_index]->patternsize;
treedist.c:    exxit(-1);
treedist.c:      if (lengths1[index1] == -1) {
treedist.c:        exxit(-1);
treedist.c:      if (lengths2[index2] == -1) {
treedist.c:        exxit(-1);
treedist.c:            return_value += pow(lengths1[index1] - lengths2[index2], 2);
treedist.c:            return_value += fabs(lengths1[index1] - lengths2[index2]);
treedist.c:      fprintf(outfile, "------");
treedist.c:    else fprintf(outfile, "------------");
treedist.c:  if ( tree1 == 1 && ((tree2 - 1) % get_num_columns() == 0 || tree2 == 1 ))
treedist.c:    if ( (tree_pairing == ALL_IN_FIRST && tree2 + get_num_columns() - 1 < trees_in_1) ||
treedist.c:         (tree_pairing == ALL_IN_1_AND_2 && tree2 + get_num_columns() - 1 < trees_in_2))
treedist.c:        print_matrix_heading(tree2, tree2 + get_num_columns() - 1);
treedist.c:  if ( (tree2 - 1) % get_num_columns() == 0 || tree2 == 1)
treedist.c:  if ( tree1 == 1 && ((tree2 - 1) % get_num_columns() == 0 || tree2 == 1 ))
treedist.c:    if ( (tree_pairing == ALL_IN_FIRST && tree2 + get_num_columns() - 1 < trees_in_1) ||
treedist.c:         (tree_pairing == ALL_IN_1_AND_2 && tree2 + get_num_columns() - 1 < trees_in_2))
treedist.c:      print_matrix_heading(tree2, tree2 + get_num_columns() - 1);
treedist.c:  if ( (tree2 - 1) % get_num_columns() == 0 || tree2 == 1)
treedist.c:      end_tree = trees_in_1 - 1;
treedist.c:            tree_diff(treeA, treeB, length1, length2, patternsz1, patternsz2, tree_index + 1 , index2 - trees_in_1 + 1, trees_in_1, trees_in_2);
treedist.c:              tree_diff (treeA, treeB, length1, length2, patternsz1, patternsz2, index1 + 1, index2 - trees_in_1 + 1, trees_in_1, trees_in_2);
treedist.c:  long end_pattern = total_trees - 1;
treedist.c:    for (j = 0 ; j < end_pattern ; j++)   /* debug -- one off? */
treedist.c:      free (pattern_array[i][j]->apattern);
treedist.c:      free (pattern_array[i][j]->patternsize);
treedist.c:      end_tree = trees_in_1 - 1;
treedist.c:            fprintf (outfile, "Robinson-Foulds distances between adjacent pairs of trees:\n\n");
treedist.c:        printf ("Error -- cannot output adjacent pairs into a full matrix.\n");
treedist.c:            fprintf (outfile, "Robinson-Foulds distances between all pairs of trees in tree file:\n\n");
treedist.c:            fprintf (outfile, "Robinson-Foulds distances between all pairs of trees in tree file:\n\n");
treedist.c:            fprintf (outfile, "Robinson-Foulds distances between corresponding pairs of trees\n");
treedist.c:        printf ("Error -- cannot output corresponding pairs into a full matrix.\n");
treedist.c:            fprintf(outfile, "Robinson-Foulds distances between all pairs of trees\n");
treedist.c:      printf (" C     Full matrix with no headings, computer-readable\n");
treedist.c:    allocate_nodep(&treeForNodes->nodep, intree2, &spp);
treedist.c:    treeread(treeForNodes, intree2, &treeForNodes->root, treeForNodes->nodep, &goteof, &firsttree2, &nextnode, &haslengths, initconsnode, false, -1);
treedist.c:    missingname(treeForNodes->root);
treedist.c:      reroot(treeForNodes, treeForNodes->nodep[outgrno - 1], &nextnode);
treedist.c:    accumulate(treeForNodes, treeForNodes->root);
treedist.c:    // BUG.966 -- original code emptied treeForNodes->[nodep] here
treedist.c:        printf("Robinson-Foulds Distance\n");
treedist.c:        exxit(-1);
treedist.c:  lasti  = -1;
treedist.c:  // we only need enough for spp-1 groups for each tree
treedist.c:  maxgrp = 4*(tip_count-1);
treedist.c:    // Here deal with the adjacent or all-in-first pairing difference computation
treedist.c:      // debug   -- not clear we need to free this anyway
treedist.c:  funcs->node_new = cons_node_new;
treedist.c:  funcs->node_new = cons_node_new;
treedist.c:  /* Open in binary: ftell() is broken for UNIX line-endings under WIN32 */
treedist.c:  /* Initialize option-based variables, then ask for changes regarding
treedist.c:    // Open in binary: ftell() is broken for UNIX line-endings under WIN32
usertree.c:/* Version 4.0. (c) Copyright 2012-2013 by the University of Washington.
usertree.c:/* Object for reading line-oriented files in general */
usertree.c:  reader->buf = Malloc(sizeof(char) * LINE_BUFSIZE);
usertree.c:  reader->fp = fp;
usertree.c:  reader->bufsize = sizeof(char) * LINE_BUFSIZE;
usertree.c:  reader->next = reader->buf;
usertree.c:  reader->line = 1;
usertree.c:  fclose(reader->fp);
usertree.c:  free(reader->buf);
usertree.c:  ch = getc(fr->fp);
usertree.c:    fr->line++;
usertree.c:  nfr->filereader = fr;
usertree.c:  nfr->paren_level = 0;
usertree.c:  nfr->comment_level = 0;
usertree.c:  nfr->is_quoted = false;
usertree.c:  nfr->treenum = 0;
usertree.c:  Filereader_close(&nfr->filereader);
usertree.c:   * assuming pre: nfr->paren_level == 0 */
usertree.c:    if ( ch = '(' && nfr->comment_level == 0 ) {
usertree.c:  while ( (ch = Filereader_getchar(nfr->filereader)) != EOF ) {
usertree.c:      if ( nfr->paren_level > 0 && nfr->comment_level == 0 ) {
usertree.c:        nfr->is_quoted = !nfr->is_quoted;
usertree.c:    else if ( !nfr->is_quoted ) {
usertree.c:        nfr->comment_level++;
usertree.c:        if ( !NEWICK_NESTED_COMMENTS && nfr->comment_level > 1 )
usertree.c:          nfr->comment_level = 1;
usertree.c:        nfr->comment_level--;
usertree.c:        if ( nfr->comment_level < 0 ) {
usertree.c:          nfr->comment_level = 0;
usertree.c:            tree_parse_error("mismatched ']'", nfr->filereader->line, nfr->treenum);
usertree.c:      else if ( nfr->comment_level == 0 ) {
usertree.c:          nfr->paren_level++;
usertree.c:          nfr->paren_level--;
usertree.c:          if ( nfr->paren_level < 0 ) {
usertree.c:            nfr->paren_level = 0;
usertree.c:            tree_parse_error("mismatched parentheses", nfr->filereader->line, nfr->treenum);
usertree.c:            nfr->ntrees++;
usertree.c:            nfr->treenum++;
usertree.c:                             nfr->filereader->line, nfr->treenum);
usertree.c:    /* Add non-comment characters to string. */
usertree.c:    if ( nfr->comment_level == 0 ) {
usertree.c:  ut->tree = treestr;
usertree.c:  ut->nnodes = nnodes;
usertree.c:  ut->nspecies = nspecies;
usertree.c:      /* Count the semicolons outside parens, (possibly-nested)
usertree.c:       * comments [[]] and single-quoted '' names.
usertree.c:       * TPS_PRE  - Before first '(', only comments are special
usertree.c:       * TPS_SUB  - In tree, expecting label or subtree
usertree.c:       * TPS_LEN  - Expecting ",:)"
usertree.c:       * TPS_LEN2 - Expecting number
usertree.c:       * TPS_END  - Expecting ":;"
usertree.c:       * TPS_RLEN - Expecting number
usertree.c:       * TPS_END2 - Expecting ;
usertree.c:              comment_level--;
usertree.c:                paren_level--;
usertree.c:  exit(-1);
wagner.c:/* Version 4.0. (c) Copyright 1993-2013 by the University of Washington.
wagner.c:      exxit(-1);
wagner.c:      wagner0[k - 1] = (long)wagner0[k - 1] | (1L << j);
wagner.c:    if (((1L << l) & wagner[k - 1]) != 0)
wagner.c:      l0 = p->next->back->fulstte0[i];
wagner.c:      l1 = p->next->back->fulstte1[i];
wagner.c:      r0 = p->next->next->back->fulstte0[i];
wagner.c:      r1 = p->next->next->back->fulstte1[i];
wagner.c:      l0 = p->next->back->empstte0[i];
wagner.c:      l1 = p->next->back->empstte1[i];
wagner.c:      r0 = p->next->next->back->empstte0[i];
wagner.c:      r1 = p->next->next->back->empstte1[i];
wagner.c:      p->fulstte1[i] = (l1 | r1) & (~(st & (wa | za)));
wagner.c:      p->fulstte0[i] = (l0 | r0) & (~(st & (wa | (fullset & (~za)))));
wagner.c:      p->fulsteps[i] = st;
wagner.c:      p->empstte1[i] = (l1 | r1) & (~(st & (wa | za)));
wagner.c:      p->empstte0[i] = (l0 | r0) & (~(st & (wa | (fullset & (~za)))));
wagner.c:      p->empsteps[i] = st;
wagner.c:    if (((1L << l) & stps[j - 1]) != 0) {
wagner.c:      if (((1L << l) & zeroanc[j - 1]) != 0)
wagner.c:  if (p->tip)
wagner.c:  postorder(p->next->back, fullset, full, wagner, zeroanc);
wagner.c:  postorder(p->next->next->back, fullset, full, wagner, zeroanc);
wagner.c:  if (!p->visited) {
wagner.c:    if (!full) p->visited = true;
wagner.c:  if (p->tip)
wagner.c:  cpostorder(p->next->back, full, zeroanc, numszero, numsone);
wagner.c:  cpostorder(p->next->next->back, full, zeroanc, numszero, numsone);
wagner.c:    count(p->fulsteps, zeroanc, numszero, numsone);
wagner.c:    count(p->empsteps, zeroanc, numszero, numsone);
wagner.c:  if (r->tip)
wagner.c:  filltrav(r->next->back, fullset, full, wagner, zeroanc);
wagner.c:  filltrav(r->next->next->back, fullset, full, wagner, zeroanc);
wagner.c:  if (htrav->bottom) {
wagner.c:    fprintf(outfile, "%3ld    ", htrav->r->back->index - spp);
wagner.c:  if (htrav->r->tip) {
wagner.c:      putc(nayme[htrav->r->index - 1][i], outfile);
wagner.c:    fprintf(outfile, "%4ld      ", htrav->r->index - spp);
wagner.c:  if (htrav->bottom && noroot && !didreroot)
wagner.c:  else if (htrav->nonzero)
wagner.c:  else if (htrav->maybe)
wagner.c:    k = (j - 1) / bits + 1;
wagner.c:    l = (j - 1) % bits + 1;
wagner.c:    dot = (((1L << l) & wagner[k - 1]) == 0 && guess[j - 1] == '?');
wagner.c:    s0 = (((1L << l) & htrav->r->empstte0[k - 1]) != 0);
wagner.c:    s1 = (((1L << l) & htrav->r->empstte1[k - 1]) != 0);
wagner.c:    a0 = (((1L << l) & htrav->zerobelow->bits_[k - 1]) != 0);
wagner.c:    a1 = (((1L << l) & htrav->onebelow->bits_[k - 1]) != 0);
wagner.c:    dot = (dot || ((!htrav->bottom || !noroot || didreroot) && a1 == s1 &&
wagner.c:  vars.bottom = (vars.r->back == NULL);
wagner.c:    memcpy(vars.zerobelow->bits_, zeroanc, words * sizeof(long));
wagner.c:    memcpy(vars.onebelow->bits_, oneanc, words * sizeof(long));
wagner.c:    memcpy(vars.zerobelow->bits_, treenode[vars.r->back->index - 1]->empstte0, words * sizeof(long));
wagner.c:    memcpy(vars.onebelow->bits_, treenode[vars.r->back->index - 1]->empstte1, words * sizeof(long));
wagner.c:    s0 = vars.r->empstte0[i];
wagner.c:    s1 = vars.r->empstte1[i];
wagner.c:    a0 = vars.zerobelow->bits_[i];
wagner.c:    a1 = vars.onebelow->bits_[i];
wagner.c:    if (!vars.r->tip) {
wagner.c:      l0 = vars.r->next->back->empstte0[i];
wagner.c:      l1 = vars.r->next->back->empstte1[i];
wagner.c:      r0 = vars.r->next->next->back->empstte0[i];
wagner.c:      r1 = vars.r->next->next->back->empstte1[i];
wagner.c:      vars.r->empstte0[i] = s0;
wagner.c:      vars.r->empstte1[i] = s1;
wagner.c:  if (!vars.r->tip) {
wagner.c:    hyptrav(vars.r->next->back, unknown, dohyp, fullset, noroot, didreroot,
wagner.c:    hyptrav(vars.r->next->next->back, unknown, dohyp, fullset, noroot,
wagner.c:      zeroanc[j - 1] = ((long)zeroanc[j - 1]) | (1L << k);
wagner.c:      oneanc[j - 1] = ((long)oneanc[j - 1]) | (1L << k);
wagner.c:    unknown = (unknown || ((((1L << k) & wagner[j - 1]) == 0) && guess[i] == '?'));
wagner.c:  if (i == p->ycoord && p == root) {
wagner.c:    if (p->index - spp >= 10)
wagner.c:      fprintf(outfile, "-%2ld", p->index - spp);
wagner.c:      fprintf(outfile, "--%ld", p->index - spp);
wagner.c:    if (!p->tip) {
wagner.c:      r = p->next;
wagner.c:        if (i >= r->back->ymin && i <= r->back->ymax) {
wagner.c:          q = r->back;
wagner.c:        r = r->next;
wagner.c:      first = p->next->back;
wagner.c:      r = p->next;
wagner.c:      while (r->next != p)
wagner.c:        r = r->next;
wagner.c:      last = r->back;
wagner.c:    n = (long)(scale * (p->xcoord - q->xcoord) + 0.5);
wagner.c:    if (n < 3 && !q->tip)
wagner.c:      n--;
wagner.c:    if (q->ycoord == i && !done) {
wagner.c:      if (!q->tip) {
wagner.c:        for (j = 1; j <= n - 2; j++)
wagner.c:          putc('-', outfile);
wagner.c:        if (q->index - spp >= 10)
wagner.c:          fprintf(outfile, "%2ld", q->index - spp);
wagner.c:          fprintf(outfile, "-%ld", q->index - spp);
wagner.c:          putc('-', outfile);
wagner.c:    } else if (!p->tip) {
wagner.c:      if (last->ycoord > i && first->ycoord < i && i != p->ycoord) {
wagner.c:  if (p->ycoord == i && p->tip) {
wagner.c:      putc(nayme[p->index - 1][j], outfile);
wagner.c:  for (i = 1; i <= (tipy - down); i++)
wagner.c:  fprintf(outfile, "\n     *-----------------------------------------\n");
wagner.c:        fprintf(outfile, "%4ld", numsteps[k - 1] + extras[k - 1]);
